// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `core/Tron.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

///  AccountId, (name, address) use name, (null, address) use address, (name, null) use name,
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.AccountId)
pub struct AccountId {
    // message fields
    // @@protoc_insertion_point(field:protocol.AccountId.name)
    pub name: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.AccountId.address)
    pub address: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.AccountId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AccountId {
    fn default() -> &'a AccountId {
        <AccountId as ::protobuf::Message>::default_instance()
    }
}

impl AccountId {
    pub fn new() -> AccountId {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &AccountId| { &m.name },
            |m: &mut AccountId| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &AccountId| { &m.address },
            |m: &mut AccountId| { &mut m.address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AccountId>(
            "AccountId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AccountId {
    const NAME: &'static str = "AccountId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_bytes()?;
                },
                18 => {
                    self.address = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.name);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_bytes(1, &self.name)?;
        }
        if !self.address.is_empty() {
            os.write_bytes(2, &self.address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AccountId {
        AccountId::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AccountId {
        static instance: AccountId = AccountId {
            name: ::std::vec::Vec::new(),
            address: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AccountId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AccountId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AccountId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  vote message
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.Vote)
pub struct Vote {
    // message fields
    ///  the super rep address
    // @@protoc_insertion_point(field:protocol.Vote.vote_address)
    pub vote_address: ::std::vec::Vec<u8>,
    ///  the vote num to this super rep.
    // @@protoc_insertion_point(field:protocol.Vote.vote_count)
    pub vote_count: i64,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.Vote.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Vote {
    fn default() -> &'a Vote {
        <Vote as ::protobuf::Message>::default_instance()
    }
}

impl Vote {
    pub fn new() -> Vote {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vote_address",
            |m: &Vote| { &m.vote_address },
            |m: &mut Vote| { &mut m.vote_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vote_count",
            |m: &Vote| { &m.vote_count },
            |m: &mut Vote| { &mut m.vote_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Vote>(
            "Vote",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Vote {
    const NAME: &'static str = "Vote";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.vote_address = is.read_bytes()?;
                },
                16 => {
                    self.vote_count = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.vote_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.vote_address);
        }
        if self.vote_count != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.vote_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.vote_address.is_empty() {
            os.write_bytes(1, &self.vote_address)?;
        }
        if self.vote_count != 0 {
            os.write_int64(2, self.vote_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Vote {
        Vote::new()
    }

    fn clear(&mut self) {
        self.vote_address.clear();
        self.vote_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Vote {
        static instance: Vote = Vote {
            vote_address: ::std::vec::Vec::new(),
            vote_count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Vote {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Vote").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Vote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vote {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Proposal
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.Proposal)
pub struct Proposal {
    // message fields
    // @@protoc_insertion_point(field:protocol.Proposal.proposal_id)
    pub proposal_id: i64,
    // @@protoc_insertion_point(field:protocol.Proposal.proposer_address)
    pub proposer_address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.Proposal.parameters)
    pub parameters: ::std::collections::HashMap<i64, i64>,
    // @@protoc_insertion_point(field:protocol.Proposal.expiration_time)
    pub expiration_time: i64,
    // @@protoc_insertion_point(field:protocol.Proposal.create_time)
    pub create_time: i64,
    // @@protoc_insertion_point(field:protocol.Proposal.approvals)
    pub approvals: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:protocol.Proposal.state)
    pub state: ::protobuf::EnumOrUnknown<proposal::State>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.Proposal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Proposal {
    fn default() -> &'a Proposal {
        <Proposal as ::protobuf::Message>::default_instance()
    }
}

impl Proposal {
    pub fn new() -> Proposal {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proposal_id",
            |m: &Proposal| { &m.proposal_id },
            |m: &mut Proposal| { &mut m.proposal_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proposer_address",
            |m: &Proposal| { &m.proposer_address },
            |m: &mut Proposal| { &mut m.proposer_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "parameters",
            |m: &Proposal| { &m.parameters },
            |m: &mut Proposal| { &mut m.parameters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "expiration_time",
            |m: &Proposal| { &m.expiration_time },
            |m: &mut Proposal| { &mut m.expiration_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "create_time",
            |m: &Proposal| { &m.create_time },
            |m: &mut Proposal| { &mut m.create_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "approvals",
            |m: &Proposal| { &m.approvals },
            |m: &mut Proposal| { &mut m.approvals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &Proposal| { &m.state },
            |m: &mut Proposal| { &mut m.state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Proposal>(
            "Proposal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Proposal {
    const NAME: &'static str = "Proposal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.proposal_id = is.read_int64()?;
                },
                18 => {
                    self.proposer_address = is.read_bytes()?;
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_int64()?,
                            16 => value = is.read_int64()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.parameters.insert(key, value);
                },
                32 => {
                    self.expiration_time = is.read_int64()?;
                },
                40 => {
                    self.create_time = is.read_int64()?;
                },
                50 => {
                    self.approvals.push(is.read_bytes()?);
                },
                56 => {
                    self.state = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.proposal_id != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.proposal_id);
        }
        if !self.proposer_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.proposer_address);
        }
        for (k, v) in &self.parameters {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int64_size(1, *k);
            entry_size += ::protobuf::rt::int64_size(2, *v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if self.expiration_time != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.expiration_time);
        }
        if self.create_time != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.create_time);
        }
        for value in &self.approvals {
            my_size += ::protobuf::rt::bytes_size(6, &value);
        };
        if self.state != ::protobuf::EnumOrUnknown::new(proposal::State::PENDING) {
            my_size += ::protobuf::rt::int32_size(7, self.state.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.proposal_id != 0 {
            os.write_int64(1, self.proposal_id)?;
        }
        if !self.proposer_address.is_empty() {
            os.write_bytes(2, &self.proposer_address)?;
        }
        for (k, v) in &self.parameters {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int64_size(1, *k);
            entry_size += ::protobuf::rt::int64_size(2, *v);
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_int64(1, *k)?;
            os.write_int64(2, *v)?;
        };
        if self.expiration_time != 0 {
            os.write_int64(4, self.expiration_time)?;
        }
        if self.create_time != 0 {
            os.write_int64(5, self.create_time)?;
        }
        for v in &self.approvals {
            os.write_bytes(6, &v)?;
        };
        if self.state != ::protobuf::EnumOrUnknown::new(proposal::State::PENDING) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.state))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Proposal {
        Proposal::new()
    }

    fn clear(&mut self) {
        self.proposal_id = 0;
        self.proposer_address.clear();
        self.parameters.clear();
        self.expiration_time = 0;
        self.create_time = 0;
        self.approvals.clear();
        self.state = ::protobuf::EnumOrUnknown::new(proposal::State::PENDING);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Proposal {
        static instance: ::protobuf::rt::Lazy<Proposal> = ::protobuf::rt::Lazy::new();
        instance.get(Proposal::new)
    }
}

impl ::protobuf::MessageFull for Proposal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Proposal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Proposal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Proposal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Proposal`
pub mod proposal {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:protocol.Proposal.State)
    pub enum State {
        // @@protoc_insertion_point(enum_value:protocol.Proposal.State.PENDING)
        PENDING = 0,
        // @@protoc_insertion_point(enum_value:protocol.Proposal.State.DISAPPROVED)
        DISAPPROVED = 1,
        // @@protoc_insertion_point(enum_value:protocol.Proposal.State.APPROVED)
        APPROVED = 2,
        // @@protoc_insertion_point(enum_value:protocol.Proposal.State.CANCELED)
        CANCELED = 3,
    }

    impl ::protobuf::Enum for State {
        const NAME: &'static str = "State";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<State> {
            match value {
                0 => ::std::option::Option::Some(State::PENDING),
                1 => ::std::option::Option::Some(State::DISAPPROVED),
                2 => ::std::option::Option::Some(State::APPROVED),
                3 => ::std::option::Option::Some(State::CANCELED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [State] = &[
            State::PENDING,
            State::DISAPPROVED,
            State::APPROVED,
            State::CANCELED,
        ];
    }

    impl ::protobuf::EnumFull for State {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Proposal.State").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for State {
        fn default() -> Self {
            State::PENDING
        }
    }

    impl State {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<State>("Proposal.State")
        }
    }
}

///  Exchange
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.Exchange)
pub struct Exchange {
    // message fields
    // @@protoc_insertion_point(field:protocol.Exchange.exchange_id)
    pub exchange_id: i64,
    // @@protoc_insertion_point(field:protocol.Exchange.creator_address)
    pub creator_address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.Exchange.create_time)
    pub create_time: i64,
    // @@protoc_insertion_point(field:protocol.Exchange.first_token_id)
    pub first_token_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.Exchange.first_token_balance)
    pub first_token_balance: i64,
    // @@protoc_insertion_point(field:protocol.Exchange.second_token_id)
    pub second_token_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.Exchange.second_token_balance)
    pub second_token_balance: i64,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.Exchange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Exchange {
    fn default() -> &'a Exchange {
        <Exchange as ::protobuf::Message>::default_instance()
    }
}

impl Exchange {
    pub fn new() -> Exchange {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exchange_id",
            |m: &Exchange| { &m.exchange_id },
            |m: &mut Exchange| { &mut m.exchange_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "creator_address",
            |m: &Exchange| { &m.creator_address },
            |m: &mut Exchange| { &mut m.creator_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "create_time",
            |m: &Exchange| { &m.create_time },
            |m: &mut Exchange| { &mut m.create_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "first_token_id",
            |m: &Exchange| { &m.first_token_id },
            |m: &mut Exchange| { &mut m.first_token_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "first_token_balance",
            |m: &Exchange| { &m.first_token_balance },
            |m: &mut Exchange| { &mut m.first_token_balance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "second_token_id",
            |m: &Exchange| { &m.second_token_id },
            |m: &mut Exchange| { &mut m.second_token_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "second_token_balance",
            |m: &Exchange| { &m.second_token_balance },
            |m: &mut Exchange| { &mut m.second_token_balance },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Exchange>(
            "Exchange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Exchange {
    const NAME: &'static str = "Exchange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.exchange_id = is.read_int64()?;
                },
                18 => {
                    self.creator_address = is.read_bytes()?;
                },
                24 => {
                    self.create_time = is.read_int64()?;
                },
                50 => {
                    self.first_token_id = is.read_bytes()?;
                },
                56 => {
                    self.first_token_balance = is.read_int64()?;
                },
                66 => {
                    self.second_token_id = is.read_bytes()?;
                },
                72 => {
                    self.second_token_balance = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.exchange_id != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.exchange_id);
        }
        if !self.creator_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.creator_address);
        }
        if self.create_time != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.create_time);
        }
        if !self.first_token_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.first_token_id);
        }
        if self.first_token_balance != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.first_token_balance);
        }
        if !self.second_token_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.second_token_id);
        }
        if self.second_token_balance != 0 {
            my_size += ::protobuf::rt::int64_size(9, self.second_token_balance);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.exchange_id != 0 {
            os.write_int64(1, self.exchange_id)?;
        }
        if !self.creator_address.is_empty() {
            os.write_bytes(2, &self.creator_address)?;
        }
        if self.create_time != 0 {
            os.write_int64(3, self.create_time)?;
        }
        if !self.first_token_id.is_empty() {
            os.write_bytes(6, &self.first_token_id)?;
        }
        if self.first_token_balance != 0 {
            os.write_int64(7, self.first_token_balance)?;
        }
        if !self.second_token_id.is_empty() {
            os.write_bytes(8, &self.second_token_id)?;
        }
        if self.second_token_balance != 0 {
            os.write_int64(9, self.second_token_balance)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Exchange {
        Exchange::new()
    }

    fn clear(&mut self) {
        self.exchange_id = 0;
        self.creator_address.clear();
        self.create_time = 0;
        self.first_token_id.clear();
        self.first_token_balance = 0;
        self.second_token_id.clear();
        self.second_token_balance = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Exchange {
        static instance: Exchange = Exchange {
            exchange_id: 0,
            creator_address: ::std::vec::Vec::new(),
            create_time: 0,
            first_token_id: ::std::vec::Vec::new(),
            first_token_balance: 0,
            second_token_id: ::std::vec::Vec::new(),
            second_token_balance: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Exchange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Exchange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Exchange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Exchange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  market
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.MarketOrder)
pub struct MarketOrder {
    // message fields
    // @@protoc_insertion_point(field:protocol.MarketOrder.order_id)
    pub order_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.MarketOrder.owner_address)
    pub owner_address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.MarketOrder.create_time)
    pub create_time: i64,
    // @@protoc_insertion_point(field:protocol.MarketOrder.sell_token_id)
    pub sell_token_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.MarketOrder.sell_token_quantity)
    pub sell_token_quantity: i64,
    // @@protoc_insertion_point(field:protocol.MarketOrder.buy_token_id)
    pub buy_token_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.MarketOrder.buy_token_quantity)
    pub buy_token_quantity: i64,
    // @@protoc_insertion_point(field:protocol.MarketOrder.sell_token_quantity_remain)
    pub sell_token_quantity_remain: i64,
    ///  When state != ACTIVE and sell_token_quantity_return !=0,
    /// it means that some sell tokens are returned to the account due to insufficient remaining amount
    // @@protoc_insertion_point(field:protocol.MarketOrder.sell_token_quantity_return)
    pub sell_token_quantity_return: i64,
    // @@protoc_insertion_point(field:protocol.MarketOrder.state)
    pub state: ::protobuf::EnumOrUnknown<market_order::State>,
    // @@protoc_insertion_point(field:protocol.MarketOrder.prev)
    pub prev: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.MarketOrder.next)
    pub next: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.MarketOrder.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MarketOrder {
    fn default() -> &'a MarketOrder {
        <MarketOrder as ::protobuf::Message>::default_instance()
    }
}

impl MarketOrder {
    pub fn new() -> MarketOrder {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "order_id",
            |m: &MarketOrder| { &m.order_id },
            |m: &mut MarketOrder| { &mut m.order_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "owner_address",
            |m: &MarketOrder| { &m.owner_address },
            |m: &mut MarketOrder| { &mut m.owner_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "create_time",
            |m: &MarketOrder| { &m.create_time },
            |m: &mut MarketOrder| { &mut m.create_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sell_token_id",
            |m: &MarketOrder| { &m.sell_token_id },
            |m: &mut MarketOrder| { &mut m.sell_token_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sell_token_quantity",
            |m: &MarketOrder| { &m.sell_token_quantity },
            |m: &mut MarketOrder| { &mut m.sell_token_quantity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buy_token_id",
            |m: &MarketOrder| { &m.buy_token_id },
            |m: &mut MarketOrder| { &mut m.buy_token_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buy_token_quantity",
            |m: &MarketOrder| { &m.buy_token_quantity },
            |m: &mut MarketOrder| { &mut m.buy_token_quantity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sell_token_quantity_remain",
            |m: &MarketOrder| { &m.sell_token_quantity_remain },
            |m: &mut MarketOrder| { &mut m.sell_token_quantity_remain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sell_token_quantity_return",
            |m: &MarketOrder| { &m.sell_token_quantity_return },
            |m: &mut MarketOrder| { &mut m.sell_token_quantity_return },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &MarketOrder| { &m.state },
            |m: &mut MarketOrder| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "prev",
            |m: &MarketOrder| { &m.prev },
            |m: &mut MarketOrder| { &mut m.prev },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next",
            |m: &MarketOrder| { &m.next },
            |m: &mut MarketOrder| { &mut m.next },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MarketOrder>(
            "MarketOrder",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MarketOrder {
    const NAME: &'static str = "MarketOrder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.order_id = is.read_bytes()?;
                },
                18 => {
                    self.owner_address = is.read_bytes()?;
                },
                24 => {
                    self.create_time = is.read_int64()?;
                },
                34 => {
                    self.sell_token_id = is.read_bytes()?;
                },
                40 => {
                    self.sell_token_quantity = is.read_int64()?;
                },
                50 => {
                    self.buy_token_id = is.read_bytes()?;
                },
                56 => {
                    self.buy_token_quantity = is.read_int64()?;
                },
                72 => {
                    self.sell_token_quantity_remain = is.read_int64()?;
                },
                80 => {
                    self.sell_token_quantity_return = is.read_int64()?;
                },
                88 => {
                    self.state = is.read_enum_or_unknown()?;
                },
                98 => {
                    self.prev = is.read_bytes()?;
                },
                106 => {
                    self.next = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.order_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.order_id);
        }
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.owner_address);
        }
        if self.create_time != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.create_time);
        }
        if !self.sell_token_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.sell_token_id);
        }
        if self.sell_token_quantity != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.sell_token_quantity);
        }
        if !self.buy_token_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.buy_token_id);
        }
        if self.buy_token_quantity != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.buy_token_quantity);
        }
        if self.sell_token_quantity_remain != 0 {
            my_size += ::protobuf::rt::int64_size(9, self.sell_token_quantity_remain);
        }
        if self.sell_token_quantity_return != 0 {
            my_size += ::protobuf::rt::int64_size(10, self.sell_token_quantity_return);
        }
        if self.state != ::protobuf::EnumOrUnknown::new(market_order::State::ACTIVE) {
            my_size += ::protobuf::rt::int32_size(11, self.state.value());
        }
        if !self.prev.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.prev);
        }
        if !self.next.is_empty() {
            my_size += ::protobuf::rt::bytes_size(13, &self.next);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.order_id.is_empty() {
            os.write_bytes(1, &self.order_id)?;
        }
        if !self.owner_address.is_empty() {
            os.write_bytes(2, &self.owner_address)?;
        }
        if self.create_time != 0 {
            os.write_int64(3, self.create_time)?;
        }
        if !self.sell_token_id.is_empty() {
            os.write_bytes(4, &self.sell_token_id)?;
        }
        if self.sell_token_quantity != 0 {
            os.write_int64(5, self.sell_token_quantity)?;
        }
        if !self.buy_token_id.is_empty() {
            os.write_bytes(6, &self.buy_token_id)?;
        }
        if self.buy_token_quantity != 0 {
            os.write_int64(7, self.buy_token_quantity)?;
        }
        if self.sell_token_quantity_remain != 0 {
            os.write_int64(9, self.sell_token_quantity_remain)?;
        }
        if self.sell_token_quantity_return != 0 {
            os.write_int64(10, self.sell_token_quantity_return)?;
        }
        if self.state != ::protobuf::EnumOrUnknown::new(market_order::State::ACTIVE) {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&self.state))?;
        }
        if !self.prev.is_empty() {
            os.write_bytes(12, &self.prev)?;
        }
        if !self.next.is_empty() {
            os.write_bytes(13, &self.next)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MarketOrder {
        MarketOrder::new()
    }

    fn clear(&mut self) {
        self.order_id.clear();
        self.owner_address.clear();
        self.create_time = 0;
        self.sell_token_id.clear();
        self.sell_token_quantity = 0;
        self.buy_token_id.clear();
        self.buy_token_quantity = 0;
        self.sell_token_quantity_remain = 0;
        self.sell_token_quantity_return = 0;
        self.state = ::protobuf::EnumOrUnknown::new(market_order::State::ACTIVE);
        self.prev.clear();
        self.next.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MarketOrder {
        static instance: MarketOrder = MarketOrder {
            order_id: ::std::vec::Vec::new(),
            owner_address: ::std::vec::Vec::new(),
            create_time: 0,
            sell_token_id: ::std::vec::Vec::new(),
            sell_token_quantity: 0,
            buy_token_id: ::std::vec::Vec::new(),
            buy_token_quantity: 0,
            sell_token_quantity_remain: 0,
            sell_token_quantity_return: 0,
            state: ::protobuf::EnumOrUnknown::from_i32(0),
            prev: ::std::vec::Vec::new(),
            next: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MarketOrder {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MarketOrder").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MarketOrder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MarketOrder {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MarketOrder`
pub mod market_order {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:protocol.MarketOrder.State)
    pub enum State {
        // @@protoc_insertion_point(enum_value:protocol.MarketOrder.State.ACTIVE)
        ACTIVE = 0,
        // @@protoc_insertion_point(enum_value:protocol.MarketOrder.State.INACTIVE)
        INACTIVE = 1,
        // @@protoc_insertion_point(enum_value:protocol.MarketOrder.State.CANCELED)
        CANCELED = 2,
    }

    impl ::protobuf::Enum for State {
        const NAME: &'static str = "State";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<State> {
            match value {
                0 => ::std::option::Option::Some(State::ACTIVE),
                1 => ::std::option::Option::Some(State::INACTIVE),
                2 => ::std::option::Option::Some(State::CANCELED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [State] = &[
            State::ACTIVE,
            State::INACTIVE,
            State::CANCELED,
        ];
    }

    impl ::protobuf::EnumFull for State {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("MarketOrder.State").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for State {
        fn default() -> Self {
            State::ACTIVE
        }
    }

    impl State {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<State>("MarketOrder.State")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.MarketOrderList)
pub struct MarketOrderList {
    // message fields
    // @@protoc_insertion_point(field:protocol.MarketOrderList.orders)
    pub orders: ::std::vec::Vec<MarketOrder>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.MarketOrderList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MarketOrderList {
    fn default() -> &'a MarketOrderList {
        <MarketOrderList as ::protobuf::Message>::default_instance()
    }
}

impl MarketOrderList {
    pub fn new() -> MarketOrderList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "orders",
            |m: &MarketOrderList| { &m.orders },
            |m: &mut MarketOrderList| { &mut m.orders },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MarketOrderList>(
            "MarketOrderList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MarketOrderList {
    const NAME: &'static str = "MarketOrderList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.orders.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.orders {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MarketOrderList {
        MarketOrderList::new()
    }

    fn clear(&mut self) {
        self.orders.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MarketOrderList {
        static instance: MarketOrderList = MarketOrderList {
            orders: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MarketOrderList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MarketOrderList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MarketOrderList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MarketOrderList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.MarketOrderPairList)
pub struct MarketOrderPairList {
    // message fields
    // @@protoc_insertion_point(field:protocol.MarketOrderPairList.orderPair)
    pub orderPair: ::std::vec::Vec<MarketOrderPair>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.MarketOrderPairList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MarketOrderPairList {
    fn default() -> &'a MarketOrderPairList {
        <MarketOrderPairList as ::protobuf::Message>::default_instance()
    }
}

impl MarketOrderPairList {
    pub fn new() -> MarketOrderPairList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "orderPair",
            |m: &MarketOrderPairList| { &m.orderPair },
            |m: &mut MarketOrderPairList| { &mut m.orderPair },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MarketOrderPairList>(
            "MarketOrderPairList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MarketOrderPairList {
    const NAME: &'static str = "MarketOrderPairList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.orderPair.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.orderPair {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.orderPair {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MarketOrderPairList {
        MarketOrderPairList::new()
    }

    fn clear(&mut self) {
        self.orderPair.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MarketOrderPairList {
        static instance: MarketOrderPairList = MarketOrderPairList {
            orderPair: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MarketOrderPairList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MarketOrderPairList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MarketOrderPairList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MarketOrderPairList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.MarketOrderPair)
pub struct MarketOrderPair {
    // message fields
    // @@protoc_insertion_point(field:protocol.MarketOrderPair.sell_token_id)
    pub sell_token_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.MarketOrderPair.buy_token_id)
    pub buy_token_id: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.MarketOrderPair.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MarketOrderPair {
    fn default() -> &'a MarketOrderPair {
        <MarketOrderPair as ::protobuf::Message>::default_instance()
    }
}

impl MarketOrderPair {
    pub fn new() -> MarketOrderPair {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sell_token_id",
            |m: &MarketOrderPair| { &m.sell_token_id },
            |m: &mut MarketOrderPair| { &mut m.sell_token_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buy_token_id",
            |m: &MarketOrderPair| { &m.buy_token_id },
            |m: &mut MarketOrderPair| { &mut m.buy_token_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MarketOrderPair>(
            "MarketOrderPair",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MarketOrderPair {
    const NAME: &'static str = "MarketOrderPair";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sell_token_id = is.read_bytes()?;
                },
                18 => {
                    self.buy_token_id = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.sell_token_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.sell_token_id);
        }
        if !self.buy_token_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.buy_token_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.sell_token_id.is_empty() {
            os.write_bytes(1, &self.sell_token_id)?;
        }
        if !self.buy_token_id.is_empty() {
            os.write_bytes(2, &self.buy_token_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MarketOrderPair {
        MarketOrderPair::new()
    }

    fn clear(&mut self) {
        self.sell_token_id.clear();
        self.buy_token_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MarketOrderPair {
        static instance: MarketOrderPair = MarketOrderPair {
            sell_token_id: ::std::vec::Vec::new(),
            buy_token_id: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MarketOrderPair {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MarketOrderPair").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MarketOrderPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MarketOrderPair {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.MarketAccountOrder)
pub struct MarketAccountOrder {
    // message fields
    // @@protoc_insertion_point(field:protocol.MarketAccountOrder.owner_address)
    pub owner_address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.MarketAccountOrder.orders)
    pub orders: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:protocol.MarketAccountOrder.count)
    pub count: i64,
    // @@protoc_insertion_point(field:protocol.MarketAccountOrder.total_count)
    pub total_count: i64,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.MarketAccountOrder.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MarketAccountOrder {
    fn default() -> &'a MarketAccountOrder {
        <MarketAccountOrder as ::protobuf::Message>::default_instance()
    }
}

impl MarketAccountOrder {
    pub fn new() -> MarketAccountOrder {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "owner_address",
            |m: &MarketAccountOrder| { &m.owner_address },
            |m: &mut MarketAccountOrder| { &mut m.owner_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "orders",
            |m: &MarketAccountOrder| { &m.orders },
            |m: &mut MarketAccountOrder| { &mut m.orders },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &MarketAccountOrder| { &m.count },
            |m: &mut MarketAccountOrder| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_count",
            |m: &MarketAccountOrder| { &m.total_count },
            |m: &mut MarketAccountOrder| { &mut m.total_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MarketAccountOrder>(
            "MarketAccountOrder",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MarketAccountOrder {
    const NAME: &'static str = "MarketAccountOrder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.owner_address = is.read_bytes()?;
                },
                18 => {
                    self.orders.push(is.read_bytes()?);
                },
                24 => {
                    self.count = is.read_int64()?;
                },
                32 => {
                    self.total_count = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        for value in &self.orders {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        if self.count != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.count);
        }
        if self.total_count != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.total_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        for v in &self.orders {
            os.write_bytes(2, &v)?;
        };
        if self.count != 0 {
            os.write_int64(3, self.count)?;
        }
        if self.total_count != 0 {
            os.write_int64(4, self.total_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MarketAccountOrder {
        MarketAccountOrder::new()
    }

    fn clear(&mut self) {
        self.owner_address.clear();
        self.orders.clear();
        self.count = 0;
        self.total_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MarketAccountOrder {
        static instance: MarketAccountOrder = MarketAccountOrder {
            owner_address: ::std::vec::Vec::new(),
            orders: ::std::vec::Vec::new(),
            count: 0,
            total_count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MarketAccountOrder {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MarketAccountOrder").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MarketAccountOrder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MarketAccountOrder {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.MarketPrice)
pub struct MarketPrice {
    // message fields
    // @@protoc_insertion_point(field:protocol.MarketPrice.sell_token_quantity)
    pub sell_token_quantity: i64,
    // @@protoc_insertion_point(field:protocol.MarketPrice.buy_token_quantity)
    pub buy_token_quantity: i64,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.MarketPrice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MarketPrice {
    fn default() -> &'a MarketPrice {
        <MarketPrice as ::protobuf::Message>::default_instance()
    }
}

impl MarketPrice {
    pub fn new() -> MarketPrice {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sell_token_quantity",
            |m: &MarketPrice| { &m.sell_token_quantity },
            |m: &mut MarketPrice| { &mut m.sell_token_quantity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buy_token_quantity",
            |m: &MarketPrice| { &m.buy_token_quantity },
            |m: &mut MarketPrice| { &mut m.buy_token_quantity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MarketPrice>(
            "MarketPrice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MarketPrice {
    const NAME: &'static str = "MarketPrice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sell_token_quantity = is.read_int64()?;
                },
                16 => {
                    self.buy_token_quantity = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.sell_token_quantity != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.sell_token_quantity);
        }
        if self.buy_token_quantity != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.buy_token_quantity);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.sell_token_quantity != 0 {
            os.write_int64(1, self.sell_token_quantity)?;
        }
        if self.buy_token_quantity != 0 {
            os.write_int64(2, self.buy_token_quantity)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MarketPrice {
        MarketPrice::new()
    }

    fn clear(&mut self) {
        self.sell_token_quantity = 0;
        self.buy_token_quantity = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MarketPrice {
        static instance: MarketPrice = MarketPrice {
            sell_token_quantity: 0,
            buy_token_quantity: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MarketPrice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MarketPrice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MarketPrice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MarketPrice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.MarketPriceList)
pub struct MarketPriceList {
    // message fields
    // @@protoc_insertion_point(field:protocol.MarketPriceList.sell_token_id)
    pub sell_token_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.MarketPriceList.buy_token_id)
    pub buy_token_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.MarketPriceList.prices)
    pub prices: ::std::vec::Vec<MarketPrice>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.MarketPriceList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MarketPriceList {
    fn default() -> &'a MarketPriceList {
        <MarketPriceList as ::protobuf::Message>::default_instance()
    }
}

impl MarketPriceList {
    pub fn new() -> MarketPriceList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sell_token_id",
            |m: &MarketPriceList| { &m.sell_token_id },
            |m: &mut MarketPriceList| { &mut m.sell_token_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buy_token_id",
            |m: &MarketPriceList| { &m.buy_token_id },
            |m: &mut MarketPriceList| { &mut m.buy_token_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "prices",
            |m: &MarketPriceList| { &m.prices },
            |m: &mut MarketPriceList| { &mut m.prices },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MarketPriceList>(
            "MarketPriceList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MarketPriceList {
    const NAME: &'static str = "MarketPriceList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sell_token_id = is.read_bytes()?;
                },
                18 => {
                    self.buy_token_id = is.read_bytes()?;
                },
                26 => {
                    self.prices.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.sell_token_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.sell_token_id);
        }
        if !self.buy_token_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.buy_token_id);
        }
        for value in &self.prices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.sell_token_id.is_empty() {
            os.write_bytes(1, &self.sell_token_id)?;
        }
        if !self.buy_token_id.is_empty() {
            os.write_bytes(2, &self.buy_token_id)?;
        }
        for v in &self.prices {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MarketPriceList {
        MarketPriceList::new()
    }

    fn clear(&mut self) {
        self.sell_token_id.clear();
        self.buy_token_id.clear();
        self.prices.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MarketPriceList {
        static instance: MarketPriceList = MarketPriceList {
            sell_token_id: ::std::vec::Vec::new(),
            buy_token_id: ::std::vec::Vec::new(),
            prices: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MarketPriceList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MarketPriceList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MarketPriceList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MarketPriceList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.MarketOrderIdList)
pub struct MarketOrderIdList {
    // message fields
    // @@protoc_insertion_point(field:protocol.MarketOrderIdList.head)
    pub head: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.MarketOrderIdList.tail)
    pub tail: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.MarketOrderIdList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MarketOrderIdList {
    fn default() -> &'a MarketOrderIdList {
        <MarketOrderIdList as ::protobuf::Message>::default_instance()
    }
}

impl MarketOrderIdList {
    pub fn new() -> MarketOrderIdList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "head",
            |m: &MarketOrderIdList| { &m.head },
            |m: &mut MarketOrderIdList| { &mut m.head },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tail",
            |m: &MarketOrderIdList| { &m.tail },
            |m: &mut MarketOrderIdList| { &mut m.tail },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MarketOrderIdList>(
            "MarketOrderIdList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MarketOrderIdList {
    const NAME: &'static str = "MarketOrderIdList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.head = is.read_bytes()?;
                },
                18 => {
                    self.tail = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.head.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.head);
        }
        if !self.tail.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.tail);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.head.is_empty() {
            os.write_bytes(1, &self.head)?;
        }
        if !self.tail.is_empty() {
            os.write_bytes(2, &self.tail)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MarketOrderIdList {
        MarketOrderIdList::new()
    }

    fn clear(&mut self) {
        self.head.clear();
        self.tail.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MarketOrderIdList {
        static instance: MarketOrderIdList = MarketOrderIdList {
            head: ::std::vec::Vec::new(),
            tail: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MarketOrderIdList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MarketOrderIdList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MarketOrderIdList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MarketOrderIdList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.ChainParameters)
pub struct ChainParameters {
    // message fields
    // @@protoc_insertion_point(field:protocol.ChainParameters.chainParameter)
    pub chainParameter: ::std::vec::Vec<chain_parameters::ChainParameter>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.ChainParameters.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChainParameters {
    fn default() -> &'a ChainParameters {
        <ChainParameters as ::protobuf::Message>::default_instance()
    }
}

impl ChainParameters {
    pub fn new() -> ChainParameters {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chainParameter",
            |m: &ChainParameters| { &m.chainParameter },
            |m: &mut ChainParameters| { &mut m.chainParameter },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChainParameters>(
            "ChainParameters",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChainParameters {
    const NAME: &'static str = "ChainParameters";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.chainParameter.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.chainParameter {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.chainParameter {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChainParameters {
        ChainParameters::new()
    }

    fn clear(&mut self) {
        self.chainParameter.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChainParameters {
        static instance: ChainParameters = ChainParameters {
            chainParameter: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChainParameters {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChainParameters").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChainParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChainParameters {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ChainParameters`
pub mod chain_parameters {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:protocol.ChainParameters.ChainParameter)
    pub struct ChainParameter {
        // message fields
        // @@protoc_insertion_point(field:protocol.ChainParameters.ChainParameter.key)
        pub key: ::std::string::String,
        // @@protoc_insertion_point(field:protocol.ChainParameters.ChainParameter.value)
        pub value: i64,
        // special fields
        // @@protoc_insertion_point(special_field:protocol.ChainParameters.ChainParameter.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ChainParameter {
        fn default() -> &'a ChainParameter {
            <ChainParameter as ::protobuf::Message>::default_instance()
        }
    }

    impl ChainParameter {
        pub fn new() -> ChainParameter {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "key",
                |m: &ChainParameter| { &m.key },
                |m: &mut ChainParameter| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "value",
                |m: &ChainParameter| { &m.value },
                |m: &mut ChainParameter| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChainParameter>(
                "ChainParameters.ChainParameter",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ChainParameter {
        const NAME: &'static str = "ChainParameter";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.key = is.read_string()?;
                    },
                    16 => {
                        self.value = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.key.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.key);
            }
            if self.value != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.value);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.key.is_empty() {
                os.write_string(1, &self.key)?;
            }
            if self.value != 0 {
                os.write_int64(2, self.value)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ChainParameter {
            ChainParameter::new()
        }

        fn clear(&mut self) {
            self.key.clear();
            self.value = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ChainParameter {
            static instance: ChainParameter = ChainParameter {
                key: ::std::string::String::new(),
                value: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ChainParameter {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ChainParameters.ChainParameter").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ChainParameter {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ChainParameter {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

///  Account 
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.Account)
pub struct Account {
    // message fields
    ///  account nick name
    // @@protoc_insertion_point(field:protocol.Account.account_name)
    pub account_name: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.Account.type)
    pub type_: ::protobuf::EnumOrUnknown<AccountType>,
    ///  the create address
    // @@protoc_insertion_point(field:protocol.Account.address)
    pub address: ::std::vec::Vec<u8>,
    ///  the trx balance
    // @@protoc_insertion_point(field:protocol.Account.balance)
    pub balance: i64,
    ///  the votes
    // @@protoc_insertion_point(field:protocol.Account.votes)
    pub votes: ::std::vec::Vec<Vote>,
    ///  the other asset owned by this account
    // @@protoc_insertion_point(field:protocol.Account.asset)
    pub asset: ::std::collections::HashMap<::std::string::String, i64>,
    ///  the other asset owned by this account，key is assetId
    // @@protoc_insertion_point(field:protocol.Account.assetV2)
    pub assetV2: ::std::collections::HashMap<::std::string::String, i64>,
    ///  the frozen balance for bandwidth
    // @@protoc_insertion_point(field:protocol.Account.frozen)
    pub frozen: ::std::vec::Vec<account::Frozen>,
    ///  bandwidth, get from frozen
    // @@protoc_insertion_point(field:protocol.Account.net_usage)
    pub net_usage: i64,
    /// Frozen balance provided by other accounts to this account
    // @@protoc_insertion_point(field:protocol.Account.acquired_delegated_frozen_balance_for_bandwidth)
    pub acquired_delegated_frozen_balance_for_bandwidth: i64,
    /// Freeze and provide balances to other accounts
    // @@protoc_insertion_point(field:protocol.Account.delegated_frozen_balance_for_bandwidth)
    pub delegated_frozen_balance_for_bandwidth: i64,
    // @@protoc_insertion_point(field:protocol.Account.old_tron_power)
    pub old_tron_power: i64,
    // @@protoc_insertion_point(field:protocol.Account.tron_power)
    pub tron_power: ::protobuf::MessageField<account::Frozen>,
    // @@protoc_insertion_point(field:protocol.Account.asset_optimized)
    pub asset_optimized: bool,
    ///  this account create time
    // @@protoc_insertion_point(field:protocol.Account.create_time)
    pub create_time: i64,
    ///  this last operation time, including transfer, voting and so on. //FIXME fix grammar
    // @@protoc_insertion_point(field:protocol.Account.latest_opration_time)
    pub latest_opration_time: i64,
    ///  witness block producing allowance
    // @@protoc_insertion_point(field:protocol.Account.allowance)
    pub allowance: i64,
    ///  last withdraw time
    // @@protoc_insertion_point(field:protocol.Account.latest_withdraw_time)
    pub latest_withdraw_time: i64,
    ///  not used so far
    // @@protoc_insertion_point(field:protocol.Account.code)
    pub code: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.Account.is_witness)
    pub is_witness: bool,
    // @@protoc_insertion_point(field:protocol.Account.is_committee)
    pub is_committee: bool,
    ///  frozen asset(for asset issuer)
    // @@protoc_insertion_point(field:protocol.Account.frozen_supply)
    pub frozen_supply: ::std::vec::Vec<account::Frozen>,
    ///  asset_issued_name
    // @@protoc_insertion_point(field:protocol.Account.asset_issued_name)
    pub asset_issued_name: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.Account.asset_issued_ID)
    pub asset_issued_ID: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.Account.latest_asset_operation_time)
    pub latest_asset_operation_time: ::std::collections::HashMap<::std::string::String, i64>,
    // @@protoc_insertion_point(field:protocol.Account.latest_asset_operation_timeV2)
    pub latest_asset_operation_timeV2: ::std::collections::HashMap<::std::string::String, i64>,
    // @@protoc_insertion_point(field:protocol.Account.free_net_usage)
    pub free_net_usage: i64,
    // @@protoc_insertion_point(field:protocol.Account.free_asset_net_usage)
    pub free_asset_net_usage: ::std::collections::HashMap<::std::string::String, i64>,
    // @@protoc_insertion_point(field:protocol.Account.free_asset_net_usageV2)
    pub free_asset_net_usageV2: ::std::collections::HashMap<::std::string::String, i64>,
    // @@protoc_insertion_point(field:protocol.Account.latest_consume_time)
    pub latest_consume_time: i64,
    // @@protoc_insertion_point(field:protocol.Account.latest_consume_free_time)
    pub latest_consume_free_time: i64,
    ///  the identity of this account, case insensitive
    // @@protoc_insertion_point(field:protocol.Account.account_id)
    pub account_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.Account.account_resource)
    pub account_resource: ::protobuf::MessageField<account::AccountResource>,
    // @@protoc_insertion_point(field:protocol.Account.codeHash)
    pub codeHash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.Account.owner_permission)
    pub owner_permission: ::protobuf::MessageField<Permission>,
    // @@protoc_insertion_point(field:protocol.Account.witness_permission)
    pub witness_permission: ::protobuf::MessageField<Permission>,
    // @@protoc_insertion_point(field:protocol.Account.active_permission)
    pub active_permission: ::std::vec::Vec<Permission>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.Account.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Account {
    fn default() -> &'a Account {
        <Account as ::protobuf::Message>::default_instance()
    }
}

impl Account {
    pub fn new() -> Account {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(37);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "account_name",
            |m: &Account| { &m.account_name },
            |m: &mut Account| { &mut m.account_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Account| { &m.type_ },
            |m: &mut Account| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &Account| { &m.address },
            |m: &mut Account| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "balance",
            |m: &Account| { &m.balance },
            |m: &mut Account| { &mut m.balance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "votes",
            |m: &Account| { &m.votes },
            |m: &mut Account| { &mut m.votes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "asset",
            |m: &Account| { &m.asset },
            |m: &mut Account| { &mut m.asset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "assetV2",
            |m: &Account| { &m.assetV2 },
            |m: &mut Account| { &mut m.assetV2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "frozen",
            |m: &Account| { &m.frozen },
            |m: &mut Account| { &mut m.frozen },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "net_usage",
            |m: &Account| { &m.net_usage },
            |m: &mut Account| { &mut m.net_usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "acquired_delegated_frozen_balance_for_bandwidth",
            |m: &Account| { &m.acquired_delegated_frozen_balance_for_bandwidth },
            |m: &mut Account| { &mut m.acquired_delegated_frozen_balance_for_bandwidth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delegated_frozen_balance_for_bandwidth",
            |m: &Account| { &m.delegated_frozen_balance_for_bandwidth },
            |m: &mut Account| { &mut m.delegated_frozen_balance_for_bandwidth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "old_tron_power",
            |m: &Account| { &m.old_tron_power },
            |m: &mut Account| { &mut m.old_tron_power },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, account::Frozen>(
            "tron_power",
            |m: &Account| { &m.tron_power },
            |m: &mut Account| { &mut m.tron_power },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "asset_optimized",
            |m: &Account| { &m.asset_optimized },
            |m: &mut Account| { &mut m.asset_optimized },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "create_time",
            |m: &Account| { &m.create_time },
            |m: &mut Account| { &mut m.create_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "latest_opration_time",
            |m: &Account| { &m.latest_opration_time },
            |m: &mut Account| { &mut m.latest_opration_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allowance",
            |m: &Account| { &m.allowance },
            |m: &mut Account| { &mut m.allowance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "latest_withdraw_time",
            |m: &Account| { &m.latest_withdraw_time },
            |m: &mut Account| { &mut m.latest_withdraw_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &Account| { &m.code },
            |m: &mut Account| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_witness",
            |m: &Account| { &m.is_witness },
            |m: &mut Account| { &mut m.is_witness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_committee",
            |m: &Account| { &m.is_committee },
            |m: &mut Account| { &mut m.is_committee },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "frozen_supply",
            |m: &Account| { &m.frozen_supply },
            |m: &mut Account| { &mut m.frozen_supply },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "asset_issued_name",
            |m: &Account| { &m.asset_issued_name },
            |m: &mut Account| { &mut m.asset_issued_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "asset_issued_ID",
            |m: &Account| { &m.asset_issued_ID },
            |m: &mut Account| { &mut m.asset_issued_ID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "latest_asset_operation_time",
            |m: &Account| { &m.latest_asset_operation_time },
            |m: &mut Account| { &mut m.latest_asset_operation_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "latest_asset_operation_timeV2",
            |m: &Account| { &m.latest_asset_operation_timeV2 },
            |m: &mut Account| { &mut m.latest_asset_operation_timeV2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "free_net_usage",
            |m: &Account| { &m.free_net_usage },
            |m: &mut Account| { &mut m.free_net_usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "free_asset_net_usage",
            |m: &Account| { &m.free_asset_net_usage },
            |m: &mut Account| { &mut m.free_asset_net_usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "free_asset_net_usageV2",
            |m: &Account| { &m.free_asset_net_usageV2 },
            |m: &mut Account| { &mut m.free_asset_net_usageV2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "latest_consume_time",
            |m: &Account| { &m.latest_consume_time },
            |m: &mut Account| { &mut m.latest_consume_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "latest_consume_free_time",
            |m: &Account| { &m.latest_consume_free_time },
            |m: &mut Account| { &mut m.latest_consume_free_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "account_id",
            |m: &Account| { &m.account_id },
            |m: &mut Account| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, account::AccountResource>(
            "account_resource",
            |m: &Account| { &m.account_resource },
            |m: &mut Account| { &mut m.account_resource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "codeHash",
            |m: &Account| { &m.codeHash },
            |m: &mut Account| { &mut m.codeHash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Permission>(
            "owner_permission",
            |m: &Account| { &m.owner_permission },
            |m: &mut Account| { &mut m.owner_permission },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Permission>(
            "witness_permission",
            |m: &Account| { &m.witness_permission },
            |m: &mut Account| { &mut m.witness_permission },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "active_permission",
            |m: &Account| { &m.active_permission },
            |m: &mut Account| { &mut m.active_permission },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Account>(
            "Account",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Account {
    const NAME: &'static str = "Account";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.account_name = is.read_bytes()?;
                },
                16 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.address = is.read_bytes()?;
                },
                32 => {
                    self.balance = is.read_int64()?;
                },
                42 => {
                    self.votes.push(is.read_message()?);
                },
                50 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            16 => value = is.read_int64()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.asset.insert(key, value);
                },
                450 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            16 => value = is.read_int64()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.assetV2.insert(key, value);
                },
                58 => {
                    self.frozen.push(is.read_message()?);
                },
                64 => {
                    self.net_usage = is.read_int64()?;
                },
                328 => {
                    self.acquired_delegated_frozen_balance_for_bandwidth = is.read_int64()?;
                },
                336 => {
                    self.delegated_frozen_balance_for_bandwidth = is.read_int64()?;
                },
                368 => {
                    self.old_tron_power = is.read_int64()?;
                },
                378 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tron_power)?;
                },
                480 => {
                    self.asset_optimized = is.read_bool()?;
                },
                72 => {
                    self.create_time = is.read_int64()?;
                },
                80 => {
                    self.latest_opration_time = is.read_int64()?;
                },
                88 => {
                    self.allowance = is.read_int64()?;
                },
                96 => {
                    self.latest_withdraw_time = is.read_int64()?;
                },
                106 => {
                    self.code = is.read_bytes()?;
                },
                112 => {
                    self.is_witness = is.read_bool()?;
                },
                120 => {
                    self.is_committee = is.read_bool()?;
                },
                130 => {
                    self.frozen_supply.push(is.read_message()?);
                },
                138 => {
                    self.asset_issued_name = is.read_bytes()?;
                },
                458 => {
                    self.asset_issued_ID = is.read_bytes()?;
                },
                146 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            16 => value = is.read_int64()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.latest_asset_operation_time.insert(key, value);
                },
                466 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            16 => value = is.read_int64()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.latest_asset_operation_timeV2.insert(key, value);
                },
                152 => {
                    self.free_net_usage = is.read_int64()?;
                },
                162 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            16 => value = is.read_int64()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.free_asset_net_usage.insert(key, value);
                },
                474 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            16 => value = is.read_int64()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.free_asset_net_usageV2.insert(key, value);
                },
                168 => {
                    self.latest_consume_time = is.read_int64()?;
                },
                176 => {
                    self.latest_consume_free_time = is.read_int64()?;
                },
                186 => {
                    self.account_id = is.read_bytes()?;
                },
                210 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.account_resource)?;
                },
                242 => {
                    self.codeHash = is.read_bytes()?;
                },
                250 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_permission)?;
                },
                258 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.witness_permission)?;
                },
                266 => {
                    self.active_permission.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.account_name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.account_name);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(AccountType::Normal) {
            my_size += ::protobuf::rt::int32_size(2, self.type_.value());
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.address);
        }
        if self.balance != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.balance);
        }
        for value in &self.votes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for (k, v) in &self.asset {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::int64_size(2, *v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.assetV2 {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::int64_size(2, *v);
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for value in &self.frozen {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.net_usage != 0 {
            my_size += ::protobuf::rt::int64_size(8, self.net_usage);
        }
        if self.acquired_delegated_frozen_balance_for_bandwidth != 0 {
            my_size += ::protobuf::rt::int64_size(41, self.acquired_delegated_frozen_balance_for_bandwidth);
        }
        if self.delegated_frozen_balance_for_bandwidth != 0 {
            my_size += ::protobuf::rt::int64_size(42, self.delegated_frozen_balance_for_bandwidth);
        }
        if self.old_tron_power != 0 {
            my_size += ::protobuf::rt::int64_size(46, self.old_tron_power);
        }
        if let Some(v) = self.tron_power.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.asset_optimized != false {
            my_size += 2 + 1;
        }
        if self.create_time != 0 {
            my_size += ::protobuf::rt::int64_size(9, self.create_time);
        }
        if self.latest_opration_time != 0 {
            my_size += ::protobuf::rt::int64_size(10, self.latest_opration_time);
        }
        if self.allowance != 0 {
            my_size += ::protobuf::rt::int64_size(11, self.allowance);
        }
        if self.latest_withdraw_time != 0 {
            my_size += ::protobuf::rt::int64_size(12, self.latest_withdraw_time);
        }
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::bytes_size(13, &self.code);
        }
        if self.is_witness != false {
            my_size += 1 + 1;
        }
        if self.is_committee != false {
            my_size += 1 + 1;
        }
        for value in &self.frozen_supply {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.asset_issued_name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(17, &self.asset_issued_name);
        }
        if !self.asset_issued_ID.is_empty() {
            my_size += ::protobuf::rt::bytes_size(57, &self.asset_issued_ID);
        }
        for (k, v) in &self.latest_asset_operation_time {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::int64_size(2, *v);
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.latest_asset_operation_timeV2 {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::int64_size(2, *v);
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if self.free_net_usage != 0 {
            my_size += ::protobuf::rt::int64_size(19, self.free_net_usage);
        }
        for (k, v) in &self.free_asset_net_usage {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::int64_size(2, *v);
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.free_asset_net_usageV2 {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::int64_size(2, *v);
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if self.latest_consume_time != 0 {
            my_size += ::protobuf::rt::int64_size(21, self.latest_consume_time);
        }
        if self.latest_consume_free_time != 0 {
            my_size += ::protobuf::rt::int64_size(22, self.latest_consume_free_time);
        }
        if !self.account_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(23, &self.account_id);
        }
        if let Some(v) = self.account_resource.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.codeHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(30, &self.codeHash);
        }
        if let Some(v) = self.owner_permission.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.witness_permission.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.active_permission {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.account_name.is_empty() {
            os.write_bytes(1, &self.account_name)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(AccountType::Normal) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if !self.address.is_empty() {
            os.write_bytes(3, &self.address)?;
        }
        if self.balance != 0 {
            os.write_int64(4, self.balance)?;
        }
        for v in &self.votes {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for (k, v) in &self.asset {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::int64_size(2, *v);
            os.write_raw_varint32(50)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_int64(2, *v)?;
        };
        for (k, v) in &self.assetV2 {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::int64_size(2, *v);
            os.write_raw_varint32(450)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_int64(2, *v)?;
        };
        for v in &self.frozen {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if self.net_usage != 0 {
            os.write_int64(8, self.net_usage)?;
        }
        if self.acquired_delegated_frozen_balance_for_bandwidth != 0 {
            os.write_int64(41, self.acquired_delegated_frozen_balance_for_bandwidth)?;
        }
        if self.delegated_frozen_balance_for_bandwidth != 0 {
            os.write_int64(42, self.delegated_frozen_balance_for_bandwidth)?;
        }
        if self.old_tron_power != 0 {
            os.write_int64(46, self.old_tron_power)?;
        }
        if let Some(v) = self.tron_power.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(47, v, os)?;
        }
        if self.asset_optimized != false {
            os.write_bool(60, self.asset_optimized)?;
        }
        if self.create_time != 0 {
            os.write_int64(9, self.create_time)?;
        }
        if self.latest_opration_time != 0 {
            os.write_int64(10, self.latest_opration_time)?;
        }
        if self.allowance != 0 {
            os.write_int64(11, self.allowance)?;
        }
        if self.latest_withdraw_time != 0 {
            os.write_int64(12, self.latest_withdraw_time)?;
        }
        if !self.code.is_empty() {
            os.write_bytes(13, &self.code)?;
        }
        if self.is_witness != false {
            os.write_bool(14, self.is_witness)?;
        }
        if self.is_committee != false {
            os.write_bool(15, self.is_committee)?;
        }
        for v in &self.frozen_supply {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        };
        if !self.asset_issued_name.is_empty() {
            os.write_bytes(17, &self.asset_issued_name)?;
        }
        if !self.asset_issued_ID.is_empty() {
            os.write_bytes(57, &self.asset_issued_ID)?;
        }
        for (k, v) in &self.latest_asset_operation_time {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::int64_size(2, *v);
            os.write_raw_varint32(146)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_int64(2, *v)?;
        };
        for (k, v) in &self.latest_asset_operation_timeV2 {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::int64_size(2, *v);
            os.write_raw_varint32(466)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_int64(2, *v)?;
        };
        if self.free_net_usage != 0 {
            os.write_int64(19, self.free_net_usage)?;
        }
        for (k, v) in &self.free_asset_net_usage {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::int64_size(2, *v);
            os.write_raw_varint32(162)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_int64(2, *v)?;
        };
        for (k, v) in &self.free_asset_net_usageV2 {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::int64_size(2, *v);
            os.write_raw_varint32(474)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_int64(2, *v)?;
        };
        if self.latest_consume_time != 0 {
            os.write_int64(21, self.latest_consume_time)?;
        }
        if self.latest_consume_free_time != 0 {
            os.write_int64(22, self.latest_consume_free_time)?;
        }
        if !self.account_id.is_empty() {
            os.write_bytes(23, &self.account_id)?;
        }
        if let Some(v) = self.account_resource.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if !self.codeHash.is_empty() {
            os.write_bytes(30, &self.codeHash)?;
        }
        if let Some(v) = self.owner_permission.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        if let Some(v) = self.witness_permission.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
        }
        for v in &self.active_permission {
            ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Account {
        Account::new()
    }

    fn clear(&mut self) {
        self.account_name.clear();
        self.type_ = ::protobuf::EnumOrUnknown::new(AccountType::Normal);
        self.address.clear();
        self.balance = 0;
        self.votes.clear();
        self.asset.clear();
        self.assetV2.clear();
        self.frozen.clear();
        self.net_usage = 0;
        self.acquired_delegated_frozen_balance_for_bandwidth = 0;
        self.delegated_frozen_balance_for_bandwidth = 0;
        self.old_tron_power = 0;
        self.tron_power.clear();
        self.asset_optimized = false;
        self.create_time = 0;
        self.latest_opration_time = 0;
        self.allowance = 0;
        self.latest_withdraw_time = 0;
        self.code.clear();
        self.is_witness = false;
        self.is_committee = false;
        self.frozen_supply.clear();
        self.asset_issued_name.clear();
        self.asset_issued_ID.clear();
        self.latest_asset_operation_time.clear();
        self.latest_asset_operation_timeV2.clear();
        self.free_net_usage = 0;
        self.free_asset_net_usage.clear();
        self.free_asset_net_usageV2.clear();
        self.latest_consume_time = 0;
        self.latest_consume_free_time = 0;
        self.account_id.clear();
        self.account_resource.clear();
        self.codeHash.clear();
        self.owner_permission.clear();
        self.witness_permission.clear();
        self.active_permission.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Account {
        static instance: ::protobuf::rt::Lazy<Account> = ::protobuf::rt::Lazy::new();
        instance.get(Account::new)
    }
}

impl ::protobuf::MessageFull for Account {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Account").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Account {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Account {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Account`
pub mod account {
    ///  frozen balance 
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:protocol.Account.Frozen)
    pub struct Frozen {
        // message fields
        // @@protoc_insertion_point(field:protocol.Account.Frozen.frozen_balance)
        pub frozen_balance: i64,
        // @@protoc_insertion_point(field:protocol.Account.Frozen.expire_time)
        pub expire_time: i64,
        // special fields
        // @@protoc_insertion_point(special_field:protocol.Account.Frozen.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Frozen {
        fn default() -> &'a Frozen {
            <Frozen as ::protobuf::Message>::default_instance()
        }
    }

    impl Frozen {
        pub fn new() -> Frozen {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "frozen_balance",
                |m: &Frozen| { &m.frozen_balance },
                |m: &mut Frozen| { &mut m.frozen_balance },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "expire_time",
                |m: &Frozen| { &m.expire_time },
                |m: &mut Frozen| { &mut m.expire_time },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Frozen>(
                "Account.Frozen",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Frozen {
        const NAME: &'static str = "Frozen";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.frozen_balance = is.read_int64()?;
                    },
                    16 => {
                        self.expire_time = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.frozen_balance != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.frozen_balance);
            }
            if self.expire_time != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.expire_time);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.frozen_balance != 0 {
                os.write_int64(1, self.frozen_balance)?;
            }
            if self.expire_time != 0 {
                os.write_int64(2, self.expire_time)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Frozen {
            Frozen::new()
        }

        fn clear(&mut self) {
            self.frozen_balance = 0;
            self.expire_time = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Frozen {
            static instance: Frozen = Frozen {
                frozen_balance: 0,
                expire_time: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Frozen {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Account.Frozen").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Frozen {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Frozen {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:protocol.Account.AccountResource)
    pub struct AccountResource {
        // message fields
        // @@protoc_insertion_point(field:protocol.Account.AccountResource.energy_usage)
        pub energy_usage: i64,
        // @@protoc_insertion_point(field:protocol.Account.AccountResource.frozen_balance_for_energy)
        pub frozen_balance_for_energy: ::protobuf::MessageField<Frozen>,
        // @@protoc_insertion_point(field:protocol.Account.AccountResource.latest_consume_time_for_energy)
        pub latest_consume_time_for_energy: i64,
        // @@protoc_insertion_point(field:protocol.Account.AccountResource.acquired_delegated_frozen_balance_for_energy)
        pub acquired_delegated_frozen_balance_for_energy: i64,
        // @@protoc_insertion_point(field:protocol.Account.AccountResource.delegated_frozen_balance_for_energy)
        pub delegated_frozen_balance_for_energy: i64,
        // @@protoc_insertion_point(field:protocol.Account.AccountResource.storage_limit)
        pub storage_limit: i64,
        // @@protoc_insertion_point(field:protocol.Account.AccountResource.storage_usage)
        pub storage_usage: i64,
        // @@protoc_insertion_point(field:protocol.Account.AccountResource.latest_exchange_storage_time)
        pub latest_exchange_storage_time: i64,
        // special fields
        // @@protoc_insertion_point(special_field:protocol.Account.AccountResource.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AccountResource {
        fn default() -> &'a AccountResource {
            <AccountResource as ::protobuf::Message>::default_instance()
        }
    }

    impl AccountResource {
        pub fn new() -> AccountResource {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "energy_usage",
                |m: &AccountResource| { &m.energy_usage },
                |m: &mut AccountResource| { &mut m.energy_usage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Frozen>(
                "frozen_balance_for_energy",
                |m: &AccountResource| { &m.frozen_balance_for_energy },
                |m: &mut AccountResource| { &mut m.frozen_balance_for_energy },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "latest_consume_time_for_energy",
                |m: &AccountResource| { &m.latest_consume_time_for_energy },
                |m: &mut AccountResource| { &mut m.latest_consume_time_for_energy },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "acquired_delegated_frozen_balance_for_energy",
                |m: &AccountResource| { &m.acquired_delegated_frozen_balance_for_energy },
                |m: &mut AccountResource| { &mut m.acquired_delegated_frozen_balance_for_energy },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "delegated_frozen_balance_for_energy",
                |m: &AccountResource| { &m.delegated_frozen_balance_for_energy },
                |m: &mut AccountResource| { &mut m.delegated_frozen_balance_for_energy },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "storage_limit",
                |m: &AccountResource| { &m.storage_limit },
                |m: &mut AccountResource| { &mut m.storage_limit },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "storage_usage",
                |m: &AccountResource| { &m.storage_usage },
                |m: &mut AccountResource| { &mut m.storage_usage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "latest_exchange_storage_time",
                |m: &AccountResource| { &m.latest_exchange_storage_time },
                |m: &mut AccountResource| { &mut m.latest_exchange_storage_time },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AccountResource>(
                "Account.AccountResource",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AccountResource {
        const NAME: &'static str = "AccountResource";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.energy_usage = is.read_int64()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.frozen_balance_for_energy)?;
                    },
                    24 => {
                        self.latest_consume_time_for_energy = is.read_int64()?;
                    },
                    32 => {
                        self.acquired_delegated_frozen_balance_for_energy = is.read_int64()?;
                    },
                    40 => {
                        self.delegated_frozen_balance_for_energy = is.read_int64()?;
                    },
                    48 => {
                        self.storage_limit = is.read_int64()?;
                    },
                    56 => {
                        self.storage_usage = is.read_int64()?;
                    },
                    64 => {
                        self.latest_exchange_storage_time = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.energy_usage != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.energy_usage);
            }
            if let Some(v) = self.frozen_balance_for_energy.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.latest_consume_time_for_energy != 0 {
                my_size += ::protobuf::rt::int64_size(3, self.latest_consume_time_for_energy);
            }
            if self.acquired_delegated_frozen_balance_for_energy != 0 {
                my_size += ::protobuf::rt::int64_size(4, self.acquired_delegated_frozen_balance_for_energy);
            }
            if self.delegated_frozen_balance_for_energy != 0 {
                my_size += ::protobuf::rt::int64_size(5, self.delegated_frozen_balance_for_energy);
            }
            if self.storage_limit != 0 {
                my_size += ::protobuf::rt::int64_size(6, self.storage_limit);
            }
            if self.storage_usage != 0 {
                my_size += ::protobuf::rt::int64_size(7, self.storage_usage);
            }
            if self.latest_exchange_storage_time != 0 {
                my_size += ::protobuf::rt::int64_size(8, self.latest_exchange_storage_time);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.energy_usage != 0 {
                os.write_int64(1, self.energy_usage)?;
            }
            if let Some(v) = self.frozen_balance_for_energy.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if self.latest_consume_time_for_energy != 0 {
                os.write_int64(3, self.latest_consume_time_for_energy)?;
            }
            if self.acquired_delegated_frozen_balance_for_energy != 0 {
                os.write_int64(4, self.acquired_delegated_frozen_balance_for_energy)?;
            }
            if self.delegated_frozen_balance_for_energy != 0 {
                os.write_int64(5, self.delegated_frozen_balance_for_energy)?;
            }
            if self.storage_limit != 0 {
                os.write_int64(6, self.storage_limit)?;
            }
            if self.storage_usage != 0 {
                os.write_int64(7, self.storage_usage)?;
            }
            if self.latest_exchange_storage_time != 0 {
                os.write_int64(8, self.latest_exchange_storage_time)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AccountResource {
            AccountResource::new()
        }

        fn clear(&mut self) {
            self.energy_usage = 0;
            self.frozen_balance_for_energy.clear();
            self.latest_consume_time_for_energy = 0;
            self.acquired_delegated_frozen_balance_for_energy = 0;
            self.delegated_frozen_balance_for_energy = 0;
            self.storage_limit = 0;
            self.storage_usage = 0;
            self.latest_exchange_storage_time = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AccountResource {
            static instance: AccountResource = AccountResource {
                energy_usage: 0,
                frozen_balance_for_energy: ::protobuf::MessageField::none(),
                latest_consume_time_for_energy: 0,
                acquired_delegated_frozen_balance_for_energy: 0,
                delegated_frozen_balance_for_energy: 0,
                storage_limit: 0,
                storage_usage: 0,
                latest_exchange_storage_time: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AccountResource {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Account.AccountResource").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AccountResource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AccountResource {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.Key)
pub struct Key {
    // message fields
    // @@protoc_insertion_point(field:protocol.Key.address)
    pub address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.Key.weight)
    pub weight: i64,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.Key.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Key {
    fn default() -> &'a Key {
        <Key as ::protobuf::Message>::default_instance()
    }
}

impl Key {
    pub fn new() -> Key {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &Key| { &m.address },
            |m: &mut Key| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "weight",
            |m: &Key| { &m.weight },
            |m: &mut Key| { &mut m.weight },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Key>(
            "Key",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Key {
    const NAME: &'static str = "Key";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                16 => {
                    self.weight = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if self.weight != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.weight);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if self.weight != 0 {
            os.write_int64(2, self.weight)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Key {
        Key::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.weight = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Key {
        static instance: Key = Key {
            address: ::std::vec::Vec::new(),
            weight: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Key {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Key").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Key {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Key {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.DelegatedResource)
pub struct DelegatedResource {
    // message fields
    // @@protoc_insertion_point(field:protocol.DelegatedResource.from)
    pub from: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.DelegatedResource.to)
    pub to: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.DelegatedResource.frozen_balance_for_bandwidth)
    pub frozen_balance_for_bandwidth: i64,
    // @@protoc_insertion_point(field:protocol.DelegatedResource.frozen_balance_for_energy)
    pub frozen_balance_for_energy: i64,
    // @@protoc_insertion_point(field:protocol.DelegatedResource.expire_time_for_bandwidth)
    pub expire_time_for_bandwidth: i64,
    // @@protoc_insertion_point(field:protocol.DelegatedResource.expire_time_for_energy)
    pub expire_time_for_energy: i64,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.DelegatedResource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DelegatedResource {
    fn default() -> &'a DelegatedResource {
        <DelegatedResource as ::protobuf::Message>::default_instance()
    }
}

impl DelegatedResource {
    pub fn new() -> DelegatedResource {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "from",
            |m: &DelegatedResource| { &m.from },
            |m: &mut DelegatedResource| { &mut m.from },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "to",
            |m: &DelegatedResource| { &m.to },
            |m: &mut DelegatedResource| { &mut m.to },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "frozen_balance_for_bandwidth",
            |m: &DelegatedResource| { &m.frozen_balance_for_bandwidth },
            |m: &mut DelegatedResource| { &mut m.frozen_balance_for_bandwidth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "frozen_balance_for_energy",
            |m: &DelegatedResource| { &m.frozen_balance_for_energy },
            |m: &mut DelegatedResource| { &mut m.frozen_balance_for_energy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "expire_time_for_bandwidth",
            |m: &DelegatedResource| { &m.expire_time_for_bandwidth },
            |m: &mut DelegatedResource| { &mut m.expire_time_for_bandwidth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "expire_time_for_energy",
            |m: &DelegatedResource| { &m.expire_time_for_energy },
            |m: &mut DelegatedResource| { &mut m.expire_time_for_energy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DelegatedResource>(
            "DelegatedResource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DelegatedResource {
    const NAME: &'static str = "DelegatedResource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.from = is.read_bytes()?;
                },
                18 => {
                    self.to = is.read_bytes()?;
                },
                24 => {
                    self.frozen_balance_for_bandwidth = is.read_int64()?;
                },
                32 => {
                    self.frozen_balance_for_energy = is.read_int64()?;
                },
                40 => {
                    self.expire_time_for_bandwidth = is.read_int64()?;
                },
                48 => {
                    self.expire_time_for_energy = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.from.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.from);
        }
        if !self.to.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.to);
        }
        if self.frozen_balance_for_bandwidth != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.frozen_balance_for_bandwidth);
        }
        if self.frozen_balance_for_energy != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.frozen_balance_for_energy);
        }
        if self.expire_time_for_bandwidth != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.expire_time_for_bandwidth);
        }
        if self.expire_time_for_energy != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.expire_time_for_energy);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.from.is_empty() {
            os.write_bytes(1, &self.from)?;
        }
        if !self.to.is_empty() {
            os.write_bytes(2, &self.to)?;
        }
        if self.frozen_balance_for_bandwidth != 0 {
            os.write_int64(3, self.frozen_balance_for_bandwidth)?;
        }
        if self.frozen_balance_for_energy != 0 {
            os.write_int64(4, self.frozen_balance_for_energy)?;
        }
        if self.expire_time_for_bandwidth != 0 {
            os.write_int64(5, self.expire_time_for_bandwidth)?;
        }
        if self.expire_time_for_energy != 0 {
            os.write_int64(6, self.expire_time_for_energy)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DelegatedResource {
        DelegatedResource::new()
    }

    fn clear(&mut self) {
        self.from.clear();
        self.to.clear();
        self.frozen_balance_for_bandwidth = 0;
        self.frozen_balance_for_energy = 0;
        self.expire_time_for_bandwidth = 0;
        self.expire_time_for_energy = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DelegatedResource {
        static instance: DelegatedResource = DelegatedResource {
            from: ::std::vec::Vec::new(),
            to: ::std::vec::Vec::new(),
            frozen_balance_for_bandwidth: 0,
            frozen_balance_for_energy: 0,
            expire_time_for_bandwidth: 0,
            expire_time_for_energy: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DelegatedResource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DelegatedResource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DelegatedResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DelegatedResource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.authority)
pub struct Authority {
    // message fields
    // @@protoc_insertion_point(field:protocol.authority.account)
    pub account: ::protobuf::MessageField<AccountId>,
    // @@protoc_insertion_point(field:protocol.authority.permission_name)
    pub permission_name: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.authority.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Authority {
    fn default() -> &'a Authority {
        <Authority as ::protobuf::Message>::default_instance()
    }
}

impl Authority {
    pub fn new() -> Authority {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AccountId>(
            "account",
            |m: &Authority| { &m.account },
            |m: &mut Authority| { &mut m.account },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "permission_name",
            |m: &Authority| { &m.permission_name },
            |m: &mut Authority| { &mut m.permission_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Authority>(
            "authority",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Authority {
    const NAME: &'static str = "authority";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.account)?;
                },
                18 => {
                    self.permission_name = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.permission_name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.permission_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.permission_name.is_empty() {
            os.write_bytes(2, &self.permission_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Authority {
        Authority::new()
    }

    fn clear(&mut self) {
        self.account.clear();
        self.permission_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Authority {
        static instance: Authority = Authority {
            account: ::protobuf::MessageField::none(),
            permission_name: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Authority {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("authority").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Authority {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Authority {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.Permission)
pub struct Permission {
    // message fields
    // @@protoc_insertion_point(field:protocol.Permission.type)
    pub type_: ::protobuf::EnumOrUnknown<permission::PermissionType>,
    // @@protoc_insertion_point(field:protocol.Permission.id)
    pub id: i32,
    // @@protoc_insertion_point(field:protocol.Permission.permission_name)
    pub permission_name: ::std::string::String,
    // @@protoc_insertion_point(field:protocol.Permission.threshold)
    pub threshold: i64,
    // @@protoc_insertion_point(field:protocol.Permission.parent_id)
    pub parent_id: i32,
    // @@protoc_insertion_point(field:protocol.Permission.operations)
    pub operations: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.Permission.keys)
    pub keys: ::std::vec::Vec<Key>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.Permission.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Permission {
    fn default() -> &'a Permission {
        <Permission as ::protobuf::Message>::default_instance()
    }
}

impl Permission {
    pub fn new() -> Permission {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Permission| { &m.type_ },
            |m: &mut Permission| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Permission| { &m.id },
            |m: &mut Permission| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "permission_name",
            |m: &Permission| { &m.permission_name },
            |m: &mut Permission| { &mut m.permission_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "threshold",
            |m: &Permission| { &m.threshold },
            |m: &mut Permission| { &mut m.threshold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "parent_id",
            |m: &Permission| { &m.parent_id },
            |m: &mut Permission| { &mut m.parent_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "operations",
            |m: &Permission| { &m.operations },
            |m: &mut Permission| { &mut m.operations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &Permission| { &m.keys },
            |m: &mut Permission| { &mut m.keys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Permission>(
            "Permission",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Permission {
    const NAME: &'static str = "Permission";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.id = is.read_int32()?;
                },
                26 => {
                    self.permission_name = is.read_string()?;
                },
                32 => {
                    self.threshold = is.read_int64()?;
                },
                40 => {
                    self.parent_id = is.read_int32()?;
                },
                50 => {
                    self.operations = is.read_bytes()?;
                },
                58 => {
                    self.keys.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(permission::PermissionType::Owner) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.id);
        }
        if !self.permission_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.permission_name);
        }
        if self.threshold != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.threshold);
        }
        if self.parent_id != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.parent_id);
        }
        if !self.operations.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.operations);
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(permission::PermissionType::Owner) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if self.id != 0 {
            os.write_int32(2, self.id)?;
        }
        if !self.permission_name.is_empty() {
            os.write_string(3, &self.permission_name)?;
        }
        if self.threshold != 0 {
            os.write_int64(4, self.threshold)?;
        }
        if self.parent_id != 0 {
            os.write_int32(5, self.parent_id)?;
        }
        if !self.operations.is_empty() {
            os.write_bytes(6, &self.operations)?;
        }
        for v in &self.keys {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Permission {
        Permission::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(permission::PermissionType::Owner);
        self.id = 0;
        self.permission_name.clear();
        self.threshold = 0;
        self.parent_id = 0;
        self.operations.clear();
        self.keys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Permission {
        static instance: Permission = Permission {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            id: 0,
            permission_name: ::std::string::String::new(),
            threshold: 0,
            parent_id: 0,
            operations: ::std::vec::Vec::new(),
            keys: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Permission {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Permission").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Permission {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Permission {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Permission`
pub mod permission {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:protocol.Permission.PermissionType)
    pub enum PermissionType {
        // @@protoc_insertion_point(enum_value:protocol.Permission.PermissionType.Owner)
        Owner = 0,
        // @@protoc_insertion_point(enum_value:protocol.Permission.PermissionType.Witness)
        Witness = 1,
        // @@protoc_insertion_point(enum_value:protocol.Permission.PermissionType.Active)
        Active = 2,
    }

    impl ::protobuf::Enum for PermissionType {
        const NAME: &'static str = "PermissionType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<PermissionType> {
            match value {
                0 => ::std::option::Option::Some(PermissionType::Owner),
                1 => ::std::option::Option::Some(PermissionType::Witness),
                2 => ::std::option::Option::Some(PermissionType::Active),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [PermissionType] = &[
            PermissionType::Owner,
            PermissionType::Witness,
            PermissionType::Active,
        ];
    }

    impl ::protobuf::EnumFull for PermissionType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Permission.PermissionType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for PermissionType {
        fn default() -> Self {
            PermissionType::Owner
        }
    }

    impl PermissionType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PermissionType>("Permission.PermissionType")
        }
    }
}

///  Witness
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.Witness)
pub struct Witness {
    // message fields
    // @@protoc_insertion_point(field:protocol.Witness.address)
    pub address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.Witness.voteCount)
    pub voteCount: i64,
    // @@protoc_insertion_point(field:protocol.Witness.pubKey)
    pub pubKey: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.Witness.url)
    pub url: ::std::string::String,
    // @@protoc_insertion_point(field:protocol.Witness.totalProduced)
    pub totalProduced: i64,
    // @@protoc_insertion_point(field:protocol.Witness.totalMissed)
    pub totalMissed: i64,
    // @@protoc_insertion_point(field:protocol.Witness.latestBlockNum)
    pub latestBlockNum: i64,
    // @@protoc_insertion_point(field:protocol.Witness.latestSlotNum)
    pub latestSlotNum: i64,
    // @@protoc_insertion_point(field:protocol.Witness.isJobs)
    pub isJobs: bool,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.Witness.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Witness {
    fn default() -> &'a Witness {
        <Witness as ::protobuf::Message>::default_instance()
    }
}

impl Witness {
    pub fn new() -> Witness {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &Witness| { &m.address },
            |m: &mut Witness| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "voteCount",
            |m: &Witness| { &m.voteCount },
            |m: &mut Witness| { &mut m.voteCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pubKey",
            |m: &Witness| { &m.pubKey },
            |m: &mut Witness| { &mut m.pubKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &Witness| { &m.url },
            |m: &mut Witness| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "totalProduced",
            |m: &Witness| { &m.totalProduced },
            |m: &mut Witness| { &mut m.totalProduced },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "totalMissed",
            |m: &Witness| { &m.totalMissed },
            |m: &mut Witness| { &mut m.totalMissed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "latestBlockNum",
            |m: &Witness| { &m.latestBlockNum },
            |m: &mut Witness| { &mut m.latestBlockNum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "latestSlotNum",
            |m: &Witness| { &m.latestSlotNum },
            |m: &mut Witness| { &mut m.latestSlotNum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isJobs",
            |m: &Witness| { &m.isJobs },
            |m: &mut Witness| { &mut m.isJobs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Witness>(
            "Witness",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Witness {
    const NAME: &'static str = "Witness";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                16 => {
                    self.voteCount = is.read_int64()?;
                },
                26 => {
                    self.pubKey = is.read_bytes()?;
                },
                34 => {
                    self.url = is.read_string()?;
                },
                40 => {
                    self.totalProduced = is.read_int64()?;
                },
                48 => {
                    self.totalMissed = is.read_int64()?;
                },
                56 => {
                    self.latestBlockNum = is.read_int64()?;
                },
                64 => {
                    self.latestSlotNum = is.read_int64()?;
                },
                72 => {
                    self.isJobs = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if self.voteCount != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.voteCount);
        }
        if !self.pubKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.pubKey);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.url);
        }
        if self.totalProduced != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.totalProduced);
        }
        if self.totalMissed != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.totalMissed);
        }
        if self.latestBlockNum != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.latestBlockNum);
        }
        if self.latestSlotNum != 0 {
            my_size += ::protobuf::rt::int64_size(8, self.latestSlotNum);
        }
        if self.isJobs != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if self.voteCount != 0 {
            os.write_int64(2, self.voteCount)?;
        }
        if !self.pubKey.is_empty() {
            os.write_bytes(3, &self.pubKey)?;
        }
        if !self.url.is_empty() {
            os.write_string(4, &self.url)?;
        }
        if self.totalProduced != 0 {
            os.write_int64(5, self.totalProduced)?;
        }
        if self.totalMissed != 0 {
            os.write_int64(6, self.totalMissed)?;
        }
        if self.latestBlockNum != 0 {
            os.write_int64(7, self.latestBlockNum)?;
        }
        if self.latestSlotNum != 0 {
            os.write_int64(8, self.latestSlotNum)?;
        }
        if self.isJobs != false {
            os.write_bool(9, self.isJobs)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Witness {
        Witness::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.voteCount = 0;
        self.pubKey.clear();
        self.url.clear();
        self.totalProduced = 0;
        self.totalMissed = 0;
        self.latestBlockNum = 0;
        self.latestSlotNum = 0;
        self.isJobs = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Witness {
        static instance: Witness = Witness {
            address: ::std::vec::Vec::new(),
            voteCount: 0,
            pubKey: ::std::vec::Vec::new(),
            url: ::std::string::String::new(),
            totalProduced: 0,
            totalMissed: 0,
            latestBlockNum: 0,
            latestSlotNum: 0,
            isJobs: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Witness {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Witness").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Witness {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Witness {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Vote Change
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.Votes)
pub struct Votes {
    // message fields
    // @@protoc_insertion_point(field:protocol.Votes.address)
    pub address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.Votes.old_votes)
    pub old_votes: ::std::vec::Vec<Vote>,
    // @@protoc_insertion_point(field:protocol.Votes.new_votes)
    pub new_votes: ::std::vec::Vec<Vote>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.Votes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Votes {
    fn default() -> &'a Votes {
        <Votes as ::protobuf::Message>::default_instance()
    }
}

impl Votes {
    pub fn new() -> Votes {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &Votes| { &m.address },
            |m: &mut Votes| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "old_votes",
            |m: &Votes| { &m.old_votes },
            |m: &mut Votes| { &mut m.old_votes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "new_votes",
            |m: &Votes| { &m.new_votes },
            |m: &mut Votes| { &mut m.new_votes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Votes>(
            "Votes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Votes {
    const NAME: &'static str = "Votes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                18 => {
                    self.old_votes.push(is.read_message()?);
                },
                26 => {
                    self.new_votes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        for value in &self.old_votes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.new_votes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        for v in &self.old_votes {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.new_votes {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Votes {
        Votes::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.old_votes.clear();
        self.new_votes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Votes {
        static instance: Votes = Votes {
            address: ::std::vec::Vec::new(),
            old_votes: ::std::vec::Vec::new(),
            new_votes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Votes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Votes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Votes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Votes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.TXOutput)
pub struct TXOutput {
    // message fields
    // @@protoc_insertion_point(field:protocol.TXOutput.value)
    pub value: i64,
    // @@protoc_insertion_point(field:protocol.TXOutput.pubKeyHash)
    pub pubKeyHash: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.TXOutput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TXOutput {
    fn default() -> &'a TXOutput {
        <TXOutput as ::protobuf::Message>::default_instance()
    }
}

impl TXOutput {
    pub fn new() -> TXOutput {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &TXOutput| { &m.value },
            |m: &mut TXOutput| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pubKeyHash",
            |m: &TXOutput| { &m.pubKeyHash },
            |m: &mut TXOutput| { &mut m.pubKeyHash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TXOutput>(
            "TXOutput",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TXOutput {
    const NAME: &'static str = "TXOutput";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.value = is.read_int64()?;
                },
                18 => {
                    self.pubKeyHash = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.value);
        }
        if !self.pubKeyHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.pubKeyHash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.value != 0 {
            os.write_int64(1, self.value)?;
        }
        if !self.pubKeyHash.is_empty() {
            os.write_bytes(2, &self.pubKeyHash)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TXOutput {
        TXOutput::new()
    }

    fn clear(&mut self) {
        self.value = 0;
        self.pubKeyHash.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TXOutput {
        static instance: TXOutput = TXOutput {
            value: 0,
            pubKeyHash: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TXOutput {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TXOutput").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TXOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TXOutput {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.TXInput)
pub struct TXInput {
    // message fields
    // @@protoc_insertion_point(field:protocol.TXInput.raw_data)
    pub raw_data: ::protobuf::MessageField<txinput::Raw>,
    // @@protoc_insertion_point(field:protocol.TXInput.signature)
    pub signature: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.TXInput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TXInput {
    fn default() -> &'a TXInput {
        <TXInput as ::protobuf::Message>::default_instance()
    }
}

impl TXInput {
    pub fn new() -> TXInput {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, txinput::Raw>(
            "raw_data",
            |m: &TXInput| { &m.raw_data },
            |m: &mut TXInput| { &mut m.raw_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signature",
            |m: &TXInput| { &m.signature },
            |m: &mut TXInput| { &mut m.signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TXInput>(
            "TXInput",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TXInput {
    const NAME: &'static str = "TXInput";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.raw_data)?;
                },
                34 => {
                    self.signature = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.raw_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.raw_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(4, &self.signature)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TXInput {
        TXInput::new()
    }

    fn clear(&mut self) {
        self.raw_data.clear();
        self.signature.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TXInput {
        static instance: TXInput = TXInput {
            raw_data: ::protobuf::MessageField::none(),
            signature: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TXInput {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TXInput").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TXInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TXInput {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TXInput`
pub mod txinput {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:protocol.TXInput.raw)
    pub struct Raw {
        // message fields
        // @@protoc_insertion_point(field:protocol.TXInput.raw.txID)
        pub txID: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:protocol.TXInput.raw.vout)
        pub vout: i64,
        // @@protoc_insertion_point(field:protocol.TXInput.raw.pubKey)
        pub pubKey: ::std::vec::Vec<u8>,
        // special fields
        // @@protoc_insertion_point(special_field:protocol.TXInput.raw.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Raw {
        fn default() -> &'a Raw {
            <Raw as ::protobuf::Message>::default_instance()
        }
    }

    impl Raw {
        pub fn new() -> Raw {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "txID",
                |m: &Raw| { &m.txID },
                |m: &mut Raw| { &mut m.txID },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "vout",
                |m: &Raw| { &m.vout },
                |m: &mut Raw| { &mut m.vout },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "pubKey",
                |m: &Raw| { &m.pubKey },
                |m: &mut Raw| { &mut m.pubKey },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Raw>(
                "TXInput.raw",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Raw {
        const NAME: &'static str = "raw";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.txID = is.read_bytes()?;
                    },
                    16 => {
                        self.vout = is.read_int64()?;
                    },
                    26 => {
                        self.pubKey = is.read_bytes()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.txID.is_empty() {
                my_size += ::protobuf::rt::bytes_size(1, &self.txID);
            }
            if self.vout != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.vout);
            }
            if !self.pubKey.is_empty() {
                my_size += ::protobuf::rt::bytes_size(3, &self.pubKey);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.txID.is_empty() {
                os.write_bytes(1, &self.txID)?;
            }
            if self.vout != 0 {
                os.write_int64(2, self.vout)?;
            }
            if !self.pubKey.is_empty() {
                os.write_bytes(3, &self.pubKey)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Raw {
            Raw::new()
        }

        fn clear(&mut self) {
            self.txID.clear();
            self.vout = 0;
            self.pubKey.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Raw {
            static instance: Raw = Raw {
                txID: ::std::vec::Vec::new(),
                vout: 0,
                pubKey: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Raw {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TXInput.raw").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Raw {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Raw {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.TXOutputs)
pub struct TXOutputs {
    // message fields
    // @@protoc_insertion_point(field:protocol.TXOutputs.outputs)
    pub outputs: ::std::vec::Vec<TXOutput>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.TXOutputs.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TXOutputs {
    fn default() -> &'a TXOutputs {
        <TXOutputs as ::protobuf::Message>::default_instance()
    }
}

impl TXOutputs {
    pub fn new() -> TXOutputs {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "outputs",
            |m: &TXOutputs| { &m.outputs },
            |m: &mut TXOutputs| { &mut m.outputs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TXOutputs>(
            "TXOutputs",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TXOutputs {
    const NAME: &'static str = "TXOutputs";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.outputs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.outputs {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TXOutputs {
        TXOutputs::new()
    }

    fn clear(&mut self) {
        self.outputs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TXOutputs {
        static instance: TXOutputs = TXOutputs {
            outputs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TXOutputs {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TXOutputs").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TXOutputs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TXOutputs {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.ResourceReceipt)
pub struct ResourceReceipt {
    // message fields
    // @@protoc_insertion_point(field:protocol.ResourceReceipt.energy_usage)
    pub energy_usage: i64,
    // @@protoc_insertion_point(field:protocol.ResourceReceipt.energy_fee)
    pub energy_fee: i64,
    // @@protoc_insertion_point(field:protocol.ResourceReceipt.origin_energy_usage)
    pub origin_energy_usage: i64,
    // @@protoc_insertion_point(field:protocol.ResourceReceipt.energy_usage_total)
    pub energy_usage_total: i64,
    // @@protoc_insertion_point(field:protocol.ResourceReceipt.net_usage)
    pub net_usage: i64,
    // @@protoc_insertion_point(field:protocol.ResourceReceipt.net_fee)
    pub net_fee: i64,
    // @@protoc_insertion_point(field:protocol.ResourceReceipt.result)
    pub result: ::protobuf::EnumOrUnknown<transaction::result::ContractResult>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.ResourceReceipt.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceReceipt {
    fn default() -> &'a ResourceReceipt {
        <ResourceReceipt as ::protobuf::Message>::default_instance()
    }
}

impl ResourceReceipt {
    pub fn new() -> ResourceReceipt {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "energy_usage",
            |m: &ResourceReceipt| { &m.energy_usage },
            |m: &mut ResourceReceipt| { &mut m.energy_usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "energy_fee",
            |m: &ResourceReceipt| { &m.energy_fee },
            |m: &mut ResourceReceipt| { &mut m.energy_fee },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "origin_energy_usage",
            |m: &ResourceReceipt| { &m.origin_energy_usage },
            |m: &mut ResourceReceipt| { &mut m.origin_energy_usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "energy_usage_total",
            |m: &ResourceReceipt| { &m.energy_usage_total },
            |m: &mut ResourceReceipt| { &mut m.energy_usage_total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "net_usage",
            |m: &ResourceReceipt| { &m.net_usage },
            |m: &mut ResourceReceipt| { &mut m.net_usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "net_fee",
            |m: &ResourceReceipt| { &m.net_fee },
            |m: &mut ResourceReceipt| { &mut m.net_fee },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "result",
            |m: &ResourceReceipt| { &m.result },
            |m: &mut ResourceReceipt| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceReceipt>(
            "ResourceReceipt",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceReceipt {
    const NAME: &'static str = "ResourceReceipt";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.energy_usage = is.read_int64()?;
                },
                16 => {
                    self.energy_fee = is.read_int64()?;
                },
                24 => {
                    self.origin_energy_usage = is.read_int64()?;
                },
                32 => {
                    self.energy_usage_total = is.read_int64()?;
                },
                40 => {
                    self.net_usage = is.read_int64()?;
                },
                48 => {
                    self.net_fee = is.read_int64()?;
                },
                56 => {
                    self.result = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.energy_usage != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.energy_usage);
        }
        if self.energy_fee != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.energy_fee);
        }
        if self.origin_energy_usage != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.origin_energy_usage);
        }
        if self.energy_usage_total != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.energy_usage_total);
        }
        if self.net_usage != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.net_usage);
        }
        if self.net_fee != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.net_fee);
        }
        if self.result != ::protobuf::EnumOrUnknown::new(transaction::result::ContractResult::DEFAULT) {
            my_size += ::protobuf::rt::int32_size(7, self.result.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.energy_usage != 0 {
            os.write_int64(1, self.energy_usage)?;
        }
        if self.energy_fee != 0 {
            os.write_int64(2, self.energy_fee)?;
        }
        if self.origin_energy_usage != 0 {
            os.write_int64(3, self.origin_energy_usage)?;
        }
        if self.energy_usage_total != 0 {
            os.write_int64(4, self.energy_usage_total)?;
        }
        if self.net_usage != 0 {
            os.write_int64(5, self.net_usage)?;
        }
        if self.net_fee != 0 {
            os.write_int64(6, self.net_fee)?;
        }
        if self.result != ::protobuf::EnumOrUnknown::new(transaction::result::ContractResult::DEFAULT) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.result))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceReceipt {
        ResourceReceipt::new()
    }

    fn clear(&mut self) {
        self.energy_usage = 0;
        self.energy_fee = 0;
        self.origin_energy_usage = 0;
        self.energy_usage_total = 0;
        self.net_usage = 0;
        self.net_fee = 0;
        self.result = ::protobuf::EnumOrUnknown::new(transaction::result::ContractResult::DEFAULT);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceReceipt {
        static instance: ResourceReceipt = ResourceReceipt {
            energy_usage: 0,
            energy_fee: 0,
            origin_energy_usage: 0,
            energy_usage_total: 0,
            net_usage: 0,
            net_fee: 0,
            result: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceReceipt {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceReceipt").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceReceipt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceReceipt {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.MarketOrderDetail)
pub struct MarketOrderDetail {
    // message fields
    // @@protoc_insertion_point(field:protocol.MarketOrderDetail.makerOrderId)
    pub makerOrderId: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.MarketOrderDetail.takerOrderId)
    pub takerOrderId: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.MarketOrderDetail.fillSellQuantity)
    pub fillSellQuantity: i64,
    // @@protoc_insertion_point(field:protocol.MarketOrderDetail.fillBuyQuantity)
    pub fillBuyQuantity: i64,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.MarketOrderDetail.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MarketOrderDetail {
    fn default() -> &'a MarketOrderDetail {
        <MarketOrderDetail as ::protobuf::Message>::default_instance()
    }
}

impl MarketOrderDetail {
    pub fn new() -> MarketOrderDetail {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "makerOrderId",
            |m: &MarketOrderDetail| { &m.makerOrderId },
            |m: &mut MarketOrderDetail| { &mut m.makerOrderId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "takerOrderId",
            |m: &MarketOrderDetail| { &m.takerOrderId },
            |m: &mut MarketOrderDetail| { &mut m.takerOrderId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fillSellQuantity",
            |m: &MarketOrderDetail| { &m.fillSellQuantity },
            |m: &mut MarketOrderDetail| { &mut m.fillSellQuantity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fillBuyQuantity",
            |m: &MarketOrderDetail| { &m.fillBuyQuantity },
            |m: &mut MarketOrderDetail| { &mut m.fillBuyQuantity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MarketOrderDetail>(
            "MarketOrderDetail",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MarketOrderDetail {
    const NAME: &'static str = "MarketOrderDetail";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.makerOrderId = is.read_bytes()?;
                },
                18 => {
                    self.takerOrderId = is.read_bytes()?;
                },
                24 => {
                    self.fillSellQuantity = is.read_int64()?;
                },
                32 => {
                    self.fillBuyQuantity = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.makerOrderId.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.makerOrderId);
        }
        if !self.takerOrderId.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.takerOrderId);
        }
        if self.fillSellQuantity != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.fillSellQuantity);
        }
        if self.fillBuyQuantity != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.fillBuyQuantity);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.makerOrderId.is_empty() {
            os.write_bytes(1, &self.makerOrderId)?;
        }
        if !self.takerOrderId.is_empty() {
            os.write_bytes(2, &self.takerOrderId)?;
        }
        if self.fillSellQuantity != 0 {
            os.write_int64(3, self.fillSellQuantity)?;
        }
        if self.fillBuyQuantity != 0 {
            os.write_int64(4, self.fillBuyQuantity)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MarketOrderDetail {
        MarketOrderDetail::new()
    }

    fn clear(&mut self) {
        self.makerOrderId.clear();
        self.takerOrderId.clear();
        self.fillSellQuantity = 0;
        self.fillBuyQuantity = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MarketOrderDetail {
        static instance: MarketOrderDetail = MarketOrderDetail {
            makerOrderId: ::std::vec::Vec::new(),
            takerOrderId: ::std::vec::Vec::new(),
            fillSellQuantity: 0,
            fillBuyQuantity: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MarketOrderDetail {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MarketOrderDetail").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MarketOrderDetail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MarketOrderDetail {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.Transaction)
pub struct Transaction {
    // message fields
    // @@protoc_insertion_point(field:protocol.Transaction.raw_data)
    pub raw_data: ::protobuf::MessageField<transaction::Raw>,
    ///  only support size = 1,  repeated list here for muti-sig extension
    // @@protoc_insertion_point(field:protocol.Transaction.signature)
    pub signature: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:protocol.Transaction.ret)
    pub ret: ::std::vec::Vec<transaction::Result>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.Transaction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Transaction {
    fn default() -> &'a Transaction {
        <Transaction as ::protobuf::Message>::default_instance()
    }
}

impl Transaction {
    pub fn new() -> Transaction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, transaction::Raw>(
            "raw_data",
            |m: &Transaction| { &m.raw_data },
            |m: &mut Transaction| { &mut m.raw_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "signature",
            |m: &Transaction| { &m.signature },
            |m: &mut Transaction| { &mut m.signature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ret",
            |m: &Transaction| { &m.ret },
            |m: &mut Transaction| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Transaction>(
            "Transaction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Transaction {
    const NAME: &'static str = "Transaction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.raw_data)?;
                },
                18 => {
                    self.signature.push(is.read_bytes()?);
                },
                42 => {
                    self.ret.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.raw_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.signature {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        for value in &self.ret {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.raw_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.signature {
            os.write_bytes(2, &v)?;
        };
        for v in &self.ret {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Transaction {
        Transaction::new()
    }

    fn clear(&mut self) {
        self.raw_data.clear();
        self.signature.clear();
        self.ret.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Transaction {
        static instance: Transaction = Transaction {
            raw_data: ::protobuf::MessageField::none(),
            signature: ::std::vec::Vec::new(),
            ret: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Transaction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Transaction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Transaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Transaction`
pub mod transaction {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:protocol.Transaction.Contract)
    pub struct Contract {
        // message fields
        // @@protoc_insertion_point(field:protocol.Transaction.Contract.type)
        pub type_: ::protobuf::EnumOrUnknown<contract::ContractType>,
        // @@protoc_insertion_point(field:protocol.Transaction.Contract.parameter)
        pub parameter: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
        // @@protoc_insertion_point(field:protocol.Transaction.Contract.provider)
        pub provider: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:protocol.Transaction.Contract.ContractName)
        pub ContractName: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:protocol.Transaction.Contract.Permission_id)
        pub Permission_id: i32,
        // special fields
        // @@protoc_insertion_point(special_field:protocol.Transaction.Contract.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Contract {
        fn default() -> &'a Contract {
            <Contract as ::protobuf::Message>::default_instance()
        }
    }

    impl Contract {
        pub fn new() -> Contract {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "type",
                |m: &Contract| { &m.type_ },
                |m: &mut Contract| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
                "parameter",
                |m: &Contract| { &m.parameter },
                |m: &mut Contract| { &mut m.parameter },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "provider",
                |m: &Contract| { &m.provider },
                |m: &mut Contract| { &mut m.provider },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "ContractName",
                |m: &Contract| { &m.ContractName },
                |m: &mut Contract| { &mut m.ContractName },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "Permission_id",
                |m: &Contract| { &m.Permission_id },
                |m: &mut Contract| { &mut m.Permission_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Contract>(
                "Transaction.Contract",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Contract {
        const NAME: &'static str = "Contract";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = is.read_enum_or_unknown()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.parameter)?;
                    },
                    26 => {
                        self.provider = is.read_bytes()?;
                    },
                    34 => {
                        self.ContractName = is.read_bytes()?;
                    },
                    40 => {
                        self.Permission_id = is.read_int32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.type_ != ::protobuf::EnumOrUnknown::new(contract::ContractType::AccountCreateContract) {
                my_size += ::protobuf::rt::int32_size(1, self.type_.value());
            }
            if let Some(v) = self.parameter.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.provider.is_empty() {
                my_size += ::protobuf::rt::bytes_size(3, &self.provider);
            }
            if !self.ContractName.is_empty() {
                my_size += ::protobuf::rt::bytes_size(4, &self.ContractName);
            }
            if self.Permission_id != 0 {
                my_size += ::protobuf::rt::int32_size(5, self.Permission_id);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.type_ != ::protobuf::EnumOrUnknown::new(contract::ContractType::AccountCreateContract) {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
            }
            if let Some(v) = self.parameter.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if !self.provider.is_empty() {
                os.write_bytes(3, &self.provider)?;
            }
            if !self.ContractName.is_empty() {
                os.write_bytes(4, &self.ContractName)?;
            }
            if self.Permission_id != 0 {
                os.write_int32(5, self.Permission_id)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Contract {
            Contract::new()
        }

        fn clear(&mut self) {
            self.type_ = ::protobuf::EnumOrUnknown::new(contract::ContractType::AccountCreateContract);
            self.parameter.clear();
            self.provider.clear();
            self.ContractName.clear();
            self.Permission_id = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Contract {
            static instance: Contract = Contract {
                type_: ::protobuf::EnumOrUnknown::from_i32(0),
                parameter: ::protobuf::MessageField::none(),
                provider: ::std::vec::Vec::new(),
                ContractName: ::std::vec::Vec::new(),
                Permission_id: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Contract {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transaction.Contract").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Contract {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Contract {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Contract`
    pub mod contract {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:protocol.Transaction.Contract.ContractType)
        pub enum ContractType {
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.AccountCreateContract)
            AccountCreateContract = 0,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.TransferContract)
            TransferContract = 1,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.TransferAssetContract)
            TransferAssetContract = 2,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.VoteAssetContract)
            VoteAssetContract = 3,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.VoteWitnessContract)
            VoteWitnessContract = 4,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.WitnessCreateContract)
            WitnessCreateContract = 5,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.AssetIssueContract)
            AssetIssueContract = 6,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.WitnessUpdateContract)
            WitnessUpdateContract = 8,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.ParticipateAssetIssueContract)
            ParticipateAssetIssueContract = 9,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.AccountUpdateContract)
            AccountUpdateContract = 10,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.FreezeBalanceContract)
            FreezeBalanceContract = 11,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.UnfreezeBalanceContract)
            UnfreezeBalanceContract = 12,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.WithdrawBalanceContract)
            WithdrawBalanceContract = 13,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.UnfreezeAssetContract)
            UnfreezeAssetContract = 14,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.UpdateAssetContract)
            UpdateAssetContract = 15,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.ProposalCreateContract)
            ProposalCreateContract = 16,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.ProposalApproveContract)
            ProposalApproveContract = 17,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.ProposalDeleteContract)
            ProposalDeleteContract = 18,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.SetAccountIdContract)
            SetAccountIdContract = 19,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.CustomContract)
            CustomContract = 20,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.CreateSmartContract)
            CreateSmartContract = 30,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.TriggerSmartContract)
            TriggerSmartContract = 31,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.GetContract)
            GetContract = 32,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.UpdateSettingContract)
            UpdateSettingContract = 33,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.ExchangeCreateContract)
            ExchangeCreateContract = 41,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.ExchangeInjectContract)
            ExchangeInjectContract = 42,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.ExchangeWithdrawContract)
            ExchangeWithdrawContract = 43,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.ExchangeTransactionContract)
            ExchangeTransactionContract = 44,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.UpdateEnergyLimitContract)
            UpdateEnergyLimitContract = 45,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.AccountPermissionUpdateContract)
            AccountPermissionUpdateContract = 46,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.ClearABIContract)
            ClearABIContract = 48,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.UpdateBrokerageContract)
            UpdateBrokerageContract = 49,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.ShieldedTransferContract)
            ShieldedTransferContract = 51,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.MarketSellAssetContract)
            MarketSellAssetContract = 52,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Contract.ContractType.MarketCancelOrderContract)
            MarketCancelOrderContract = 53,
        }

        impl ::protobuf::Enum for ContractType {
            const NAME: &'static str = "ContractType";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<ContractType> {
                match value {
                    0 => ::std::option::Option::Some(ContractType::AccountCreateContract),
                    1 => ::std::option::Option::Some(ContractType::TransferContract),
                    2 => ::std::option::Option::Some(ContractType::TransferAssetContract),
                    3 => ::std::option::Option::Some(ContractType::VoteAssetContract),
                    4 => ::std::option::Option::Some(ContractType::VoteWitnessContract),
                    5 => ::std::option::Option::Some(ContractType::WitnessCreateContract),
                    6 => ::std::option::Option::Some(ContractType::AssetIssueContract),
                    8 => ::std::option::Option::Some(ContractType::WitnessUpdateContract),
                    9 => ::std::option::Option::Some(ContractType::ParticipateAssetIssueContract),
                    10 => ::std::option::Option::Some(ContractType::AccountUpdateContract),
                    11 => ::std::option::Option::Some(ContractType::FreezeBalanceContract),
                    12 => ::std::option::Option::Some(ContractType::UnfreezeBalanceContract),
                    13 => ::std::option::Option::Some(ContractType::WithdrawBalanceContract),
                    14 => ::std::option::Option::Some(ContractType::UnfreezeAssetContract),
                    15 => ::std::option::Option::Some(ContractType::UpdateAssetContract),
                    16 => ::std::option::Option::Some(ContractType::ProposalCreateContract),
                    17 => ::std::option::Option::Some(ContractType::ProposalApproveContract),
                    18 => ::std::option::Option::Some(ContractType::ProposalDeleteContract),
                    19 => ::std::option::Option::Some(ContractType::SetAccountIdContract),
                    20 => ::std::option::Option::Some(ContractType::CustomContract),
                    30 => ::std::option::Option::Some(ContractType::CreateSmartContract),
                    31 => ::std::option::Option::Some(ContractType::TriggerSmartContract),
                    32 => ::std::option::Option::Some(ContractType::GetContract),
                    33 => ::std::option::Option::Some(ContractType::UpdateSettingContract),
                    41 => ::std::option::Option::Some(ContractType::ExchangeCreateContract),
                    42 => ::std::option::Option::Some(ContractType::ExchangeInjectContract),
                    43 => ::std::option::Option::Some(ContractType::ExchangeWithdrawContract),
                    44 => ::std::option::Option::Some(ContractType::ExchangeTransactionContract),
                    45 => ::std::option::Option::Some(ContractType::UpdateEnergyLimitContract),
                    46 => ::std::option::Option::Some(ContractType::AccountPermissionUpdateContract),
                    48 => ::std::option::Option::Some(ContractType::ClearABIContract),
                    49 => ::std::option::Option::Some(ContractType::UpdateBrokerageContract),
                    51 => ::std::option::Option::Some(ContractType::ShieldedTransferContract),
                    52 => ::std::option::Option::Some(ContractType::MarketSellAssetContract),
                    53 => ::std::option::Option::Some(ContractType::MarketCancelOrderContract),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [ContractType] = &[
                ContractType::AccountCreateContract,
                ContractType::TransferContract,
                ContractType::TransferAssetContract,
                ContractType::VoteAssetContract,
                ContractType::VoteWitnessContract,
                ContractType::WitnessCreateContract,
                ContractType::AssetIssueContract,
                ContractType::WitnessUpdateContract,
                ContractType::ParticipateAssetIssueContract,
                ContractType::AccountUpdateContract,
                ContractType::FreezeBalanceContract,
                ContractType::UnfreezeBalanceContract,
                ContractType::WithdrawBalanceContract,
                ContractType::UnfreezeAssetContract,
                ContractType::UpdateAssetContract,
                ContractType::ProposalCreateContract,
                ContractType::ProposalApproveContract,
                ContractType::ProposalDeleteContract,
                ContractType::SetAccountIdContract,
                ContractType::CustomContract,
                ContractType::CreateSmartContract,
                ContractType::TriggerSmartContract,
                ContractType::GetContract,
                ContractType::UpdateSettingContract,
                ContractType::ExchangeCreateContract,
                ContractType::ExchangeInjectContract,
                ContractType::ExchangeWithdrawContract,
                ContractType::ExchangeTransactionContract,
                ContractType::UpdateEnergyLimitContract,
                ContractType::AccountPermissionUpdateContract,
                ContractType::ClearABIContract,
                ContractType::UpdateBrokerageContract,
                ContractType::ShieldedTransferContract,
                ContractType::MarketSellAssetContract,
                ContractType::MarketCancelOrderContract,
            ];
        }

        impl ::protobuf::EnumFull for ContractType {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("Transaction.Contract.ContractType").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = match self {
                    ContractType::AccountCreateContract => 0,
                    ContractType::TransferContract => 1,
                    ContractType::TransferAssetContract => 2,
                    ContractType::VoteAssetContract => 3,
                    ContractType::VoteWitnessContract => 4,
                    ContractType::WitnessCreateContract => 5,
                    ContractType::AssetIssueContract => 6,
                    ContractType::WitnessUpdateContract => 7,
                    ContractType::ParticipateAssetIssueContract => 8,
                    ContractType::AccountUpdateContract => 9,
                    ContractType::FreezeBalanceContract => 10,
                    ContractType::UnfreezeBalanceContract => 11,
                    ContractType::WithdrawBalanceContract => 12,
                    ContractType::UnfreezeAssetContract => 13,
                    ContractType::UpdateAssetContract => 14,
                    ContractType::ProposalCreateContract => 15,
                    ContractType::ProposalApproveContract => 16,
                    ContractType::ProposalDeleteContract => 17,
                    ContractType::SetAccountIdContract => 18,
                    ContractType::CustomContract => 19,
                    ContractType::CreateSmartContract => 20,
                    ContractType::TriggerSmartContract => 21,
                    ContractType::GetContract => 22,
                    ContractType::UpdateSettingContract => 23,
                    ContractType::ExchangeCreateContract => 24,
                    ContractType::ExchangeInjectContract => 25,
                    ContractType::ExchangeWithdrawContract => 26,
                    ContractType::ExchangeTransactionContract => 27,
                    ContractType::UpdateEnergyLimitContract => 28,
                    ContractType::AccountPermissionUpdateContract => 29,
                    ContractType::ClearABIContract => 30,
                    ContractType::UpdateBrokerageContract => 31,
                    ContractType::ShieldedTransferContract => 32,
                    ContractType::MarketSellAssetContract => 33,
                    ContractType::MarketCancelOrderContract => 34,
                };
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for ContractType {
            fn default() -> Self {
                ContractType::AccountCreateContract
            }
        }

        impl ContractType {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ContractType>("Transaction.Contract.ContractType")
            }
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:protocol.Transaction.Result)
    pub struct Result {
        // message fields
        // @@protoc_insertion_point(field:protocol.Transaction.Result.fee)
        pub fee: i64,
        // @@protoc_insertion_point(field:protocol.Transaction.Result.ret)
        pub ret: ::protobuf::EnumOrUnknown<result::Code>,
        // @@protoc_insertion_point(field:protocol.Transaction.Result.contractRet)
        pub contractRet: ::protobuf::EnumOrUnknown<result::ContractResult>,
        // @@protoc_insertion_point(field:protocol.Transaction.Result.assetIssueID)
        pub assetIssueID: ::std::string::String,
        // @@protoc_insertion_point(field:protocol.Transaction.Result.withdraw_amount)
        pub withdraw_amount: i64,
        // @@protoc_insertion_point(field:protocol.Transaction.Result.unfreeze_amount)
        pub unfreeze_amount: i64,
        // @@protoc_insertion_point(field:protocol.Transaction.Result.exchange_received_amount)
        pub exchange_received_amount: i64,
        // @@protoc_insertion_point(field:protocol.Transaction.Result.exchange_inject_another_amount)
        pub exchange_inject_another_amount: i64,
        // @@protoc_insertion_point(field:protocol.Transaction.Result.exchange_withdraw_another_amount)
        pub exchange_withdraw_another_amount: i64,
        // @@protoc_insertion_point(field:protocol.Transaction.Result.exchange_id)
        pub exchange_id: i64,
        // @@protoc_insertion_point(field:protocol.Transaction.Result.shielded_transaction_fee)
        pub shielded_transaction_fee: i64,
        // @@protoc_insertion_point(field:protocol.Transaction.Result.orderId)
        pub orderId: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:protocol.Transaction.Result.orderDetails)
        pub orderDetails: ::std::vec::Vec<super::MarketOrderDetail>,
        // special fields
        // @@protoc_insertion_point(special_field:protocol.Transaction.Result.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Result {
        fn default() -> &'a Result {
            <Result as ::protobuf::Message>::default_instance()
        }
    }

    impl Result {
        pub fn new() -> Result {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(13);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "fee",
                |m: &Result| { &m.fee },
                |m: &mut Result| { &mut m.fee },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "ret",
                |m: &Result| { &m.ret },
                |m: &mut Result| { &mut m.ret },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "contractRet",
                |m: &Result| { &m.contractRet },
                |m: &mut Result| { &mut m.contractRet },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "assetIssueID",
                |m: &Result| { &m.assetIssueID },
                |m: &mut Result| { &mut m.assetIssueID },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "withdraw_amount",
                |m: &Result| { &m.withdraw_amount },
                |m: &mut Result| { &mut m.withdraw_amount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "unfreeze_amount",
                |m: &Result| { &m.unfreeze_amount },
                |m: &mut Result| { &mut m.unfreeze_amount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "exchange_received_amount",
                |m: &Result| { &m.exchange_received_amount },
                |m: &mut Result| { &mut m.exchange_received_amount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "exchange_inject_another_amount",
                |m: &Result| { &m.exchange_inject_another_amount },
                |m: &mut Result| { &mut m.exchange_inject_another_amount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "exchange_withdraw_another_amount",
                |m: &Result| { &m.exchange_withdraw_another_amount },
                |m: &mut Result| { &mut m.exchange_withdraw_another_amount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "exchange_id",
                |m: &Result| { &m.exchange_id },
                |m: &mut Result| { &mut m.exchange_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "shielded_transaction_fee",
                |m: &Result| { &m.shielded_transaction_fee },
                |m: &mut Result| { &mut m.shielded_transaction_fee },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "orderId",
                |m: &Result| { &m.orderId },
                |m: &mut Result| { &mut m.orderId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "orderDetails",
                |m: &Result| { &m.orderDetails },
                |m: &mut Result| { &mut m.orderDetails },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Result>(
                "Transaction.Result",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Result {
        const NAME: &'static str = "Result";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.fee = is.read_int64()?;
                    },
                    16 => {
                        self.ret = is.read_enum_or_unknown()?;
                    },
                    24 => {
                        self.contractRet = is.read_enum_or_unknown()?;
                    },
                    114 => {
                        self.assetIssueID = is.read_string()?;
                    },
                    120 => {
                        self.withdraw_amount = is.read_int64()?;
                    },
                    128 => {
                        self.unfreeze_amount = is.read_int64()?;
                    },
                    144 => {
                        self.exchange_received_amount = is.read_int64()?;
                    },
                    152 => {
                        self.exchange_inject_another_amount = is.read_int64()?;
                    },
                    160 => {
                        self.exchange_withdraw_another_amount = is.read_int64()?;
                    },
                    168 => {
                        self.exchange_id = is.read_int64()?;
                    },
                    176 => {
                        self.shielded_transaction_fee = is.read_int64()?;
                    },
                    202 => {
                        self.orderId = is.read_bytes()?;
                    },
                    210 => {
                        self.orderDetails.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.fee != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.fee);
            }
            if self.ret != ::protobuf::EnumOrUnknown::new(result::Code::SUCESS) {
                my_size += ::protobuf::rt::int32_size(2, self.ret.value());
            }
            if self.contractRet != ::protobuf::EnumOrUnknown::new(result::ContractResult::DEFAULT) {
                my_size += ::protobuf::rt::int32_size(3, self.contractRet.value());
            }
            if !self.assetIssueID.is_empty() {
                my_size += ::protobuf::rt::string_size(14, &self.assetIssueID);
            }
            if self.withdraw_amount != 0 {
                my_size += ::protobuf::rt::int64_size(15, self.withdraw_amount);
            }
            if self.unfreeze_amount != 0 {
                my_size += ::protobuf::rt::int64_size(16, self.unfreeze_amount);
            }
            if self.exchange_received_amount != 0 {
                my_size += ::protobuf::rt::int64_size(18, self.exchange_received_amount);
            }
            if self.exchange_inject_another_amount != 0 {
                my_size += ::protobuf::rt::int64_size(19, self.exchange_inject_another_amount);
            }
            if self.exchange_withdraw_another_amount != 0 {
                my_size += ::protobuf::rt::int64_size(20, self.exchange_withdraw_another_amount);
            }
            if self.exchange_id != 0 {
                my_size += ::protobuf::rt::int64_size(21, self.exchange_id);
            }
            if self.shielded_transaction_fee != 0 {
                my_size += ::protobuf::rt::int64_size(22, self.shielded_transaction_fee);
            }
            if !self.orderId.is_empty() {
                my_size += ::protobuf::rt::bytes_size(25, &self.orderId);
            }
            for value in &self.orderDetails {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.fee != 0 {
                os.write_int64(1, self.fee)?;
            }
            if self.ret != ::protobuf::EnumOrUnknown::new(result::Code::SUCESS) {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.ret))?;
            }
            if self.contractRet != ::protobuf::EnumOrUnknown::new(result::ContractResult::DEFAULT) {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.contractRet))?;
            }
            if !self.assetIssueID.is_empty() {
                os.write_string(14, &self.assetIssueID)?;
            }
            if self.withdraw_amount != 0 {
                os.write_int64(15, self.withdraw_amount)?;
            }
            if self.unfreeze_amount != 0 {
                os.write_int64(16, self.unfreeze_amount)?;
            }
            if self.exchange_received_amount != 0 {
                os.write_int64(18, self.exchange_received_amount)?;
            }
            if self.exchange_inject_another_amount != 0 {
                os.write_int64(19, self.exchange_inject_another_amount)?;
            }
            if self.exchange_withdraw_another_amount != 0 {
                os.write_int64(20, self.exchange_withdraw_another_amount)?;
            }
            if self.exchange_id != 0 {
                os.write_int64(21, self.exchange_id)?;
            }
            if self.shielded_transaction_fee != 0 {
                os.write_int64(22, self.shielded_transaction_fee)?;
            }
            if !self.orderId.is_empty() {
                os.write_bytes(25, &self.orderId)?;
            }
            for v in &self.orderDetails {
                ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Result {
            Result::new()
        }

        fn clear(&mut self) {
            self.fee = 0;
            self.ret = ::protobuf::EnumOrUnknown::new(result::Code::SUCESS);
            self.contractRet = ::protobuf::EnumOrUnknown::new(result::ContractResult::DEFAULT);
            self.assetIssueID.clear();
            self.withdraw_amount = 0;
            self.unfreeze_amount = 0;
            self.exchange_received_amount = 0;
            self.exchange_inject_another_amount = 0;
            self.exchange_withdraw_another_amount = 0;
            self.exchange_id = 0;
            self.shielded_transaction_fee = 0;
            self.orderId.clear();
            self.orderDetails.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Result {
            static instance: Result = Result {
                fee: 0,
                ret: ::protobuf::EnumOrUnknown::from_i32(0),
                contractRet: ::protobuf::EnumOrUnknown::from_i32(0),
                assetIssueID: ::std::string::String::new(),
                withdraw_amount: 0,
                unfreeze_amount: 0,
                exchange_received_amount: 0,
                exchange_inject_another_amount: 0,
                exchange_withdraw_another_amount: 0,
                exchange_id: 0,
                shielded_transaction_fee: 0,
                orderId: ::std::vec::Vec::new(),
                orderDetails: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Result {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transaction.Result").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Result {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Result {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Result`
    pub mod result {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:protocol.Transaction.Result.code)
        pub enum Code {
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Result.code.SUCESS)
            SUCESS = 0,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Result.code.FAILED)
            FAILED = 1,
        }

        impl ::protobuf::Enum for Code {
            const NAME: &'static str = "code";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Code> {
                match value {
                    0 => ::std::option::Option::Some(Code::SUCESS),
                    1 => ::std::option::Option::Some(Code::FAILED),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Code] = &[
                Code::SUCESS,
                Code::FAILED,
            ];
        }

        impl ::protobuf::EnumFull for Code {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("Transaction.Result.code").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for Code {
            fn default() -> Self {
                Code::SUCESS
            }
        }

        impl Code {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Code>("Transaction.Result.code")
            }
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:protocol.Transaction.Result.contractResult)
        pub enum ContractResult {
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Result.contractResult.DEFAULT)
            DEFAULT = 0,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Result.contractResult.SUCCESS)
            SUCCESS = 1,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Result.contractResult.REVERT)
            REVERT = 2,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Result.contractResult.BAD_JUMP_DESTINATION)
            BAD_JUMP_DESTINATION = 3,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Result.contractResult.OUT_OF_MEMORY)
            OUT_OF_MEMORY = 4,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Result.contractResult.PRECOMPILED_CONTRACT)
            PRECOMPILED_CONTRACT = 5,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Result.contractResult.STACK_TOO_SMALL)
            STACK_TOO_SMALL = 6,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Result.contractResult.STACK_TOO_LARGE)
            STACK_TOO_LARGE = 7,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Result.contractResult.ILLEGAL_OPERATION)
            ILLEGAL_OPERATION = 8,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Result.contractResult.STACK_OVERFLOW)
            STACK_OVERFLOW = 9,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Result.contractResult.OUT_OF_ENERGY)
            OUT_OF_ENERGY = 10,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Result.contractResult.OUT_OF_TIME)
            OUT_OF_TIME = 11,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Result.contractResult.JVM_STACK_OVER_FLOW)
            JVM_STACK_OVER_FLOW = 12,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Result.contractResult.UNKNOWN)
            UNKNOWN = 13,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Result.contractResult.TRANSFER_FAILED)
            TRANSFER_FAILED = 14,
            // @@protoc_insertion_point(enum_value:protocol.Transaction.Result.contractResult.INVALID_CODE)
            INVALID_CODE = 15,
        }

        impl ::protobuf::Enum for ContractResult {
            const NAME: &'static str = "contractResult";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<ContractResult> {
                match value {
                    0 => ::std::option::Option::Some(ContractResult::DEFAULT),
                    1 => ::std::option::Option::Some(ContractResult::SUCCESS),
                    2 => ::std::option::Option::Some(ContractResult::REVERT),
                    3 => ::std::option::Option::Some(ContractResult::BAD_JUMP_DESTINATION),
                    4 => ::std::option::Option::Some(ContractResult::OUT_OF_MEMORY),
                    5 => ::std::option::Option::Some(ContractResult::PRECOMPILED_CONTRACT),
                    6 => ::std::option::Option::Some(ContractResult::STACK_TOO_SMALL),
                    7 => ::std::option::Option::Some(ContractResult::STACK_TOO_LARGE),
                    8 => ::std::option::Option::Some(ContractResult::ILLEGAL_OPERATION),
                    9 => ::std::option::Option::Some(ContractResult::STACK_OVERFLOW),
                    10 => ::std::option::Option::Some(ContractResult::OUT_OF_ENERGY),
                    11 => ::std::option::Option::Some(ContractResult::OUT_OF_TIME),
                    12 => ::std::option::Option::Some(ContractResult::JVM_STACK_OVER_FLOW),
                    13 => ::std::option::Option::Some(ContractResult::UNKNOWN),
                    14 => ::std::option::Option::Some(ContractResult::TRANSFER_FAILED),
                    15 => ::std::option::Option::Some(ContractResult::INVALID_CODE),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [ContractResult] = &[
                ContractResult::DEFAULT,
                ContractResult::SUCCESS,
                ContractResult::REVERT,
                ContractResult::BAD_JUMP_DESTINATION,
                ContractResult::OUT_OF_MEMORY,
                ContractResult::PRECOMPILED_CONTRACT,
                ContractResult::STACK_TOO_SMALL,
                ContractResult::STACK_TOO_LARGE,
                ContractResult::ILLEGAL_OPERATION,
                ContractResult::STACK_OVERFLOW,
                ContractResult::OUT_OF_ENERGY,
                ContractResult::OUT_OF_TIME,
                ContractResult::JVM_STACK_OVER_FLOW,
                ContractResult::UNKNOWN,
                ContractResult::TRANSFER_FAILED,
                ContractResult::INVALID_CODE,
            ];
        }

        impl ::protobuf::EnumFull for ContractResult {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("Transaction.Result.contractResult").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for ContractResult {
            fn default() -> Self {
                ContractResult::DEFAULT
            }
        }

        impl ContractResult {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ContractResult>("Transaction.Result.contractResult")
            }
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:protocol.Transaction.raw)
    pub struct Raw {
        // message fields
        // @@protoc_insertion_point(field:protocol.Transaction.raw.ref_block_bytes)
        pub ref_block_bytes: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:protocol.Transaction.raw.ref_block_num)
        pub ref_block_num: i64,
        // @@protoc_insertion_point(field:protocol.Transaction.raw.ref_block_hash)
        pub ref_block_hash: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:protocol.Transaction.raw.expiration)
        pub expiration: i64,
        // @@protoc_insertion_point(field:protocol.Transaction.raw.auths)
        pub auths: ::std::vec::Vec<super::Authority>,
        ///  data not used
        // @@protoc_insertion_point(field:protocol.Transaction.raw.data)
        pub data: ::std::vec::Vec<u8>,
        /// only support size = 1,  repeated list here for extension
        // @@protoc_insertion_point(field:protocol.Transaction.raw.contract)
        pub contract: ::std::vec::Vec<Contract>,
        ///  scripts not used
        // @@protoc_insertion_point(field:protocol.Transaction.raw.scripts)
        pub scripts: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:protocol.Transaction.raw.timestamp)
        pub timestamp: i64,
        // @@protoc_insertion_point(field:protocol.Transaction.raw.fee_limit)
        pub fee_limit: i64,
        // special fields
        // @@protoc_insertion_point(special_field:protocol.Transaction.raw.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Raw {
        fn default() -> &'a Raw {
            <Raw as ::protobuf::Message>::default_instance()
        }
    }

    impl Raw {
        pub fn new() -> Raw {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(10);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "ref_block_bytes",
                |m: &Raw| { &m.ref_block_bytes },
                |m: &mut Raw| { &mut m.ref_block_bytes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "ref_block_num",
                |m: &Raw| { &m.ref_block_num },
                |m: &mut Raw| { &mut m.ref_block_num },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "ref_block_hash",
                |m: &Raw| { &m.ref_block_hash },
                |m: &mut Raw| { &mut m.ref_block_hash },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "expiration",
                |m: &Raw| { &m.expiration },
                |m: &mut Raw| { &mut m.expiration },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "auths",
                |m: &Raw| { &m.auths },
                |m: &mut Raw| { &mut m.auths },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data",
                |m: &Raw| { &m.data },
                |m: &mut Raw| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "contract",
                |m: &Raw| { &m.contract },
                |m: &mut Raw| { &mut m.contract },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "scripts",
                |m: &Raw| { &m.scripts },
                |m: &mut Raw| { &mut m.scripts },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "timestamp",
                |m: &Raw| { &m.timestamp },
                |m: &mut Raw| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "fee_limit",
                |m: &Raw| { &m.fee_limit },
                |m: &mut Raw| { &mut m.fee_limit },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Raw>(
                "Transaction.raw",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Raw {
        const NAME: &'static str = "raw";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.ref_block_bytes = is.read_bytes()?;
                    },
                    24 => {
                        self.ref_block_num = is.read_int64()?;
                    },
                    34 => {
                        self.ref_block_hash = is.read_bytes()?;
                    },
                    64 => {
                        self.expiration = is.read_int64()?;
                    },
                    74 => {
                        self.auths.push(is.read_message()?);
                    },
                    82 => {
                        self.data = is.read_bytes()?;
                    },
                    90 => {
                        self.contract.push(is.read_message()?);
                    },
                    98 => {
                        self.scripts = is.read_bytes()?;
                    },
                    112 => {
                        self.timestamp = is.read_int64()?;
                    },
                    144 => {
                        self.fee_limit = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.ref_block_bytes.is_empty() {
                my_size += ::protobuf::rt::bytes_size(1, &self.ref_block_bytes);
            }
            if self.ref_block_num != 0 {
                my_size += ::protobuf::rt::int64_size(3, self.ref_block_num);
            }
            if !self.ref_block_hash.is_empty() {
                my_size += ::protobuf::rt::bytes_size(4, &self.ref_block_hash);
            }
            if self.expiration != 0 {
                my_size += ::protobuf::rt::int64_size(8, self.expiration);
            }
            for value in &self.auths {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if !self.data.is_empty() {
                my_size += ::protobuf::rt::bytes_size(10, &self.data);
            }
            for value in &self.contract {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if !self.scripts.is_empty() {
                my_size += ::protobuf::rt::bytes_size(12, &self.scripts);
            }
            if self.timestamp != 0 {
                my_size += ::protobuf::rt::int64_size(14, self.timestamp);
            }
            if self.fee_limit != 0 {
                my_size += ::protobuf::rt::int64_size(18, self.fee_limit);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.ref_block_bytes.is_empty() {
                os.write_bytes(1, &self.ref_block_bytes)?;
            }
            if self.ref_block_num != 0 {
                os.write_int64(3, self.ref_block_num)?;
            }
            if !self.ref_block_hash.is_empty() {
                os.write_bytes(4, &self.ref_block_hash)?;
            }
            if self.expiration != 0 {
                os.write_int64(8, self.expiration)?;
            }
            for v in &self.auths {
                ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
            };
            if !self.data.is_empty() {
                os.write_bytes(10, &self.data)?;
            }
            for v in &self.contract {
                ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
            };
            if !self.scripts.is_empty() {
                os.write_bytes(12, &self.scripts)?;
            }
            if self.timestamp != 0 {
                os.write_int64(14, self.timestamp)?;
            }
            if self.fee_limit != 0 {
                os.write_int64(18, self.fee_limit)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Raw {
            Raw::new()
        }

        fn clear(&mut self) {
            self.ref_block_bytes.clear();
            self.ref_block_num = 0;
            self.ref_block_hash.clear();
            self.expiration = 0;
            self.auths.clear();
            self.data.clear();
            self.contract.clear();
            self.scripts.clear();
            self.timestamp = 0;
            self.fee_limit = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Raw {
            static instance: Raw = Raw {
                ref_block_bytes: ::std::vec::Vec::new(),
                ref_block_num: 0,
                ref_block_hash: ::std::vec::Vec::new(),
                expiration: 0,
                auths: ::std::vec::Vec::new(),
                data: ::std::vec::Vec::new(),
                contract: ::std::vec::Vec::new(),
                scripts: ::std::vec::Vec::new(),
                timestamp: 0,
                fee_limit: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Raw {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transaction.raw").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Raw {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Raw {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.TransactionInfo)
pub struct TransactionInfo {
    // message fields
    // @@protoc_insertion_point(field:protocol.TransactionInfo.id)
    pub id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.TransactionInfo.fee)
    pub fee: i64,
    // @@protoc_insertion_point(field:protocol.TransactionInfo.blockNumber)
    pub blockNumber: i64,
    // @@protoc_insertion_point(field:protocol.TransactionInfo.blockTimeStamp)
    pub blockTimeStamp: i64,
    // @@protoc_insertion_point(field:protocol.TransactionInfo.contractResult)
    pub contractResult: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:protocol.TransactionInfo.contract_address)
    pub contract_address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.TransactionInfo.receipt)
    pub receipt: ::protobuf::MessageField<ResourceReceipt>,
    // @@protoc_insertion_point(field:protocol.TransactionInfo.log)
    pub log: ::std::vec::Vec<transaction_info::Log>,
    // @@protoc_insertion_point(field:protocol.TransactionInfo.result)
    pub result: ::protobuf::EnumOrUnknown<transaction_info::Code>,
    // @@protoc_insertion_point(field:protocol.TransactionInfo.resMessage)
    pub resMessage: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.TransactionInfo.assetIssueID)
    pub assetIssueID: ::std::string::String,
    // @@protoc_insertion_point(field:protocol.TransactionInfo.withdraw_amount)
    pub withdraw_amount: i64,
    // @@protoc_insertion_point(field:protocol.TransactionInfo.unfreeze_amount)
    pub unfreeze_amount: i64,
    // @@protoc_insertion_point(field:protocol.TransactionInfo.internal_transactions)
    pub internal_transactions: ::std::vec::Vec<InternalTransaction>,
    // @@protoc_insertion_point(field:protocol.TransactionInfo.exchange_received_amount)
    pub exchange_received_amount: i64,
    // @@protoc_insertion_point(field:protocol.TransactionInfo.exchange_inject_another_amount)
    pub exchange_inject_another_amount: i64,
    // @@protoc_insertion_point(field:protocol.TransactionInfo.exchange_withdraw_another_amount)
    pub exchange_withdraw_another_amount: i64,
    // @@protoc_insertion_point(field:protocol.TransactionInfo.exchange_id)
    pub exchange_id: i64,
    // @@protoc_insertion_point(field:protocol.TransactionInfo.shielded_transaction_fee)
    pub shielded_transaction_fee: i64,
    // @@protoc_insertion_point(field:protocol.TransactionInfo.orderId)
    pub orderId: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.TransactionInfo.orderDetails)
    pub orderDetails: ::std::vec::Vec<MarketOrderDetail>,
    // @@protoc_insertion_point(field:protocol.TransactionInfo.packingFee)
    pub packingFee: i64,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.TransactionInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransactionInfo {
    fn default() -> &'a TransactionInfo {
        <TransactionInfo as ::protobuf::Message>::default_instance()
    }
}

impl TransactionInfo {
    pub fn new() -> TransactionInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(22);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &TransactionInfo| { &m.id },
            |m: &mut TransactionInfo| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fee",
            |m: &TransactionInfo| { &m.fee },
            |m: &mut TransactionInfo| { &mut m.fee },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "blockNumber",
            |m: &TransactionInfo| { &m.blockNumber },
            |m: &mut TransactionInfo| { &mut m.blockNumber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "blockTimeStamp",
            |m: &TransactionInfo| { &m.blockTimeStamp },
            |m: &mut TransactionInfo| { &mut m.blockTimeStamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "contractResult",
            |m: &TransactionInfo| { &m.contractResult },
            |m: &mut TransactionInfo| { &mut m.contractResult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "contract_address",
            |m: &TransactionInfo| { &m.contract_address },
            |m: &mut TransactionInfo| { &mut m.contract_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceReceipt>(
            "receipt",
            |m: &TransactionInfo| { &m.receipt },
            |m: &mut TransactionInfo| { &mut m.receipt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "log",
            |m: &TransactionInfo| { &m.log },
            |m: &mut TransactionInfo| { &mut m.log },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "result",
            |m: &TransactionInfo| { &m.result },
            |m: &mut TransactionInfo| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "resMessage",
            |m: &TransactionInfo| { &m.resMessage },
            |m: &mut TransactionInfo| { &mut m.resMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "assetIssueID",
            |m: &TransactionInfo| { &m.assetIssueID },
            |m: &mut TransactionInfo| { &mut m.assetIssueID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "withdraw_amount",
            |m: &TransactionInfo| { &m.withdraw_amount },
            |m: &mut TransactionInfo| { &mut m.withdraw_amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unfreeze_amount",
            |m: &TransactionInfo| { &m.unfreeze_amount },
            |m: &mut TransactionInfo| { &mut m.unfreeze_amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "internal_transactions",
            |m: &TransactionInfo| { &m.internal_transactions },
            |m: &mut TransactionInfo| { &mut m.internal_transactions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exchange_received_amount",
            |m: &TransactionInfo| { &m.exchange_received_amount },
            |m: &mut TransactionInfo| { &mut m.exchange_received_amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exchange_inject_another_amount",
            |m: &TransactionInfo| { &m.exchange_inject_another_amount },
            |m: &mut TransactionInfo| { &mut m.exchange_inject_another_amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exchange_withdraw_another_amount",
            |m: &TransactionInfo| { &m.exchange_withdraw_another_amount },
            |m: &mut TransactionInfo| { &mut m.exchange_withdraw_another_amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exchange_id",
            |m: &TransactionInfo| { &m.exchange_id },
            |m: &mut TransactionInfo| { &mut m.exchange_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shielded_transaction_fee",
            |m: &TransactionInfo| { &m.shielded_transaction_fee },
            |m: &mut TransactionInfo| { &mut m.shielded_transaction_fee },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "orderId",
            |m: &TransactionInfo| { &m.orderId },
            |m: &mut TransactionInfo| { &mut m.orderId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "orderDetails",
            |m: &TransactionInfo| { &m.orderDetails },
            |m: &mut TransactionInfo| { &mut m.orderDetails },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "packingFee",
            |m: &TransactionInfo| { &m.packingFee },
            |m: &mut TransactionInfo| { &mut m.packingFee },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransactionInfo>(
            "TransactionInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransactionInfo {
    const NAME: &'static str = "TransactionInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_bytes()?;
                },
                16 => {
                    self.fee = is.read_int64()?;
                },
                24 => {
                    self.blockNumber = is.read_int64()?;
                },
                32 => {
                    self.blockTimeStamp = is.read_int64()?;
                },
                42 => {
                    self.contractResult.push(is.read_bytes()?);
                },
                50 => {
                    self.contract_address = is.read_bytes()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.receipt)?;
                },
                66 => {
                    self.log.push(is.read_message()?);
                },
                72 => {
                    self.result = is.read_enum_or_unknown()?;
                },
                82 => {
                    self.resMessage = is.read_bytes()?;
                },
                114 => {
                    self.assetIssueID = is.read_string()?;
                },
                120 => {
                    self.withdraw_amount = is.read_int64()?;
                },
                128 => {
                    self.unfreeze_amount = is.read_int64()?;
                },
                138 => {
                    self.internal_transactions.push(is.read_message()?);
                },
                144 => {
                    self.exchange_received_amount = is.read_int64()?;
                },
                152 => {
                    self.exchange_inject_another_amount = is.read_int64()?;
                },
                160 => {
                    self.exchange_withdraw_another_amount = is.read_int64()?;
                },
                168 => {
                    self.exchange_id = is.read_int64()?;
                },
                176 => {
                    self.shielded_transaction_fee = is.read_int64()?;
                },
                202 => {
                    self.orderId = is.read_bytes()?;
                },
                210 => {
                    self.orderDetails.push(is.read_message()?);
                },
                216 => {
                    self.packingFee = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.id);
        }
        if self.fee != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.fee);
        }
        if self.blockNumber != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.blockNumber);
        }
        if self.blockTimeStamp != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.blockTimeStamp);
        }
        for value in &self.contractResult {
            my_size += ::protobuf::rt::bytes_size(5, &value);
        };
        if !self.contract_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.contract_address);
        }
        if let Some(v) = self.receipt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.log {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.result != ::protobuf::EnumOrUnknown::new(transaction_info::Code::SUCESS) {
            my_size += ::protobuf::rt::int32_size(9, self.result.value());
        }
        if !self.resMessage.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.resMessage);
        }
        if !self.assetIssueID.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.assetIssueID);
        }
        if self.withdraw_amount != 0 {
            my_size += ::protobuf::rt::int64_size(15, self.withdraw_amount);
        }
        if self.unfreeze_amount != 0 {
            my_size += ::protobuf::rt::int64_size(16, self.unfreeze_amount);
        }
        for value in &self.internal_transactions {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.exchange_received_amount != 0 {
            my_size += ::protobuf::rt::int64_size(18, self.exchange_received_amount);
        }
        if self.exchange_inject_another_amount != 0 {
            my_size += ::protobuf::rt::int64_size(19, self.exchange_inject_another_amount);
        }
        if self.exchange_withdraw_another_amount != 0 {
            my_size += ::protobuf::rt::int64_size(20, self.exchange_withdraw_another_amount);
        }
        if self.exchange_id != 0 {
            my_size += ::protobuf::rt::int64_size(21, self.exchange_id);
        }
        if self.shielded_transaction_fee != 0 {
            my_size += ::protobuf::rt::int64_size(22, self.shielded_transaction_fee);
        }
        if !self.orderId.is_empty() {
            my_size += ::protobuf::rt::bytes_size(25, &self.orderId);
        }
        for value in &self.orderDetails {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.packingFee != 0 {
            my_size += ::protobuf::rt::int64_size(27, self.packingFee);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_bytes(1, &self.id)?;
        }
        if self.fee != 0 {
            os.write_int64(2, self.fee)?;
        }
        if self.blockNumber != 0 {
            os.write_int64(3, self.blockNumber)?;
        }
        if self.blockTimeStamp != 0 {
            os.write_int64(4, self.blockTimeStamp)?;
        }
        for v in &self.contractResult {
            os.write_bytes(5, &v)?;
        };
        if !self.contract_address.is_empty() {
            os.write_bytes(6, &self.contract_address)?;
        }
        if let Some(v) = self.receipt.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.log {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if self.result != ::protobuf::EnumOrUnknown::new(transaction_info::Code::SUCESS) {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&self.result))?;
        }
        if !self.resMessage.is_empty() {
            os.write_bytes(10, &self.resMessage)?;
        }
        if !self.assetIssueID.is_empty() {
            os.write_string(14, &self.assetIssueID)?;
        }
        if self.withdraw_amount != 0 {
            os.write_int64(15, self.withdraw_amount)?;
        }
        if self.unfreeze_amount != 0 {
            os.write_int64(16, self.unfreeze_amount)?;
        }
        for v in &self.internal_transactions {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        if self.exchange_received_amount != 0 {
            os.write_int64(18, self.exchange_received_amount)?;
        }
        if self.exchange_inject_another_amount != 0 {
            os.write_int64(19, self.exchange_inject_another_amount)?;
        }
        if self.exchange_withdraw_another_amount != 0 {
            os.write_int64(20, self.exchange_withdraw_another_amount)?;
        }
        if self.exchange_id != 0 {
            os.write_int64(21, self.exchange_id)?;
        }
        if self.shielded_transaction_fee != 0 {
            os.write_int64(22, self.shielded_transaction_fee)?;
        }
        if !self.orderId.is_empty() {
            os.write_bytes(25, &self.orderId)?;
        }
        for v in &self.orderDetails {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        };
        if self.packingFee != 0 {
            os.write_int64(27, self.packingFee)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransactionInfo {
        TransactionInfo::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.fee = 0;
        self.blockNumber = 0;
        self.blockTimeStamp = 0;
        self.contractResult.clear();
        self.contract_address.clear();
        self.receipt.clear();
        self.log.clear();
        self.result = ::protobuf::EnumOrUnknown::new(transaction_info::Code::SUCESS);
        self.resMessage.clear();
        self.assetIssueID.clear();
        self.withdraw_amount = 0;
        self.unfreeze_amount = 0;
        self.internal_transactions.clear();
        self.exchange_received_amount = 0;
        self.exchange_inject_another_amount = 0;
        self.exchange_withdraw_another_amount = 0;
        self.exchange_id = 0;
        self.shielded_transaction_fee = 0;
        self.orderId.clear();
        self.orderDetails.clear();
        self.packingFee = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransactionInfo {
        static instance: TransactionInfo = TransactionInfo {
            id: ::std::vec::Vec::new(),
            fee: 0,
            blockNumber: 0,
            blockTimeStamp: 0,
            contractResult: ::std::vec::Vec::new(),
            contract_address: ::std::vec::Vec::new(),
            receipt: ::protobuf::MessageField::none(),
            log: ::std::vec::Vec::new(),
            result: ::protobuf::EnumOrUnknown::from_i32(0),
            resMessage: ::std::vec::Vec::new(),
            assetIssueID: ::std::string::String::new(),
            withdraw_amount: 0,
            unfreeze_amount: 0,
            internal_transactions: ::std::vec::Vec::new(),
            exchange_received_amount: 0,
            exchange_inject_another_amount: 0,
            exchange_withdraw_another_amount: 0,
            exchange_id: 0,
            shielded_transaction_fee: 0,
            orderId: ::std::vec::Vec::new(),
            orderDetails: ::std::vec::Vec::new(),
            packingFee: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransactionInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransactionInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransactionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TransactionInfo`
pub mod transaction_info {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:protocol.TransactionInfo.Log)
    pub struct Log {
        // message fields
        // @@protoc_insertion_point(field:protocol.TransactionInfo.Log.address)
        pub address: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:protocol.TransactionInfo.Log.topics)
        pub topics: ::std::vec::Vec<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:protocol.TransactionInfo.Log.data)
        pub data: ::std::vec::Vec<u8>,
        // special fields
        // @@protoc_insertion_point(special_field:protocol.TransactionInfo.Log.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Log {
        fn default() -> &'a Log {
            <Log as ::protobuf::Message>::default_instance()
        }
    }

    impl Log {
        pub fn new() -> Log {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "address",
                |m: &Log| { &m.address },
                |m: &mut Log| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "topics",
                |m: &Log| { &m.topics },
                |m: &mut Log| { &mut m.topics },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data",
                |m: &Log| { &m.data },
                |m: &mut Log| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Log>(
                "TransactionInfo.Log",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Log {
        const NAME: &'static str = "Log";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.address = is.read_bytes()?;
                    },
                    18 => {
                        self.topics.push(is.read_bytes()?);
                    },
                    26 => {
                        self.data = is.read_bytes()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.address.is_empty() {
                my_size += ::protobuf::rt::bytes_size(1, &self.address);
            }
            for value in &self.topics {
                my_size += ::protobuf::rt::bytes_size(2, &value);
            };
            if !self.data.is_empty() {
                my_size += ::protobuf::rt::bytes_size(3, &self.data);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.address.is_empty() {
                os.write_bytes(1, &self.address)?;
            }
            for v in &self.topics {
                os.write_bytes(2, &v)?;
            };
            if !self.data.is_empty() {
                os.write_bytes(3, &self.data)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Log {
            Log::new()
        }

        fn clear(&mut self) {
            self.address.clear();
            self.topics.clear();
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Log {
            static instance: Log = Log {
                address: ::std::vec::Vec::new(),
                topics: ::std::vec::Vec::new(),
                data: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Log {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TransactionInfo.Log").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Log {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Log {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:protocol.TransactionInfo.code)
    pub enum Code {
        // @@protoc_insertion_point(enum_value:protocol.TransactionInfo.code.SUCESS)
        SUCESS = 0,
        // @@protoc_insertion_point(enum_value:protocol.TransactionInfo.code.FAILED)
        FAILED = 1,
    }

    impl ::protobuf::Enum for Code {
        const NAME: &'static str = "code";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Code> {
            match value {
                0 => ::std::option::Option::Some(Code::SUCESS),
                1 => ::std::option::Option::Some(Code::FAILED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Code] = &[
            Code::SUCESS,
            Code::FAILED,
        ];
    }

    impl ::protobuf::EnumFull for Code {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("TransactionInfo.code").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Code {
        fn default() -> Self {
            Code::SUCESS
        }
    }

    impl Code {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Code>("TransactionInfo.code")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.TransactionRet)
pub struct TransactionRet {
    // message fields
    // @@protoc_insertion_point(field:protocol.TransactionRet.blockNumber)
    pub blockNumber: i64,
    // @@protoc_insertion_point(field:protocol.TransactionRet.blockTimeStamp)
    pub blockTimeStamp: i64,
    // @@protoc_insertion_point(field:protocol.TransactionRet.transactioninfo)
    pub transactioninfo: ::std::vec::Vec<TransactionInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.TransactionRet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransactionRet {
    fn default() -> &'a TransactionRet {
        <TransactionRet as ::protobuf::Message>::default_instance()
    }
}

impl TransactionRet {
    pub fn new() -> TransactionRet {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "blockNumber",
            |m: &TransactionRet| { &m.blockNumber },
            |m: &mut TransactionRet| { &mut m.blockNumber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "blockTimeStamp",
            |m: &TransactionRet| { &m.blockTimeStamp },
            |m: &mut TransactionRet| { &mut m.blockTimeStamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "transactioninfo",
            |m: &TransactionRet| { &m.transactioninfo },
            |m: &mut TransactionRet| { &mut m.transactioninfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransactionRet>(
            "TransactionRet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransactionRet {
    const NAME: &'static str = "TransactionRet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.blockNumber = is.read_int64()?;
                },
                16 => {
                    self.blockTimeStamp = is.read_int64()?;
                },
                26 => {
                    self.transactioninfo.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.blockNumber != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.blockNumber);
        }
        if self.blockTimeStamp != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.blockTimeStamp);
        }
        for value in &self.transactioninfo {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.blockNumber != 0 {
            os.write_int64(1, self.blockNumber)?;
        }
        if self.blockTimeStamp != 0 {
            os.write_int64(2, self.blockTimeStamp)?;
        }
        for v in &self.transactioninfo {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransactionRet {
        TransactionRet::new()
    }

    fn clear(&mut self) {
        self.blockNumber = 0;
        self.blockTimeStamp = 0;
        self.transactioninfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransactionRet {
        static instance: TransactionRet = TransactionRet {
            blockNumber: 0,
            blockTimeStamp: 0,
            transactioninfo: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransactionRet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransactionRet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransactionRet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionRet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.Transactions)
pub struct Transactions {
    // message fields
    // @@protoc_insertion_point(field:protocol.Transactions.transactions)
    pub transactions: ::std::vec::Vec<Transaction>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.Transactions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Transactions {
    fn default() -> &'a Transactions {
        <Transactions as ::protobuf::Message>::default_instance()
    }
}

impl Transactions {
    pub fn new() -> Transactions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "transactions",
            |m: &Transactions| { &m.transactions },
            |m: &mut Transactions| { &mut m.transactions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Transactions>(
            "Transactions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Transactions {
    const NAME: &'static str = "Transactions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.transactions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.transactions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Transactions {
        Transactions::new()
    }

    fn clear(&mut self) {
        self.transactions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Transactions {
        static instance: Transactions = Transactions {
            transactions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Transactions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Transactions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Transactions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transactions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.TransactionSign)
pub struct TransactionSign {
    // message fields
    // @@protoc_insertion_point(field:protocol.TransactionSign.transaction)
    pub transaction: ::protobuf::MessageField<Transaction>,
    // @@protoc_insertion_point(field:protocol.TransactionSign.privateKey)
    pub privateKey: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.TransactionSign.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransactionSign {
    fn default() -> &'a TransactionSign {
        <TransactionSign as ::protobuf::Message>::default_instance()
    }
}

impl TransactionSign {
    pub fn new() -> TransactionSign {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Transaction>(
            "transaction",
            |m: &TransactionSign| { &m.transaction },
            |m: &mut TransactionSign| { &mut m.transaction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "privateKey",
            |m: &TransactionSign| { &m.privateKey },
            |m: &mut TransactionSign| { &mut m.privateKey },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransactionSign>(
            "TransactionSign",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransactionSign {
    const NAME: &'static str = "TransactionSign";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transaction)?;
                },
                18 => {
                    self.privateKey = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.transaction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.privateKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.privateKey);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.transaction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.privateKey.is_empty() {
            os.write_bytes(2, &self.privateKey)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransactionSign {
        TransactionSign::new()
    }

    fn clear(&mut self) {
        self.transaction.clear();
        self.privateKey.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransactionSign {
        static instance: TransactionSign = TransactionSign {
            transaction: ::protobuf::MessageField::none(),
            privateKey: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransactionSign {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransactionSign").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransactionSign {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionSign {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.BlockHeader)
pub struct BlockHeader {
    // message fields
    // @@protoc_insertion_point(field:protocol.BlockHeader.raw_data)
    pub raw_data: ::protobuf::MessageField<block_header::Raw>,
    // @@protoc_insertion_point(field:protocol.BlockHeader.witness_signature)
    pub witness_signature: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.BlockHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockHeader {
    fn default() -> &'a BlockHeader {
        <BlockHeader as ::protobuf::Message>::default_instance()
    }
}

impl BlockHeader {
    pub fn new() -> BlockHeader {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, block_header::Raw>(
            "raw_data",
            |m: &BlockHeader| { &m.raw_data },
            |m: &mut BlockHeader| { &mut m.raw_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "witness_signature",
            |m: &BlockHeader| { &m.witness_signature },
            |m: &mut BlockHeader| { &mut m.witness_signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockHeader>(
            "BlockHeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockHeader {
    const NAME: &'static str = "BlockHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.raw_data)?;
                },
                18 => {
                    self.witness_signature = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.raw_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.witness_signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.witness_signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.raw_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.witness_signature.is_empty() {
            os.write_bytes(2, &self.witness_signature)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockHeader {
        BlockHeader::new()
    }

    fn clear(&mut self) {
        self.raw_data.clear();
        self.witness_signature.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockHeader {
        static instance: BlockHeader = BlockHeader {
            raw_data: ::protobuf::MessageField::none(),
            witness_signature: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockHeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockHeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BlockHeader`
pub mod block_header {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:protocol.BlockHeader.raw)
    pub struct Raw {
        // message fields
        // @@protoc_insertion_point(field:protocol.BlockHeader.raw.timestamp)
        pub timestamp: i64,
        // @@protoc_insertion_point(field:protocol.BlockHeader.raw.txTrieRoot)
        pub txTrieRoot: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:protocol.BlockHeader.raw.parentHash)
        pub parentHash: ::std::vec::Vec<u8>,
        /// bytes nonce = 5;
        /// bytes difficulty = 6;
        // @@protoc_insertion_point(field:protocol.BlockHeader.raw.number)
        pub number: i64,
        // @@protoc_insertion_point(field:protocol.BlockHeader.raw.witness_id)
        pub witness_id: i64,
        // @@protoc_insertion_point(field:protocol.BlockHeader.raw.witness_address)
        pub witness_address: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:protocol.BlockHeader.raw.version)
        pub version: i32,
        // @@protoc_insertion_point(field:protocol.BlockHeader.raw.accountStateRoot)
        pub accountStateRoot: ::std::vec::Vec<u8>,
        // special fields
        // @@protoc_insertion_point(special_field:protocol.BlockHeader.raw.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Raw {
        fn default() -> &'a Raw {
            <Raw as ::protobuf::Message>::default_instance()
        }
    }

    impl Raw {
        pub fn new() -> Raw {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "timestamp",
                |m: &Raw| { &m.timestamp },
                |m: &mut Raw| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "txTrieRoot",
                |m: &Raw| { &m.txTrieRoot },
                |m: &mut Raw| { &mut m.txTrieRoot },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "parentHash",
                |m: &Raw| { &m.parentHash },
                |m: &mut Raw| { &mut m.parentHash },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "number",
                |m: &Raw| { &m.number },
                |m: &mut Raw| { &mut m.number },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "witness_id",
                |m: &Raw| { &m.witness_id },
                |m: &mut Raw| { &mut m.witness_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "witness_address",
                |m: &Raw| { &m.witness_address },
                |m: &mut Raw| { &mut m.witness_address },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "version",
                |m: &Raw| { &m.version },
                |m: &mut Raw| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "accountStateRoot",
                |m: &Raw| { &m.accountStateRoot },
                |m: &mut Raw| { &mut m.accountStateRoot },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Raw>(
                "BlockHeader.raw",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Raw {
        const NAME: &'static str = "raw";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.timestamp = is.read_int64()?;
                    },
                    18 => {
                        self.txTrieRoot = is.read_bytes()?;
                    },
                    26 => {
                        self.parentHash = is.read_bytes()?;
                    },
                    56 => {
                        self.number = is.read_int64()?;
                    },
                    64 => {
                        self.witness_id = is.read_int64()?;
                    },
                    74 => {
                        self.witness_address = is.read_bytes()?;
                    },
                    80 => {
                        self.version = is.read_int32()?;
                    },
                    90 => {
                        self.accountStateRoot = is.read_bytes()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.timestamp != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.timestamp);
            }
            if !self.txTrieRoot.is_empty() {
                my_size += ::protobuf::rt::bytes_size(2, &self.txTrieRoot);
            }
            if !self.parentHash.is_empty() {
                my_size += ::protobuf::rt::bytes_size(3, &self.parentHash);
            }
            if self.number != 0 {
                my_size += ::protobuf::rt::int64_size(7, self.number);
            }
            if self.witness_id != 0 {
                my_size += ::protobuf::rt::int64_size(8, self.witness_id);
            }
            if !self.witness_address.is_empty() {
                my_size += ::protobuf::rt::bytes_size(9, &self.witness_address);
            }
            if self.version != 0 {
                my_size += ::protobuf::rt::int32_size(10, self.version);
            }
            if !self.accountStateRoot.is_empty() {
                my_size += ::protobuf::rt::bytes_size(11, &self.accountStateRoot);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.timestamp != 0 {
                os.write_int64(1, self.timestamp)?;
            }
            if !self.txTrieRoot.is_empty() {
                os.write_bytes(2, &self.txTrieRoot)?;
            }
            if !self.parentHash.is_empty() {
                os.write_bytes(3, &self.parentHash)?;
            }
            if self.number != 0 {
                os.write_int64(7, self.number)?;
            }
            if self.witness_id != 0 {
                os.write_int64(8, self.witness_id)?;
            }
            if !self.witness_address.is_empty() {
                os.write_bytes(9, &self.witness_address)?;
            }
            if self.version != 0 {
                os.write_int32(10, self.version)?;
            }
            if !self.accountStateRoot.is_empty() {
                os.write_bytes(11, &self.accountStateRoot)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Raw {
            Raw::new()
        }

        fn clear(&mut self) {
            self.timestamp = 0;
            self.txTrieRoot.clear();
            self.parentHash.clear();
            self.number = 0;
            self.witness_id = 0;
            self.witness_address.clear();
            self.version = 0;
            self.accountStateRoot.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Raw {
            static instance: Raw = Raw {
                timestamp: 0,
                txTrieRoot: ::std::vec::Vec::new(),
                parentHash: ::std::vec::Vec::new(),
                number: 0,
                witness_id: 0,
                witness_address: ::std::vec::Vec::new(),
                version: 0,
                accountStateRoot: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Raw {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BlockHeader.raw").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Raw {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Raw {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

///  block
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.Block)
pub struct Block {
    // message fields
    // @@protoc_insertion_point(field:protocol.Block.transactions)
    pub transactions: ::std::vec::Vec<Transaction>,
    // @@protoc_insertion_point(field:protocol.Block.block_header)
    pub block_header: ::protobuf::MessageField<BlockHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.Block.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Block {
    fn default() -> &'a Block {
        <Block as ::protobuf::Message>::default_instance()
    }
}

impl Block {
    pub fn new() -> Block {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "transactions",
            |m: &Block| { &m.transactions },
            |m: &mut Block| { &mut m.transactions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BlockHeader>(
            "block_header",
            |m: &Block| { &m.block_header },
            |m: &mut Block| { &mut m.block_header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Block>(
            "Block",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Block {
    const NAME: &'static str = "Block";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.transactions.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block_header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.block_header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.transactions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.block_header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Block {
        Block::new()
    }

    fn clear(&mut self) {
        self.transactions.clear();
        self.block_header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Block {
        static instance: Block = Block {
            transactions: ::std::vec::Vec::new(),
            block_header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Block {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Block").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Block {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Block {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.ChainInventory)
pub struct ChainInventory {
    // message fields
    // @@protoc_insertion_point(field:protocol.ChainInventory.ids)
    pub ids: ::std::vec::Vec<chain_inventory::BlockId>,
    // @@protoc_insertion_point(field:protocol.ChainInventory.remain_num)
    pub remain_num: i64,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.ChainInventory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChainInventory {
    fn default() -> &'a ChainInventory {
        <ChainInventory as ::protobuf::Message>::default_instance()
    }
}

impl ChainInventory {
    pub fn new() -> ChainInventory {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &ChainInventory| { &m.ids },
            |m: &mut ChainInventory| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "remain_num",
            |m: &ChainInventory| { &m.remain_num },
            |m: &mut ChainInventory| { &mut m.remain_num },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChainInventory>(
            "ChainInventory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChainInventory {
    const NAME: &'static str = "ChainInventory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ids.push(is.read_message()?);
                },
                16 => {
                    self.remain_num = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.remain_num != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.remain_num);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ids {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.remain_num != 0 {
            os.write_int64(2, self.remain_num)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChainInventory {
        ChainInventory::new()
    }

    fn clear(&mut self) {
        self.ids.clear();
        self.remain_num = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChainInventory {
        static instance: ChainInventory = ChainInventory {
            ids: ::std::vec::Vec::new(),
            remain_num: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChainInventory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChainInventory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChainInventory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChainInventory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ChainInventory`
pub mod chain_inventory {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:protocol.ChainInventory.BlockId)
    pub struct BlockId {
        // message fields
        // @@protoc_insertion_point(field:protocol.ChainInventory.BlockId.hash)
        pub hash: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:protocol.ChainInventory.BlockId.number)
        pub number: i64,
        // special fields
        // @@protoc_insertion_point(special_field:protocol.ChainInventory.BlockId.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BlockId {
        fn default() -> &'a BlockId {
            <BlockId as ::protobuf::Message>::default_instance()
        }
    }

    impl BlockId {
        pub fn new() -> BlockId {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "hash",
                |m: &BlockId| { &m.hash },
                |m: &mut BlockId| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "number",
                |m: &BlockId| { &m.number },
                |m: &mut BlockId| { &mut m.number },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockId>(
                "ChainInventory.BlockId",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BlockId {
        const NAME: &'static str = "BlockId";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.hash = is.read_bytes()?;
                    },
                    16 => {
                        self.number = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.hash.is_empty() {
                my_size += ::protobuf::rt::bytes_size(1, &self.hash);
            }
            if self.number != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.number);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.hash.is_empty() {
                os.write_bytes(1, &self.hash)?;
            }
            if self.number != 0 {
                os.write_int64(2, self.number)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BlockId {
            BlockId::new()
        }

        fn clear(&mut self) {
            self.hash.clear();
            self.number = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BlockId {
            static instance: BlockId = BlockId {
                hash: ::std::vec::Vec::new(),
                number: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BlockId {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ChainInventory.BlockId").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BlockId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BlockId {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

///  Inventory
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.BlockInventory)
pub struct BlockInventory {
    // message fields
    // @@protoc_insertion_point(field:protocol.BlockInventory.ids)
    pub ids: ::std::vec::Vec<block_inventory::BlockId>,
    // @@protoc_insertion_point(field:protocol.BlockInventory.type)
    pub type_: ::protobuf::EnumOrUnknown<block_inventory::Type>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.BlockInventory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockInventory {
    fn default() -> &'a BlockInventory {
        <BlockInventory as ::protobuf::Message>::default_instance()
    }
}

impl BlockInventory {
    pub fn new() -> BlockInventory {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &BlockInventory| { &m.ids },
            |m: &mut BlockInventory| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &BlockInventory| { &m.type_ },
            |m: &mut BlockInventory| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockInventory>(
            "BlockInventory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockInventory {
    const NAME: &'static str = "BlockInventory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ids.push(is.read_message()?);
                },
                16 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.type_ != ::protobuf::EnumOrUnknown::new(block_inventory::Type::SYNC) {
            my_size += ::protobuf::rt::int32_size(2, self.type_.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ids {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.type_ != ::protobuf::EnumOrUnknown::new(block_inventory::Type::SYNC) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockInventory {
        BlockInventory::new()
    }

    fn clear(&mut self) {
        self.ids.clear();
        self.type_ = ::protobuf::EnumOrUnknown::new(block_inventory::Type::SYNC);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockInventory {
        static instance: BlockInventory = BlockInventory {
            ids: ::std::vec::Vec::new(),
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockInventory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockInventory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockInventory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockInventory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BlockInventory`
pub mod block_inventory {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:protocol.BlockInventory.BlockId)
    pub struct BlockId {
        // message fields
        // @@protoc_insertion_point(field:protocol.BlockInventory.BlockId.hash)
        pub hash: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:protocol.BlockInventory.BlockId.number)
        pub number: i64,
        // special fields
        // @@protoc_insertion_point(special_field:protocol.BlockInventory.BlockId.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BlockId {
        fn default() -> &'a BlockId {
            <BlockId as ::protobuf::Message>::default_instance()
        }
    }

    impl BlockId {
        pub fn new() -> BlockId {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "hash",
                |m: &BlockId| { &m.hash },
                |m: &mut BlockId| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "number",
                |m: &BlockId| { &m.number },
                |m: &mut BlockId| { &mut m.number },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockId>(
                "BlockInventory.BlockId",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BlockId {
        const NAME: &'static str = "BlockId";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.hash = is.read_bytes()?;
                    },
                    16 => {
                        self.number = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.hash.is_empty() {
                my_size += ::protobuf::rt::bytes_size(1, &self.hash);
            }
            if self.number != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.number);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.hash.is_empty() {
                os.write_bytes(1, &self.hash)?;
            }
            if self.number != 0 {
                os.write_int64(2, self.number)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BlockId {
            BlockId::new()
        }

        fn clear(&mut self) {
            self.hash.clear();
            self.number = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BlockId {
            static instance: BlockId = BlockId {
                hash: ::std::vec::Vec::new(),
                number: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BlockId {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BlockInventory.BlockId").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BlockId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BlockId {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:protocol.BlockInventory.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:protocol.BlockInventory.Type.SYNC)
        SYNC = 0,
        // @@protoc_insertion_point(enum_value:protocol.BlockInventory.Type.ADVTISE)
        ADVTISE = 1,
        // @@protoc_insertion_point(enum_value:protocol.BlockInventory.Type.FETCH)
        FETCH = 2,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::SYNC),
                1 => ::std::option::Option::Some(Type::ADVTISE),
                2 => ::std::option::Option::Some(Type::FETCH),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::SYNC,
            Type::ADVTISE,
            Type::FETCH,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("BlockInventory.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::SYNC
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("BlockInventory.Type")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.Inventory)
pub struct Inventory {
    // message fields
    // @@protoc_insertion_point(field:protocol.Inventory.type)
    pub type_: ::protobuf::EnumOrUnknown<inventory::InventoryType>,
    // @@protoc_insertion_point(field:protocol.Inventory.ids)
    pub ids: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.Inventory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Inventory {
    fn default() -> &'a Inventory {
        <Inventory as ::protobuf::Message>::default_instance()
    }
}

impl Inventory {
    pub fn new() -> Inventory {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Inventory| { &m.type_ },
            |m: &mut Inventory| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &Inventory| { &m.ids },
            |m: &mut Inventory| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Inventory>(
            "Inventory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Inventory {
    const NAME: &'static str = "Inventory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.ids.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(inventory::InventoryType::TRX) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(inventory::InventoryType::TRX) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        for v in &self.ids {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Inventory {
        Inventory::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(inventory::InventoryType::TRX);
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Inventory {
        static instance: Inventory = Inventory {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Inventory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Inventory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Inventory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Inventory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Inventory`
pub mod inventory {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:protocol.Inventory.InventoryType)
    pub enum InventoryType {
        // @@protoc_insertion_point(enum_value:protocol.Inventory.InventoryType.TRX)
        TRX = 0,
        // @@protoc_insertion_point(enum_value:protocol.Inventory.InventoryType.BLOCK)
        BLOCK = 1,
    }

    impl ::protobuf::Enum for InventoryType {
        const NAME: &'static str = "InventoryType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<InventoryType> {
            match value {
                0 => ::std::option::Option::Some(InventoryType::TRX),
                1 => ::std::option::Option::Some(InventoryType::BLOCK),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [InventoryType] = &[
            InventoryType::TRX,
            InventoryType::BLOCK,
        ];
    }

    impl ::protobuf::EnumFull for InventoryType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Inventory.InventoryType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for InventoryType {
        fn default() -> Self {
            InventoryType::TRX
        }
    }

    impl InventoryType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<InventoryType>("Inventory.InventoryType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.Items)
pub struct Items {
    // message fields
    // @@protoc_insertion_point(field:protocol.Items.type)
    pub type_: ::protobuf::EnumOrUnknown<items::ItemType>,
    // @@protoc_insertion_point(field:protocol.Items.blocks)
    pub blocks: ::std::vec::Vec<Block>,
    // @@protoc_insertion_point(field:protocol.Items.block_headers)
    pub block_headers: ::std::vec::Vec<BlockHeader>,
    // @@protoc_insertion_point(field:protocol.Items.transactions)
    pub transactions: ::std::vec::Vec<Transaction>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.Items.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Items {
    fn default() -> &'a Items {
        <Items as ::protobuf::Message>::default_instance()
    }
}

impl Items {
    pub fn new() -> Items {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Items| { &m.type_ },
            |m: &mut Items| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "blocks",
            |m: &Items| { &m.blocks },
            |m: &mut Items| { &mut m.blocks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "block_headers",
            |m: &Items| { &m.block_headers },
            |m: &mut Items| { &mut m.block_headers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "transactions",
            |m: &Items| { &m.transactions },
            |m: &mut Items| { &mut m.transactions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Items>(
            "Items",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Items {
    const NAME: &'static str = "Items";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.blocks.push(is.read_message()?);
                },
                26 => {
                    self.block_headers.push(is.read_message()?);
                },
                34 => {
                    self.transactions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(items::ItemType::ERR) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.block_headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(items::ItemType::ERR) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        for v in &self.blocks {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.block_headers {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.transactions {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Items {
        Items::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(items::ItemType::ERR);
        self.blocks.clear();
        self.block_headers.clear();
        self.transactions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Items {
        static instance: Items = Items {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            blocks: ::std::vec::Vec::new(),
            block_headers: ::std::vec::Vec::new(),
            transactions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Items {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Items").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Items {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Items {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Items`
pub mod items {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:protocol.Items.ItemType)
    pub enum ItemType {
        // @@protoc_insertion_point(enum_value:protocol.Items.ItemType.ERR)
        ERR = 0,
        // @@protoc_insertion_point(enum_value:protocol.Items.ItemType.TRX)
        TRX = 1,
        // @@protoc_insertion_point(enum_value:protocol.Items.ItemType.BLOCK)
        BLOCK = 2,
        // @@protoc_insertion_point(enum_value:protocol.Items.ItemType.BLOCKHEADER)
        BLOCKHEADER = 3,
    }

    impl ::protobuf::Enum for ItemType {
        const NAME: &'static str = "ItemType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ItemType> {
            match value {
                0 => ::std::option::Option::Some(ItemType::ERR),
                1 => ::std::option::Option::Some(ItemType::TRX),
                2 => ::std::option::Option::Some(ItemType::BLOCK),
                3 => ::std::option::Option::Some(ItemType::BLOCKHEADER),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ItemType] = &[
            ItemType::ERR,
            ItemType::TRX,
            ItemType::BLOCK,
            ItemType::BLOCKHEADER,
        ];
    }

    impl ::protobuf::EnumFull for ItemType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Items.ItemType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ItemType {
        fn default() -> Self {
            ItemType::ERR
        }
    }

    impl ItemType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ItemType>("Items.ItemType")
        }
    }
}

///  DynamicProperties
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.DynamicProperties)
pub struct DynamicProperties {
    // message fields
    // @@protoc_insertion_point(field:protocol.DynamicProperties.last_solidity_block_num)
    pub last_solidity_block_num: i64,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.DynamicProperties.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DynamicProperties {
    fn default() -> &'a DynamicProperties {
        <DynamicProperties as ::protobuf::Message>::default_instance()
    }
}

impl DynamicProperties {
    pub fn new() -> DynamicProperties {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_solidity_block_num",
            |m: &DynamicProperties| { &m.last_solidity_block_num },
            |m: &mut DynamicProperties| { &mut m.last_solidity_block_num },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DynamicProperties>(
            "DynamicProperties",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DynamicProperties {
    const NAME: &'static str = "DynamicProperties";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.last_solidity_block_num = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.last_solidity_block_num != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.last_solidity_block_num);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.last_solidity_block_num != 0 {
            os.write_int64(1, self.last_solidity_block_num)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DynamicProperties {
        DynamicProperties::new()
    }

    fn clear(&mut self) {
        self.last_solidity_block_num = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DynamicProperties {
        static instance: DynamicProperties = DynamicProperties {
            last_solidity_block_num: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DynamicProperties {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DynamicProperties").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DynamicProperties {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DynamicProperties {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.DisconnectMessage)
pub struct DisconnectMessage {
    // message fields
    // @@protoc_insertion_point(field:protocol.DisconnectMessage.reason)
    pub reason: ::protobuf::EnumOrUnknown<ReasonCode>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.DisconnectMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DisconnectMessage {
    fn default() -> &'a DisconnectMessage {
        <DisconnectMessage as ::protobuf::Message>::default_instance()
    }
}

impl DisconnectMessage {
    pub fn new() -> DisconnectMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reason",
            |m: &DisconnectMessage| { &m.reason },
            |m: &mut DisconnectMessage| { &mut m.reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DisconnectMessage>(
            "DisconnectMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DisconnectMessage {
    const NAME: &'static str = "DisconnectMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reason = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.reason != ::protobuf::EnumOrUnknown::new(ReasonCode::REQUESTED) {
            my_size += ::protobuf::rt::int32_size(1, self.reason.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.reason != ::protobuf::EnumOrUnknown::new(ReasonCode::REQUESTED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.reason))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DisconnectMessage {
        DisconnectMessage::new()
    }

    fn clear(&mut self) {
        self.reason = ::protobuf::EnumOrUnknown::new(ReasonCode::REQUESTED);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DisconnectMessage {
        static instance: DisconnectMessage = DisconnectMessage {
            reason: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DisconnectMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DisconnectMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DisconnectMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisconnectMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.HelloMessage)
pub struct HelloMessage {
    // message fields
    // @@protoc_insertion_point(field:protocol.HelloMessage.from)
    pub from: ::protobuf::MessageField<super::Discover::Endpoint>,
    // @@protoc_insertion_point(field:protocol.HelloMessage.version)
    pub version: i32,
    // @@protoc_insertion_point(field:protocol.HelloMessage.timestamp)
    pub timestamp: i64,
    // @@protoc_insertion_point(field:protocol.HelloMessage.genesisBlockId)
    pub genesisBlockId: ::protobuf::MessageField<hello_message::BlockId>,
    // @@protoc_insertion_point(field:protocol.HelloMessage.solidBlockId)
    pub solidBlockId: ::protobuf::MessageField<hello_message::BlockId>,
    // @@protoc_insertion_point(field:protocol.HelloMessage.headBlockId)
    pub headBlockId: ::protobuf::MessageField<hello_message::BlockId>,
    // @@protoc_insertion_point(field:protocol.HelloMessage.address)
    pub address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.HelloMessage.signature)
    pub signature: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.HelloMessage.nodeType)
    pub nodeType: i32,
    // @@protoc_insertion_point(field:protocol.HelloMessage.lowestBlockNum)
    pub lowestBlockNum: i64,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.HelloMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HelloMessage {
    fn default() -> &'a HelloMessage {
        <HelloMessage as ::protobuf::Message>::default_instance()
    }
}

impl HelloMessage {
    pub fn new() -> HelloMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Discover::Endpoint>(
            "from",
            |m: &HelloMessage| { &m.from },
            |m: &mut HelloMessage| { &mut m.from },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &HelloMessage| { &m.version },
            |m: &mut HelloMessage| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp",
            |m: &HelloMessage| { &m.timestamp },
            |m: &mut HelloMessage| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, hello_message::BlockId>(
            "genesisBlockId",
            |m: &HelloMessage| { &m.genesisBlockId },
            |m: &mut HelloMessage| { &mut m.genesisBlockId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, hello_message::BlockId>(
            "solidBlockId",
            |m: &HelloMessage| { &m.solidBlockId },
            |m: &mut HelloMessage| { &mut m.solidBlockId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, hello_message::BlockId>(
            "headBlockId",
            |m: &HelloMessage| { &m.headBlockId },
            |m: &mut HelloMessage| { &mut m.headBlockId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &HelloMessage| { &m.address },
            |m: &mut HelloMessage| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signature",
            |m: &HelloMessage| { &m.signature },
            |m: &mut HelloMessage| { &mut m.signature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "nodeType",
            |m: &HelloMessage| { &m.nodeType },
            |m: &mut HelloMessage| { &mut m.nodeType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lowestBlockNum",
            |m: &HelloMessage| { &m.lowestBlockNum },
            |m: &mut HelloMessage| { &mut m.lowestBlockNum },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HelloMessage>(
            "HelloMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HelloMessage {
    const NAME: &'static str = "HelloMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.from)?;
                },
                16 => {
                    self.version = is.read_int32()?;
                },
                24 => {
                    self.timestamp = is.read_int64()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.genesisBlockId)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.solidBlockId)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.headBlockId)?;
                },
                58 => {
                    self.address = is.read_bytes()?;
                },
                66 => {
                    self.signature = is.read_bytes()?;
                },
                72 => {
                    self.nodeType = is.read_int32()?;
                },
                80 => {
                    self.lowestBlockNum = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.from.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.version);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.timestamp);
        }
        if let Some(v) = self.genesisBlockId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.solidBlockId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.headBlockId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.address);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.signature);
        }
        if self.nodeType != 0 {
            my_size += ::protobuf::rt::int32_size(9, self.nodeType);
        }
        if self.lowestBlockNum != 0 {
            my_size += ::protobuf::rt::int64_size(10, self.lowestBlockNum);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.from.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.version != 0 {
            os.write_int32(2, self.version)?;
        }
        if self.timestamp != 0 {
            os.write_int64(3, self.timestamp)?;
        }
        if let Some(v) = self.genesisBlockId.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.solidBlockId.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.headBlockId.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if !self.address.is_empty() {
            os.write_bytes(7, &self.address)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(8, &self.signature)?;
        }
        if self.nodeType != 0 {
            os.write_int32(9, self.nodeType)?;
        }
        if self.lowestBlockNum != 0 {
            os.write_int64(10, self.lowestBlockNum)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HelloMessage {
        HelloMessage::new()
    }

    fn clear(&mut self) {
        self.from.clear();
        self.version = 0;
        self.timestamp = 0;
        self.genesisBlockId.clear();
        self.solidBlockId.clear();
        self.headBlockId.clear();
        self.address.clear();
        self.signature.clear();
        self.nodeType = 0;
        self.lowestBlockNum = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HelloMessage {
        static instance: HelloMessage = HelloMessage {
            from: ::protobuf::MessageField::none(),
            version: 0,
            timestamp: 0,
            genesisBlockId: ::protobuf::MessageField::none(),
            solidBlockId: ::protobuf::MessageField::none(),
            headBlockId: ::protobuf::MessageField::none(),
            address: ::std::vec::Vec::new(),
            signature: ::std::vec::Vec::new(),
            nodeType: 0,
            lowestBlockNum: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HelloMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HelloMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HelloMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HelloMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `HelloMessage`
pub mod hello_message {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:protocol.HelloMessage.BlockId)
    pub struct BlockId {
        // message fields
        // @@protoc_insertion_point(field:protocol.HelloMessage.BlockId.hash)
        pub hash: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:protocol.HelloMessage.BlockId.number)
        pub number: i64,
        // special fields
        // @@protoc_insertion_point(special_field:protocol.HelloMessage.BlockId.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BlockId {
        fn default() -> &'a BlockId {
            <BlockId as ::protobuf::Message>::default_instance()
        }
    }

    impl BlockId {
        pub fn new() -> BlockId {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "hash",
                |m: &BlockId| { &m.hash },
                |m: &mut BlockId| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "number",
                |m: &BlockId| { &m.number },
                |m: &mut BlockId| { &mut m.number },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockId>(
                "HelloMessage.BlockId",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BlockId {
        const NAME: &'static str = "BlockId";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.hash = is.read_bytes()?;
                    },
                    16 => {
                        self.number = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.hash.is_empty() {
                my_size += ::protobuf::rt::bytes_size(1, &self.hash);
            }
            if self.number != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.number);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.hash.is_empty() {
                os.write_bytes(1, &self.hash)?;
            }
            if self.number != 0 {
                os.write_int64(2, self.number)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BlockId {
            BlockId::new()
        }

        fn clear(&mut self) {
            self.hash.clear();
            self.number = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BlockId {
            static instance: BlockId = BlockId {
                hash: ::std::vec::Vec::new(),
                number: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BlockId {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("HelloMessage.BlockId").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BlockId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BlockId {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.InternalTransaction)
pub struct InternalTransaction {
    // message fields
    ///  internalTransaction identity, the root InternalTransaction hash
    ///  should equals to root transaction id.
    // @@protoc_insertion_point(field:protocol.InternalTransaction.hash)
    pub hash: ::std::vec::Vec<u8>,
    ///  the one send trx (TBD: or token) via function
    // @@protoc_insertion_point(field:protocol.InternalTransaction.caller_address)
    pub caller_address: ::std::vec::Vec<u8>,
    ///  the one recieve trx (TBD: or token) via function
    // @@protoc_insertion_point(field:protocol.InternalTransaction.transferTo_address)
    pub transferTo_address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.InternalTransaction.callValueInfo)
    pub callValueInfo: ::std::vec::Vec<internal_transaction::CallValueInfo>,
    // @@protoc_insertion_point(field:protocol.InternalTransaction.note)
    pub note: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.InternalTransaction.rejected)
    pub rejected: bool,
    // @@protoc_insertion_point(field:protocol.InternalTransaction.extra)
    pub extra: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.InternalTransaction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InternalTransaction {
    fn default() -> &'a InternalTransaction {
        <InternalTransaction as ::protobuf::Message>::default_instance()
    }
}

impl InternalTransaction {
    pub fn new() -> InternalTransaction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &InternalTransaction| { &m.hash },
            |m: &mut InternalTransaction| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "caller_address",
            |m: &InternalTransaction| { &m.caller_address },
            |m: &mut InternalTransaction| { &mut m.caller_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transferTo_address",
            |m: &InternalTransaction| { &m.transferTo_address },
            |m: &mut InternalTransaction| { &mut m.transferTo_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "callValueInfo",
            |m: &InternalTransaction| { &m.callValueInfo },
            |m: &mut InternalTransaction| { &mut m.callValueInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "note",
            |m: &InternalTransaction| { &m.note },
            |m: &mut InternalTransaction| { &mut m.note },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rejected",
            |m: &InternalTransaction| { &m.rejected },
            |m: &mut InternalTransaction| { &mut m.rejected },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "extra",
            |m: &InternalTransaction| { &m.extra },
            |m: &mut InternalTransaction| { &mut m.extra },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InternalTransaction>(
            "InternalTransaction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InternalTransaction {
    const NAME: &'static str = "InternalTransaction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hash = is.read_bytes()?;
                },
                18 => {
                    self.caller_address = is.read_bytes()?;
                },
                26 => {
                    self.transferTo_address = is.read_bytes()?;
                },
                34 => {
                    self.callValueInfo.push(is.read_message()?);
                },
                42 => {
                    self.note = is.read_bytes()?;
                },
                48 => {
                    self.rejected = is.read_bool()?;
                },
                58 => {
                    self.extra = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        if !self.caller_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.caller_address);
        }
        if !self.transferTo_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.transferTo_address);
        }
        for value in &self.callValueInfo {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.note.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.note);
        }
        if self.rejected != false {
            my_size += 1 + 1;
        }
        if !self.extra.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.extra);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        if !self.caller_address.is_empty() {
            os.write_bytes(2, &self.caller_address)?;
        }
        if !self.transferTo_address.is_empty() {
            os.write_bytes(3, &self.transferTo_address)?;
        }
        for v in &self.callValueInfo {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if !self.note.is_empty() {
            os.write_bytes(5, &self.note)?;
        }
        if self.rejected != false {
            os.write_bool(6, self.rejected)?;
        }
        if !self.extra.is_empty() {
            os.write_string(7, &self.extra)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InternalTransaction {
        InternalTransaction::new()
    }

    fn clear(&mut self) {
        self.hash.clear();
        self.caller_address.clear();
        self.transferTo_address.clear();
        self.callValueInfo.clear();
        self.note.clear();
        self.rejected = false;
        self.extra.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InternalTransaction {
        static instance: InternalTransaction = InternalTransaction {
            hash: ::std::vec::Vec::new(),
            caller_address: ::std::vec::Vec::new(),
            transferTo_address: ::std::vec::Vec::new(),
            callValueInfo: ::std::vec::Vec::new(),
            note: ::std::vec::Vec::new(),
            rejected: false,
            extra: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InternalTransaction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InternalTransaction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InternalTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InternalTransaction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `InternalTransaction`
pub mod internal_transaction {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:protocol.InternalTransaction.CallValueInfo)
    pub struct CallValueInfo {
        // message fields
        ///  trx (TBD: or token) value
        // @@protoc_insertion_point(field:protocol.InternalTransaction.CallValueInfo.callValue)
        pub callValue: i64,
        ///  TBD: tokenName, trx should be empty
        // @@protoc_insertion_point(field:protocol.InternalTransaction.CallValueInfo.tokenId)
        pub tokenId: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:protocol.InternalTransaction.CallValueInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CallValueInfo {
        fn default() -> &'a CallValueInfo {
            <CallValueInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl CallValueInfo {
        pub fn new() -> CallValueInfo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "callValue",
                |m: &CallValueInfo| { &m.callValue },
                |m: &mut CallValueInfo| { &mut m.callValue },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "tokenId",
                |m: &CallValueInfo| { &m.tokenId },
                |m: &mut CallValueInfo| { &mut m.tokenId },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CallValueInfo>(
                "InternalTransaction.CallValueInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CallValueInfo {
        const NAME: &'static str = "CallValueInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.callValue = is.read_int64()?;
                    },
                    18 => {
                        self.tokenId = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.callValue != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.callValue);
            }
            if !self.tokenId.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.tokenId);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.callValue != 0 {
                os.write_int64(1, self.callValue)?;
            }
            if !self.tokenId.is_empty() {
                os.write_string(2, &self.tokenId)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CallValueInfo {
            CallValueInfo::new()
        }

        fn clear(&mut self) {
            self.callValue = 0;
            self.tokenId.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CallValueInfo {
            static instance: CallValueInfo = CallValueInfo {
                callValue: 0,
                tokenId: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CallValueInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("InternalTransaction.CallValueInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CallValueInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CallValueInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.DelegatedResourceAccountIndex)
pub struct DelegatedResourceAccountIndex {
    // message fields
    // @@protoc_insertion_point(field:protocol.DelegatedResourceAccountIndex.account)
    pub account: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.DelegatedResourceAccountIndex.fromAccounts)
    pub fromAccounts: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:protocol.DelegatedResourceAccountIndex.toAccounts)
    pub toAccounts: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.DelegatedResourceAccountIndex.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DelegatedResourceAccountIndex {
    fn default() -> &'a DelegatedResourceAccountIndex {
        <DelegatedResourceAccountIndex as ::protobuf::Message>::default_instance()
    }
}

impl DelegatedResourceAccountIndex {
    pub fn new() -> DelegatedResourceAccountIndex {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "account",
            |m: &DelegatedResourceAccountIndex| { &m.account },
            |m: &mut DelegatedResourceAccountIndex| { &mut m.account },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fromAccounts",
            |m: &DelegatedResourceAccountIndex| { &m.fromAccounts },
            |m: &mut DelegatedResourceAccountIndex| { &mut m.fromAccounts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "toAccounts",
            |m: &DelegatedResourceAccountIndex| { &m.toAccounts },
            |m: &mut DelegatedResourceAccountIndex| { &mut m.toAccounts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DelegatedResourceAccountIndex>(
            "DelegatedResourceAccountIndex",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DelegatedResourceAccountIndex {
    const NAME: &'static str = "DelegatedResourceAccountIndex";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.account = is.read_bytes()?;
                },
                18 => {
                    self.fromAccounts.push(is.read_bytes()?);
                },
                26 => {
                    self.toAccounts.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.account.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.account);
        }
        for value in &self.fromAccounts {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        for value in &self.toAccounts {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.account.is_empty() {
            os.write_bytes(1, &self.account)?;
        }
        for v in &self.fromAccounts {
            os.write_bytes(2, &v)?;
        };
        for v in &self.toAccounts {
            os.write_bytes(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DelegatedResourceAccountIndex {
        DelegatedResourceAccountIndex::new()
    }

    fn clear(&mut self) {
        self.account.clear();
        self.fromAccounts.clear();
        self.toAccounts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DelegatedResourceAccountIndex {
        static instance: DelegatedResourceAccountIndex = DelegatedResourceAccountIndex {
            account: ::std::vec::Vec::new(),
            fromAccounts: ::std::vec::Vec::new(),
            toAccounts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DelegatedResourceAccountIndex {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DelegatedResourceAccountIndex").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DelegatedResourceAccountIndex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DelegatedResourceAccountIndex {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.NodeInfo)
pub struct NodeInfo {
    // message fields
    // @@protoc_insertion_point(field:protocol.NodeInfo.beginSyncNum)
    pub beginSyncNum: i64,
    // @@protoc_insertion_point(field:protocol.NodeInfo.block)
    pub block: ::std::string::String,
    // @@protoc_insertion_point(field:protocol.NodeInfo.solidityBlock)
    pub solidityBlock: ::std::string::String,
    /// connect information
    // @@protoc_insertion_point(field:protocol.NodeInfo.currentConnectCount)
    pub currentConnectCount: i32,
    // @@protoc_insertion_point(field:protocol.NodeInfo.activeConnectCount)
    pub activeConnectCount: i32,
    // @@protoc_insertion_point(field:protocol.NodeInfo.passiveConnectCount)
    pub passiveConnectCount: i32,
    // @@protoc_insertion_point(field:protocol.NodeInfo.totalFlow)
    pub totalFlow: i64,
    // @@protoc_insertion_point(field:protocol.NodeInfo.peerInfoList)
    pub peerInfoList: ::std::vec::Vec<node_info::PeerInfo>,
    // @@protoc_insertion_point(field:protocol.NodeInfo.configNodeInfo)
    pub configNodeInfo: ::protobuf::MessageField<node_info::ConfigNodeInfo>,
    // @@protoc_insertion_point(field:protocol.NodeInfo.machineInfo)
    pub machineInfo: ::protobuf::MessageField<node_info::MachineInfo>,
    // @@protoc_insertion_point(field:protocol.NodeInfo.cheatWitnessInfoMap)
    pub cheatWitnessInfoMap: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.NodeInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeInfo {
    fn default() -> &'a NodeInfo {
        <NodeInfo as ::protobuf::Message>::default_instance()
    }
}

impl NodeInfo {
    pub fn new() -> NodeInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "beginSyncNum",
            |m: &NodeInfo| { &m.beginSyncNum },
            |m: &mut NodeInfo| { &mut m.beginSyncNum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block",
            |m: &NodeInfo| { &m.block },
            |m: &mut NodeInfo| { &mut m.block },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "solidityBlock",
            |m: &NodeInfo| { &m.solidityBlock },
            |m: &mut NodeInfo| { &mut m.solidityBlock },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "currentConnectCount",
            |m: &NodeInfo| { &m.currentConnectCount },
            |m: &mut NodeInfo| { &mut m.currentConnectCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "activeConnectCount",
            |m: &NodeInfo| { &m.activeConnectCount },
            |m: &mut NodeInfo| { &mut m.activeConnectCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "passiveConnectCount",
            |m: &NodeInfo| { &m.passiveConnectCount },
            |m: &mut NodeInfo| { &mut m.passiveConnectCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "totalFlow",
            |m: &NodeInfo| { &m.totalFlow },
            |m: &mut NodeInfo| { &mut m.totalFlow },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "peerInfoList",
            |m: &NodeInfo| { &m.peerInfoList },
            |m: &mut NodeInfo| { &mut m.peerInfoList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, node_info::ConfigNodeInfo>(
            "configNodeInfo",
            |m: &NodeInfo| { &m.configNodeInfo },
            |m: &mut NodeInfo| { &mut m.configNodeInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, node_info::MachineInfo>(
            "machineInfo",
            |m: &NodeInfo| { &m.machineInfo },
            |m: &mut NodeInfo| { &mut m.machineInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "cheatWitnessInfoMap",
            |m: &NodeInfo| { &m.cheatWitnessInfoMap },
            |m: &mut NodeInfo| { &mut m.cheatWitnessInfoMap },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeInfo>(
            "NodeInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeInfo {
    const NAME: &'static str = "NodeInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.beginSyncNum = is.read_int64()?;
                },
                18 => {
                    self.block = is.read_string()?;
                },
                26 => {
                    self.solidityBlock = is.read_string()?;
                },
                32 => {
                    self.currentConnectCount = is.read_int32()?;
                },
                40 => {
                    self.activeConnectCount = is.read_int32()?;
                },
                48 => {
                    self.passiveConnectCount = is.read_int32()?;
                },
                56 => {
                    self.totalFlow = is.read_int64()?;
                },
                66 => {
                    self.peerInfoList.push(is.read_message()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.configNodeInfo)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.machineInfo)?;
                },
                90 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.cheatWitnessInfoMap.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.beginSyncNum != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.beginSyncNum);
        }
        if !self.block.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.block);
        }
        if !self.solidityBlock.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.solidityBlock);
        }
        if self.currentConnectCount != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.currentConnectCount);
        }
        if self.activeConnectCount != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.activeConnectCount);
        }
        if self.passiveConnectCount != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.passiveConnectCount);
        }
        if self.totalFlow != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.totalFlow);
        }
        for value in &self.peerInfoList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.configNodeInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.machineInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.cheatWitnessInfoMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.beginSyncNum != 0 {
            os.write_int64(1, self.beginSyncNum)?;
        }
        if !self.block.is_empty() {
            os.write_string(2, &self.block)?;
        }
        if !self.solidityBlock.is_empty() {
            os.write_string(3, &self.solidityBlock)?;
        }
        if self.currentConnectCount != 0 {
            os.write_int32(4, self.currentConnectCount)?;
        }
        if self.activeConnectCount != 0 {
            os.write_int32(5, self.activeConnectCount)?;
        }
        if self.passiveConnectCount != 0 {
            os.write_int32(6, self.passiveConnectCount)?;
        }
        if self.totalFlow != 0 {
            os.write_int64(7, self.totalFlow)?;
        }
        for v in &self.peerInfoList {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if let Some(v) = self.configNodeInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.machineInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        for (k, v) in &self.cheatWitnessInfoMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(90)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeInfo {
        NodeInfo::new()
    }

    fn clear(&mut self) {
        self.beginSyncNum = 0;
        self.block.clear();
        self.solidityBlock.clear();
        self.currentConnectCount = 0;
        self.activeConnectCount = 0;
        self.passiveConnectCount = 0;
        self.totalFlow = 0;
        self.peerInfoList.clear();
        self.configNodeInfo.clear();
        self.machineInfo.clear();
        self.cheatWitnessInfoMap.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeInfo {
        static instance: ::protobuf::rt::Lazy<NodeInfo> = ::protobuf::rt::Lazy::new();
        instance.get(NodeInfo::new)
    }
}

impl ::protobuf::MessageFull for NodeInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `NodeInfo`
pub mod node_info {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:protocol.NodeInfo.PeerInfo)
    pub struct PeerInfo {
        // message fields
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.lastSyncBlock)
        pub lastSyncBlock: ::std::string::String,
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.remainNum)
        pub remainNum: i64,
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.lastBlockUpdateTime)
        pub lastBlockUpdateTime: i64,
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.syncFlag)
        pub syncFlag: bool,
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.headBlockTimeWeBothHave)
        pub headBlockTimeWeBothHave: i64,
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.needSyncFromPeer)
        pub needSyncFromPeer: bool,
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.needSyncFromUs)
        pub needSyncFromUs: bool,
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.host)
        pub host: ::std::string::String,
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.port)
        pub port: i32,
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.nodeId)
        pub nodeId: ::std::string::String,
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.connectTime)
        pub connectTime: i64,
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.avgLatency)
        pub avgLatency: f64,
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.syncToFetchSize)
        pub syncToFetchSize: i32,
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.syncToFetchSizePeekNum)
        pub syncToFetchSizePeekNum: i64,
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.syncBlockRequestedSize)
        pub syncBlockRequestedSize: i32,
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.unFetchSynNum)
        pub unFetchSynNum: i64,
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.blockInPorcSize)
        pub blockInPorcSize: i32,
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.headBlockWeBothHave)
        pub headBlockWeBothHave: ::std::string::String,
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.isActive)
        pub isActive: bool,
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.score)
        pub score: i32,
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.nodeCount)
        pub nodeCount: i32,
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.inFlow)
        pub inFlow: i64,
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.disconnectTimes)
        pub disconnectTimes: i32,
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.localDisconnectReason)
        pub localDisconnectReason: ::std::string::String,
        // @@protoc_insertion_point(field:protocol.NodeInfo.PeerInfo.remoteDisconnectReason)
        pub remoteDisconnectReason: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:protocol.NodeInfo.PeerInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PeerInfo {
        fn default() -> &'a PeerInfo {
            <PeerInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl PeerInfo {
        pub fn new() -> PeerInfo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(25);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "lastSyncBlock",
                |m: &PeerInfo| { &m.lastSyncBlock },
                |m: &mut PeerInfo| { &mut m.lastSyncBlock },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "remainNum",
                |m: &PeerInfo| { &m.remainNum },
                |m: &mut PeerInfo| { &mut m.remainNum },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "lastBlockUpdateTime",
                |m: &PeerInfo| { &m.lastBlockUpdateTime },
                |m: &mut PeerInfo| { &mut m.lastBlockUpdateTime },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "syncFlag",
                |m: &PeerInfo| { &m.syncFlag },
                |m: &mut PeerInfo| { &mut m.syncFlag },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "headBlockTimeWeBothHave",
                |m: &PeerInfo| { &m.headBlockTimeWeBothHave },
                |m: &mut PeerInfo| { &mut m.headBlockTimeWeBothHave },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "needSyncFromPeer",
                |m: &PeerInfo| { &m.needSyncFromPeer },
                |m: &mut PeerInfo| { &mut m.needSyncFromPeer },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "needSyncFromUs",
                |m: &PeerInfo| { &m.needSyncFromUs },
                |m: &mut PeerInfo| { &mut m.needSyncFromUs },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "host",
                |m: &PeerInfo| { &m.host },
                |m: &mut PeerInfo| { &mut m.host },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "port",
                |m: &PeerInfo| { &m.port },
                |m: &mut PeerInfo| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "nodeId",
                |m: &PeerInfo| { &m.nodeId },
                |m: &mut PeerInfo| { &mut m.nodeId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "connectTime",
                |m: &PeerInfo| { &m.connectTime },
                |m: &mut PeerInfo| { &mut m.connectTime },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "avgLatency",
                |m: &PeerInfo| { &m.avgLatency },
                |m: &mut PeerInfo| { &mut m.avgLatency },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "syncToFetchSize",
                |m: &PeerInfo| { &m.syncToFetchSize },
                |m: &mut PeerInfo| { &mut m.syncToFetchSize },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "syncToFetchSizePeekNum",
                |m: &PeerInfo| { &m.syncToFetchSizePeekNum },
                |m: &mut PeerInfo| { &mut m.syncToFetchSizePeekNum },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "syncBlockRequestedSize",
                |m: &PeerInfo| { &m.syncBlockRequestedSize },
                |m: &mut PeerInfo| { &mut m.syncBlockRequestedSize },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "unFetchSynNum",
                |m: &PeerInfo| { &m.unFetchSynNum },
                |m: &mut PeerInfo| { &mut m.unFetchSynNum },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "blockInPorcSize",
                |m: &PeerInfo| { &m.blockInPorcSize },
                |m: &mut PeerInfo| { &mut m.blockInPorcSize },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "headBlockWeBothHave",
                |m: &PeerInfo| { &m.headBlockWeBothHave },
                |m: &mut PeerInfo| { &mut m.headBlockWeBothHave },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "isActive",
                |m: &PeerInfo| { &m.isActive },
                |m: &mut PeerInfo| { &mut m.isActive },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "score",
                |m: &PeerInfo| { &m.score },
                |m: &mut PeerInfo| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "nodeCount",
                |m: &PeerInfo| { &m.nodeCount },
                |m: &mut PeerInfo| { &mut m.nodeCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "inFlow",
                |m: &PeerInfo| { &m.inFlow },
                |m: &mut PeerInfo| { &mut m.inFlow },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "disconnectTimes",
                |m: &PeerInfo| { &m.disconnectTimes },
                |m: &mut PeerInfo| { &mut m.disconnectTimes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "localDisconnectReason",
                |m: &PeerInfo| { &m.localDisconnectReason },
                |m: &mut PeerInfo| { &mut m.localDisconnectReason },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "remoteDisconnectReason",
                |m: &PeerInfo| { &m.remoteDisconnectReason },
                |m: &mut PeerInfo| { &mut m.remoteDisconnectReason },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PeerInfo>(
                "NodeInfo.PeerInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PeerInfo {
        const NAME: &'static str = "PeerInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.lastSyncBlock = is.read_string()?;
                    },
                    16 => {
                        self.remainNum = is.read_int64()?;
                    },
                    24 => {
                        self.lastBlockUpdateTime = is.read_int64()?;
                    },
                    32 => {
                        self.syncFlag = is.read_bool()?;
                    },
                    40 => {
                        self.headBlockTimeWeBothHave = is.read_int64()?;
                    },
                    48 => {
                        self.needSyncFromPeer = is.read_bool()?;
                    },
                    56 => {
                        self.needSyncFromUs = is.read_bool()?;
                    },
                    66 => {
                        self.host = is.read_string()?;
                    },
                    72 => {
                        self.port = is.read_int32()?;
                    },
                    82 => {
                        self.nodeId = is.read_string()?;
                    },
                    88 => {
                        self.connectTime = is.read_int64()?;
                    },
                    97 => {
                        self.avgLatency = is.read_double()?;
                    },
                    104 => {
                        self.syncToFetchSize = is.read_int32()?;
                    },
                    112 => {
                        self.syncToFetchSizePeekNum = is.read_int64()?;
                    },
                    120 => {
                        self.syncBlockRequestedSize = is.read_int32()?;
                    },
                    128 => {
                        self.unFetchSynNum = is.read_int64()?;
                    },
                    136 => {
                        self.blockInPorcSize = is.read_int32()?;
                    },
                    146 => {
                        self.headBlockWeBothHave = is.read_string()?;
                    },
                    152 => {
                        self.isActive = is.read_bool()?;
                    },
                    160 => {
                        self.score = is.read_int32()?;
                    },
                    168 => {
                        self.nodeCount = is.read_int32()?;
                    },
                    176 => {
                        self.inFlow = is.read_int64()?;
                    },
                    184 => {
                        self.disconnectTimes = is.read_int32()?;
                    },
                    194 => {
                        self.localDisconnectReason = is.read_string()?;
                    },
                    202 => {
                        self.remoteDisconnectReason = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.lastSyncBlock.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.lastSyncBlock);
            }
            if self.remainNum != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.remainNum);
            }
            if self.lastBlockUpdateTime != 0 {
                my_size += ::protobuf::rt::int64_size(3, self.lastBlockUpdateTime);
            }
            if self.syncFlag != false {
                my_size += 1 + 1;
            }
            if self.headBlockTimeWeBothHave != 0 {
                my_size += ::protobuf::rt::int64_size(5, self.headBlockTimeWeBothHave);
            }
            if self.needSyncFromPeer != false {
                my_size += 1 + 1;
            }
            if self.needSyncFromUs != false {
                my_size += 1 + 1;
            }
            if !self.host.is_empty() {
                my_size += ::protobuf::rt::string_size(8, &self.host);
            }
            if self.port != 0 {
                my_size += ::protobuf::rt::int32_size(9, self.port);
            }
            if !self.nodeId.is_empty() {
                my_size += ::protobuf::rt::string_size(10, &self.nodeId);
            }
            if self.connectTime != 0 {
                my_size += ::protobuf::rt::int64_size(11, self.connectTime);
            }
            if self.avgLatency != 0. {
                my_size += 1 + 8;
            }
            if self.syncToFetchSize != 0 {
                my_size += ::protobuf::rt::int32_size(13, self.syncToFetchSize);
            }
            if self.syncToFetchSizePeekNum != 0 {
                my_size += ::protobuf::rt::int64_size(14, self.syncToFetchSizePeekNum);
            }
            if self.syncBlockRequestedSize != 0 {
                my_size += ::protobuf::rt::int32_size(15, self.syncBlockRequestedSize);
            }
            if self.unFetchSynNum != 0 {
                my_size += ::protobuf::rt::int64_size(16, self.unFetchSynNum);
            }
            if self.blockInPorcSize != 0 {
                my_size += ::protobuf::rt::int32_size(17, self.blockInPorcSize);
            }
            if !self.headBlockWeBothHave.is_empty() {
                my_size += ::protobuf::rt::string_size(18, &self.headBlockWeBothHave);
            }
            if self.isActive != false {
                my_size += 2 + 1;
            }
            if self.score != 0 {
                my_size += ::protobuf::rt::int32_size(20, self.score);
            }
            if self.nodeCount != 0 {
                my_size += ::protobuf::rt::int32_size(21, self.nodeCount);
            }
            if self.inFlow != 0 {
                my_size += ::protobuf::rt::int64_size(22, self.inFlow);
            }
            if self.disconnectTimes != 0 {
                my_size += ::protobuf::rt::int32_size(23, self.disconnectTimes);
            }
            if !self.localDisconnectReason.is_empty() {
                my_size += ::protobuf::rt::string_size(24, &self.localDisconnectReason);
            }
            if !self.remoteDisconnectReason.is_empty() {
                my_size += ::protobuf::rt::string_size(25, &self.remoteDisconnectReason);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.lastSyncBlock.is_empty() {
                os.write_string(1, &self.lastSyncBlock)?;
            }
            if self.remainNum != 0 {
                os.write_int64(2, self.remainNum)?;
            }
            if self.lastBlockUpdateTime != 0 {
                os.write_int64(3, self.lastBlockUpdateTime)?;
            }
            if self.syncFlag != false {
                os.write_bool(4, self.syncFlag)?;
            }
            if self.headBlockTimeWeBothHave != 0 {
                os.write_int64(5, self.headBlockTimeWeBothHave)?;
            }
            if self.needSyncFromPeer != false {
                os.write_bool(6, self.needSyncFromPeer)?;
            }
            if self.needSyncFromUs != false {
                os.write_bool(7, self.needSyncFromUs)?;
            }
            if !self.host.is_empty() {
                os.write_string(8, &self.host)?;
            }
            if self.port != 0 {
                os.write_int32(9, self.port)?;
            }
            if !self.nodeId.is_empty() {
                os.write_string(10, &self.nodeId)?;
            }
            if self.connectTime != 0 {
                os.write_int64(11, self.connectTime)?;
            }
            if self.avgLatency != 0. {
                os.write_double(12, self.avgLatency)?;
            }
            if self.syncToFetchSize != 0 {
                os.write_int32(13, self.syncToFetchSize)?;
            }
            if self.syncToFetchSizePeekNum != 0 {
                os.write_int64(14, self.syncToFetchSizePeekNum)?;
            }
            if self.syncBlockRequestedSize != 0 {
                os.write_int32(15, self.syncBlockRequestedSize)?;
            }
            if self.unFetchSynNum != 0 {
                os.write_int64(16, self.unFetchSynNum)?;
            }
            if self.blockInPorcSize != 0 {
                os.write_int32(17, self.blockInPorcSize)?;
            }
            if !self.headBlockWeBothHave.is_empty() {
                os.write_string(18, &self.headBlockWeBothHave)?;
            }
            if self.isActive != false {
                os.write_bool(19, self.isActive)?;
            }
            if self.score != 0 {
                os.write_int32(20, self.score)?;
            }
            if self.nodeCount != 0 {
                os.write_int32(21, self.nodeCount)?;
            }
            if self.inFlow != 0 {
                os.write_int64(22, self.inFlow)?;
            }
            if self.disconnectTimes != 0 {
                os.write_int32(23, self.disconnectTimes)?;
            }
            if !self.localDisconnectReason.is_empty() {
                os.write_string(24, &self.localDisconnectReason)?;
            }
            if !self.remoteDisconnectReason.is_empty() {
                os.write_string(25, &self.remoteDisconnectReason)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PeerInfo {
            PeerInfo::new()
        }

        fn clear(&mut self) {
            self.lastSyncBlock.clear();
            self.remainNum = 0;
            self.lastBlockUpdateTime = 0;
            self.syncFlag = false;
            self.headBlockTimeWeBothHave = 0;
            self.needSyncFromPeer = false;
            self.needSyncFromUs = false;
            self.host.clear();
            self.port = 0;
            self.nodeId.clear();
            self.connectTime = 0;
            self.avgLatency = 0.;
            self.syncToFetchSize = 0;
            self.syncToFetchSizePeekNum = 0;
            self.syncBlockRequestedSize = 0;
            self.unFetchSynNum = 0;
            self.blockInPorcSize = 0;
            self.headBlockWeBothHave.clear();
            self.isActive = false;
            self.score = 0;
            self.nodeCount = 0;
            self.inFlow = 0;
            self.disconnectTimes = 0;
            self.localDisconnectReason.clear();
            self.remoteDisconnectReason.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PeerInfo {
            static instance: PeerInfo = PeerInfo {
                lastSyncBlock: ::std::string::String::new(),
                remainNum: 0,
                lastBlockUpdateTime: 0,
                syncFlag: false,
                headBlockTimeWeBothHave: 0,
                needSyncFromPeer: false,
                needSyncFromUs: false,
                host: ::std::string::String::new(),
                port: 0,
                nodeId: ::std::string::String::new(),
                connectTime: 0,
                avgLatency: 0.,
                syncToFetchSize: 0,
                syncToFetchSizePeekNum: 0,
                syncBlockRequestedSize: 0,
                unFetchSynNum: 0,
                blockInPorcSize: 0,
                headBlockWeBothHave: ::std::string::String::new(),
                isActive: false,
                score: 0,
                nodeCount: 0,
                inFlow: 0,
                disconnectTimes: 0,
                localDisconnectReason: ::std::string::String::new(),
                remoteDisconnectReason: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PeerInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("NodeInfo.PeerInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PeerInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PeerInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:protocol.NodeInfo.ConfigNodeInfo)
    pub struct ConfigNodeInfo {
        // message fields
        // @@protoc_insertion_point(field:protocol.NodeInfo.ConfigNodeInfo.codeVersion)
        pub codeVersion: ::std::string::String,
        // @@protoc_insertion_point(field:protocol.NodeInfo.ConfigNodeInfo.p2pVersion)
        pub p2pVersion: ::std::string::String,
        // @@protoc_insertion_point(field:protocol.NodeInfo.ConfigNodeInfo.listenPort)
        pub listenPort: i32,
        // @@protoc_insertion_point(field:protocol.NodeInfo.ConfigNodeInfo.discoverEnable)
        pub discoverEnable: bool,
        // @@protoc_insertion_point(field:protocol.NodeInfo.ConfigNodeInfo.activeNodeSize)
        pub activeNodeSize: i32,
        // @@protoc_insertion_point(field:protocol.NodeInfo.ConfigNodeInfo.passiveNodeSize)
        pub passiveNodeSize: i32,
        // @@protoc_insertion_point(field:protocol.NodeInfo.ConfigNodeInfo.sendNodeSize)
        pub sendNodeSize: i32,
        // @@protoc_insertion_point(field:protocol.NodeInfo.ConfigNodeInfo.maxConnectCount)
        pub maxConnectCount: i32,
        // @@protoc_insertion_point(field:protocol.NodeInfo.ConfigNodeInfo.sameIpMaxConnectCount)
        pub sameIpMaxConnectCount: i32,
        // @@protoc_insertion_point(field:protocol.NodeInfo.ConfigNodeInfo.backupListenPort)
        pub backupListenPort: i32,
        // @@protoc_insertion_point(field:protocol.NodeInfo.ConfigNodeInfo.backupMemberSize)
        pub backupMemberSize: i32,
        // @@protoc_insertion_point(field:protocol.NodeInfo.ConfigNodeInfo.backupPriority)
        pub backupPriority: i32,
        // @@protoc_insertion_point(field:protocol.NodeInfo.ConfigNodeInfo.dbVersion)
        pub dbVersion: i32,
        // @@protoc_insertion_point(field:protocol.NodeInfo.ConfigNodeInfo.minParticipationRate)
        pub minParticipationRate: i32,
        // @@protoc_insertion_point(field:protocol.NodeInfo.ConfigNodeInfo.supportConstant)
        pub supportConstant: bool,
        // @@protoc_insertion_point(field:protocol.NodeInfo.ConfigNodeInfo.minTimeRatio)
        pub minTimeRatio: f64,
        // @@protoc_insertion_point(field:protocol.NodeInfo.ConfigNodeInfo.maxTimeRatio)
        pub maxTimeRatio: f64,
        // @@protoc_insertion_point(field:protocol.NodeInfo.ConfigNodeInfo.allowCreationOfContracts)
        pub allowCreationOfContracts: i64,
        // @@protoc_insertion_point(field:protocol.NodeInfo.ConfigNodeInfo.allowAdaptiveEnergy)
        pub allowAdaptiveEnergy: i64,
        // special fields
        // @@protoc_insertion_point(special_field:protocol.NodeInfo.ConfigNodeInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ConfigNodeInfo {
        fn default() -> &'a ConfigNodeInfo {
            <ConfigNodeInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl ConfigNodeInfo {
        pub fn new() -> ConfigNodeInfo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(19);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "codeVersion",
                |m: &ConfigNodeInfo| { &m.codeVersion },
                |m: &mut ConfigNodeInfo| { &mut m.codeVersion },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "p2pVersion",
                |m: &ConfigNodeInfo| { &m.p2pVersion },
                |m: &mut ConfigNodeInfo| { &mut m.p2pVersion },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "listenPort",
                |m: &ConfigNodeInfo| { &m.listenPort },
                |m: &mut ConfigNodeInfo| { &mut m.listenPort },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "discoverEnable",
                |m: &ConfigNodeInfo| { &m.discoverEnable },
                |m: &mut ConfigNodeInfo| { &mut m.discoverEnable },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "activeNodeSize",
                |m: &ConfigNodeInfo| { &m.activeNodeSize },
                |m: &mut ConfigNodeInfo| { &mut m.activeNodeSize },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "passiveNodeSize",
                |m: &ConfigNodeInfo| { &m.passiveNodeSize },
                |m: &mut ConfigNodeInfo| { &mut m.passiveNodeSize },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "sendNodeSize",
                |m: &ConfigNodeInfo| { &m.sendNodeSize },
                |m: &mut ConfigNodeInfo| { &mut m.sendNodeSize },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "maxConnectCount",
                |m: &ConfigNodeInfo| { &m.maxConnectCount },
                |m: &mut ConfigNodeInfo| { &mut m.maxConnectCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "sameIpMaxConnectCount",
                |m: &ConfigNodeInfo| { &m.sameIpMaxConnectCount },
                |m: &mut ConfigNodeInfo| { &mut m.sameIpMaxConnectCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "backupListenPort",
                |m: &ConfigNodeInfo| { &m.backupListenPort },
                |m: &mut ConfigNodeInfo| { &mut m.backupListenPort },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "backupMemberSize",
                |m: &ConfigNodeInfo| { &m.backupMemberSize },
                |m: &mut ConfigNodeInfo| { &mut m.backupMemberSize },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "backupPriority",
                |m: &ConfigNodeInfo| { &m.backupPriority },
                |m: &mut ConfigNodeInfo| { &mut m.backupPriority },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "dbVersion",
                |m: &ConfigNodeInfo| { &m.dbVersion },
                |m: &mut ConfigNodeInfo| { &mut m.dbVersion },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "minParticipationRate",
                |m: &ConfigNodeInfo| { &m.minParticipationRate },
                |m: &mut ConfigNodeInfo| { &mut m.minParticipationRate },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "supportConstant",
                |m: &ConfigNodeInfo| { &m.supportConstant },
                |m: &mut ConfigNodeInfo| { &mut m.supportConstant },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "minTimeRatio",
                |m: &ConfigNodeInfo| { &m.minTimeRatio },
                |m: &mut ConfigNodeInfo| { &mut m.minTimeRatio },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "maxTimeRatio",
                |m: &ConfigNodeInfo| { &m.maxTimeRatio },
                |m: &mut ConfigNodeInfo| { &mut m.maxTimeRatio },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "allowCreationOfContracts",
                |m: &ConfigNodeInfo| { &m.allowCreationOfContracts },
                |m: &mut ConfigNodeInfo| { &mut m.allowCreationOfContracts },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "allowAdaptiveEnergy",
                |m: &ConfigNodeInfo| { &m.allowAdaptiveEnergy },
                |m: &mut ConfigNodeInfo| { &mut m.allowAdaptiveEnergy },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConfigNodeInfo>(
                "NodeInfo.ConfigNodeInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ConfigNodeInfo {
        const NAME: &'static str = "ConfigNodeInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.codeVersion = is.read_string()?;
                    },
                    18 => {
                        self.p2pVersion = is.read_string()?;
                    },
                    24 => {
                        self.listenPort = is.read_int32()?;
                    },
                    32 => {
                        self.discoverEnable = is.read_bool()?;
                    },
                    40 => {
                        self.activeNodeSize = is.read_int32()?;
                    },
                    48 => {
                        self.passiveNodeSize = is.read_int32()?;
                    },
                    56 => {
                        self.sendNodeSize = is.read_int32()?;
                    },
                    64 => {
                        self.maxConnectCount = is.read_int32()?;
                    },
                    72 => {
                        self.sameIpMaxConnectCount = is.read_int32()?;
                    },
                    80 => {
                        self.backupListenPort = is.read_int32()?;
                    },
                    88 => {
                        self.backupMemberSize = is.read_int32()?;
                    },
                    96 => {
                        self.backupPriority = is.read_int32()?;
                    },
                    104 => {
                        self.dbVersion = is.read_int32()?;
                    },
                    112 => {
                        self.minParticipationRate = is.read_int32()?;
                    },
                    120 => {
                        self.supportConstant = is.read_bool()?;
                    },
                    129 => {
                        self.minTimeRatio = is.read_double()?;
                    },
                    137 => {
                        self.maxTimeRatio = is.read_double()?;
                    },
                    144 => {
                        self.allowCreationOfContracts = is.read_int64()?;
                    },
                    152 => {
                        self.allowAdaptiveEnergy = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.codeVersion.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.codeVersion);
            }
            if !self.p2pVersion.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.p2pVersion);
            }
            if self.listenPort != 0 {
                my_size += ::protobuf::rt::int32_size(3, self.listenPort);
            }
            if self.discoverEnable != false {
                my_size += 1 + 1;
            }
            if self.activeNodeSize != 0 {
                my_size += ::protobuf::rt::int32_size(5, self.activeNodeSize);
            }
            if self.passiveNodeSize != 0 {
                my_size += ::protobuf::rt::int32_size(6, self.passiveNodeSize);
            }
            if self.sendNodeSize != 0 {
                my_size += ::protobuf::rt::int32_size(7, self.sendNodeSize);
            }
            if self.maxConnectCount != 0 {
                my_size += ::protobuf::rt::int32_size(8, self.maxConnectCount);
            }
            if self.sameIpMaxConnectCount != 0 {
                my_size += ::protobuf::rt::int32_size(9, self.sameIpMaxConnectCount);
            }
            if self.backupListenPort != 0 {
                my_size += ::protobuf::rt::int32_size(10, self.backupListenPort);
            }
            if self.backupMemberSize != 0 {
                my_size += ::protobuf::rt::int32_size(11, self.backupMemberSize);
            }
            if self.backupPriority != 0 {
                my_size += ::protobuf::rt::int32_size(12, self.backupPriority);
            }
            if self.dbVersion != 0 {
                my_size += ::protobuf::rt::int32_size(13, self.dbVersion);
            }
            if self.minParticipationRate != 0 {
                my_size += ::protobuf::rt::int32_size(14, self.minParticipationRate);
            }
            if self.supportConstant != false {
                my_size += 1 + 1;
            }
            if self.minTimeRatio != 0. {
                my_size += 2 + 8;
            }
            if self.maxTimeRatio != 0. {
                my_size += 2 + 8;
            }
            if self.allowCreationOfContracts != 0 {
                my_size += ::protobuf::rt::int64_size(18, self.allowCreationOfContracts);
            }
            if self.allowAdaptiveEnergy != 0 {
                my_size += ::protobuf::rt::int64_size(19, self.allowAdaptiveEnergy);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.codeVersion.is_empty() {
                os.write_string(1, &self.codeVersion)?;
            }
            if !self.p2pVersion.is_empty() {
                os.write_string(2, &self.p2pVersion)?;
            }
            if self.listenPort != 0 {
                os.write_int32(3, self.listenPort)?;
            }
            if self.discoverEnable != false {
                os.write_bool(4, self.discoverEnable)?;
            }
            if self.activeNodeSize != 0 {
                os.write_int32(5, self.activeNodeSize)?;
            }
            if self.passiveNodeSize != 0 {
                os.write_int32(6, self.passiveNodeSize)?;
            }
            if self.sendNodeSize != 0 {
                os.write_int32(7, self.sendNodeSize)?;
            }
            if self.maxConnectCount != 0 {
                os.write_int32(8, self.maxConnectCount)?;
            }
            if self.sameIpMaxConnectCount != 0 {
                os.write_int32(9, self.sameIpMaxConnectCount)?;
            }
            if self.backupListenPort != 0 {
                os.write_int32(10, self.backupListenPort)?;
            }
            if self.backupMemberSize != 0 {
                os.write_int32(11, self.backupMemberSize)?;
            }
            if self.backupPriority != 0 {
                os.write_int32(12, self.backupPriority)?;
            }
            if self.dbVersion != 0 {
                os.write_int32(13, self.dbVersion)?;
            }
            if self.minParticipationRate != 0 {
                os.write_int32(14, self.minParticipationRate)?;
            }
            if self.supportConstant != false {
                os.write_bool(15, self.supportConstant)?;
            }
            if self.minTimeRatio != 0. {
                os.write_double(16, self.minTimeRatio)?;
            }
            if self.maxTimeRatio != 0. {
                os.write_double(17, self.maxTimeRatio)?;
            }
            if self.allowCreationOfContracts != 0 {
                os.write_int64(18, self.allowCreationOfContracts)?;
            }
            if self.allowAdaptiveEnergy != 0 {
                os.write_int64(19, self.allowAdaptiveEnergy)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ConfigNodeInfo {
            ConfigNodeInfo::new()
        }

        fn clear(&mut self) {
            self.codeVersion.clear();
            self.p2pVersion.clear();
            self.listenPort = 0;
            self.discoverEnable = false;
            self.activeNodeSize = 0;
            self.passiveNodeSize = 0;
            self.sendNodeSize = 0;
            self.maxConnectCount = 0;
            self.sameIpMaxConnectCount = 0;
            self.backupListenPort = 0;
            self.backupMemberSize = 0;
            self.backupPriority = 0;
            self.dbVersion = 0;
            self.minParticipationRate = 0;
            self.supportConstant = false;
            self.minTimeRatio = 0.;
            self.maxTimeRatio = 0.;
            self.allowCreationOfContracts = 0;
            self.allowAdaptiveEnergy = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ConfigNodeInfo {
            static instance: ConfigNodeInfo = ConfigNodeInfo {
                codeVersion: ::std::string::String::new(),
                p2pVersion: ::std::string::String::new(),
                listenPort: 0,
                discoverEnable: false,
                activeNodeSize: 0,
                passiveNodeSize: 0,
                sendNodeSize: 0,
                maxConnectCount: 0,
                sameIpMaxConnectCount: 0,
                backupListenPort: 0,
                backupMemberSize: 0,
                backupPriority: 0,
                dbVersion: 0,
                minParticipationRate: 0,
                supportConstant: false,
                minTimeRatio: 0.,
                maxTimeRatio: 0.,
                allowCreationOfContracts: 0,
                allowAdaptiveEnergy: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ConfigNodeInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("NodeInfo.ConfigNodeInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ConfigNodeInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ConfigNodeInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:protocol.NodeInfo.MachineInfo)
    pub struct MachineInfo {
        // message fields
        // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.threadCount)
        pub threadCount: i32,
        // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.deadLockThreadCount)
        pub deadLockThreadCount: i32,
        // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.cpuCount)
        pub cpuCount: i32,
        // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.totalMemory)
        pub totalMemory: i64,
        // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.freeMemory)
        pub freeMemory: i64,
        // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.cpuRate)
        pub cpuRate: f64,
        // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.javaVersion)
        pub javaVersion: ::std::string::String,
        // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.osName)
        pub osName: ::std::string::String,
        // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.jvmTotalMemory)
        pub jvmTotalMemory: i64,
        // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.jvmFreeMemory)
        pub jvmFreeMemory: i64,
        // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.processCpuRate)
        pub processCpuRate: f64,
        // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.memoryDescInfoList)
        pub memoryDescInfoList: ::std::vec::Vec<machine_info::MemoryDescInfo>,
        // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.deadLockThreadInfoList)
        pub deadLockThreadInfoList: ::std::vec::Vec<machine_info::DeadLockThreadInfo>,
        // special fields
        // @@protoc_insertion_point(special_field:protocol.NodeInfo.MachineInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MachineInfo {
        fn default() -> &'a MachineInfo {
            <MachineInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl MachineInfo {
        pub fn new() -> MachineInfo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(13);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "threadCount",
                |m: &MachineInfo| { &m.threadCount },
                |m: &mut MachineInfo| { &mut m.threadCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "deadLockThreadCount",
                |m: &MachineInfo| { &m.deadLockThreadCount },
                |m: &mut MachineInfo| { &mut m.deadLockThreadCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "cpuCount",
                |m: &MachineInfo| { &m.cpuCount },
                |m: &mut MachineInfo| { &mut m.cpuCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "totalMemory",
                |m: &MachineInfo| { &m.totalMemory },
                |m: &mut MachineInfo| { &mut m.totalMemory },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "freeMemory",
                |m: &MachineInfo| { &m.freeMemory },
                |m: &mut MachineInfo| { &mut m.freeMemory },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "cpuRate",
                |m: &MachineInfo| { &m.cpuRate },
                |m: &mut MachineInfo| { &mut m.cpuRate },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "javaVersion",
                |m: &MachineInfo| { &m.javaVersion },
                |m: &mut MachineInfo| { &mut m.javaVersion },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "osName",
                |m: &MachineInfo| { &m.osName },
                |m: &mut MachineInfo| { &mut m.osName },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "jvmTotalMemory",
                |m: &MachineInfo| { &m.jvmTotalMemory },
                |m: &mut MachineInfo| { &mut m.jvmTotalMemory },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "jvmFreeMemory",
                |m: &MachineInfo| { &m.jvmFreeMemory },
                |m: &mut MachineInfo| { &mut m.jvmFreeMemory },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "processCpuRate",
                |m: &MachineInfo| { &m.processCpuRate },
                |m: &mut MachineInfo| { &mut m.processCpuRate },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "memoryDescInfoList",
                |m: &MachineInfo| { &m.memoryDescInfoList },
                |m: &mut MachineInfo| { &mut m.memoryDescInfoList },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "deadLockThreadInfoList",
                |m: &MachineInfo| { &m.deadLockThreadInfoList },
                |m: &mut MachineInfo| { &mut m.deadLockThreadInfoList },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MachineInfo>(
                "NodeInfo.MachineInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MachineInfo {
        const NAME: &'static str = "MachineInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.threadCount = is.read_int32()?;
                    },
                    16 => {
                        self.deadLockThreadCount = is.read_int32()?;
                    },
                    24 => {
                        self.cpuCount = is.read_int32()?;
                    },
                    32 => {
                        self.totalMemory = is.read_int64()?;
                    },
                    40 => {
                        self.freeMemory = is.read_int64()?;
                    },
                    49 => {
                        self.cpuRate = is.read_double()?;
                    },
                    58 => {
                        self.javaVersion = is.read_string()?;
                    },
                    66 => {
                        self.osName = is.read_string()?;
                    },
                    72 => {
                        self.jvmTotalMemory = is.read_int64()?;
                    },
                    80 => {
                        self.jvmFreeMemory = is.read_int64()?;
                    },
                    89 => {
                        self.processCpuRate = is.read_double()?;
                    },
                    98 => {
                        self.memoryDescInfoList.push(is.read_message()?);
                    },
                    106 => {
                        self.deadLockThreadInfoList.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.threadCount != 0 {
                my_size += ::protobuf::rt::int32_size(1, self.threadCount);
            }
            if self.deadLockThreadCount != 0 {
                my_size += ::protobuf::rt::int32_size(2, self.deadLockThreadCount);
            }
            if self.cpuCount != 0 {
                my_size += ::protobuf::rt::int32_size(3, self.cpuCount);
            }
            if self.totalMemory != 0 {
                my_size += ::protobuf::rt::int64_size(4, self.totalMemory);
            }
            if self.freeMemory != 0 {
                my_size += ::protobuf::rt::int64_size(5, self.freeMemory);
            }
            if self.cpuRate != 0. {
                my_size += 1 + 8;
            }
            if !self.javaVersion.is_empty() {
                my_size += ::protobuf::rt::string_size(7, &self.javaVersion);
            }
            if !self.osName.is_empty() {
                my_size += ::protobuf::rt::string_size(8, &self.osName);
            }
            if self.jvmTotalMemory != 0 {
                my_size += ::protobuf::rt::int64_size(9, self.jvmTotalMemory);
            }
            if self.jvmFreeMemory != 0 {
                my_size += ::protobuf::rt::int64_size(10, self.jvmFreeMemory);
            }
            if self.processCpuRate != 0. {
                my_size += 1 + 8;
            }
            for value in &self.memoryDescInfoList {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.deadLockThreadInfoList {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.threadCount != 0 {
                os.write_int32(1, self.threadCount)?;
            }
            if self.deadLockThreadCount != 0 {
                os.write_int32(2, self.deadLockThreadCount)?;
            }
            if self.cpuCount != 0 {
                os.write_int32(3, self.cpuCount)?;
            }
            if self.totalMemory != 0 {
                os.write_int64(4, self.totalMemory)?;
            }
            if self.freeMemory != 0 {
                os.write_int64(5, self.freeMemory)?;
            }
            if self.cpuRate != 0. {
                os.write_double(6, self.cpuRate)?;
            }
            if !self.javaVersion.is_empty() {
                os.write_string(7, &self.javaVersion)?;
            }
            if !self.osName.is_empty() {
                os.write_string(8, &self.osName)?;
            }
            if self.jvmTotalMemory != 0 {
                os.write_int64(9, self.jvmTotalMemory)?;
            }
            if self.jvmFreeMemory != 0 {
                os.write_int64(10, self.jvmFreeMemory)?;
            }
            if self.processCpuRate != 0. {
                os.write_double(11, self.processCpuRate)?;
            }
            for v in &self.memoryDescInfoList {
                ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
            };
            for v in &self.deadLockThreadInfoList {
                ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MachineInfo {
            MachineInfo::new()
        }

        fn clear(&mut self) {
            self.threadCount = 0;
            self.deadLockThreadCount = 0;
            self.cpuCount = 0;
            self.totalMemory = 0;
            self.freeMemory = 0;
            self.cpuRate = 0.;
            self.javaVersion.clear();
            self.osName.clear();
            self.jvmTotalMemory = 0;
            self.jvmFreeMemory = 0;
            self.processCpuRate = 0.;
            self.memoryDescInfoList.clear();
            self.deadLockThreadInfoList.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MachineInfo {
            static instance: MachineInfo = MachineInfo {
                threadCount: 0,
                deadLockThreadCount: 0,
                cpuCount: 0,
                totalMemory: 0,
                freeMemory: 0,
                cpuRate: 0.,
                javaVersion: ::std::string::String::new(),
                osName: ::std::string::String::new(),
                jvmTotalMemory: 0,
                jvmFreeMemory: 0,
                processCpuRate: 0.,
                memoryDescInfoList: ::std::vec::Vec::new(),
                deadLockThreadInfoList: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MachineInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("NodeInfo.MachineInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MachineInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MachineInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `MachineInfo`
    pub mod machine_info {
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:protocol.NodeInfo.MachineInfo.MemoryDescInfo)
        pub struct MemoryDescInfo {
            // message fields
            // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.MemoryDescInfo.name)
            pub name: ::std::string::String,
            // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.MemoryDescInfo.initSize)
            pub initSize: i64,
            // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.MemoryDescInfo.useSize)
            pub useSize: i64,
            // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.MemoryDescInfo.maxSize)
            pub maxSize: i64,
            // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.MemoryDescInfo.useRate)
            pub useRate: f64,
            // special fields
            // @@protoc_insertion_point(special_field:protocol.NodeInfo.MachineInfo.MemoryDescInfo.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a MemoryDescInfo {
            fn default() -> &'a MemoryDescInfo {
                <MemoryDescInfo as ::protobuf::Message>::default_instance()
            }
        }

        impl MemoryDescInfo {
            pub fn new() -> MemoryDescInfo {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "name",
                    |m: &MemoryDescInfo| { &m.name },
                    |m: &mut MemoryDescInfo| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "initSize",
                    |m: &MemoryDescInfo| { &m.initSize },
                    |m: &mut MemoryDescInfo| { &mut m.initSize },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "useSize",
                    |m: &MemoryDescInfo| { &m.useSize },
                    |m: &mut MemoryDescInfo| { &mut m.useSize },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "maxSize",
                    |m: &MemoryDescInfo| { &m.maxSize },
                    |m: &mut MemoryDescInfo| { &mut m.maxSize },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "useRate",
                    |m: &MemoryDescInfo| { &m.useRate },
                    |m: &mut MemoryDescInfo| { &mut m.useRate },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MemoryDescInfo>(
                    "NodeInfo.MachineInfo.MemoryDescInfo",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for MemoryDescInfo {
            const NAME: &'static str = "MemoryDescInfo";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.name = is.read_string()?;
                        },
                        16 => {
                            self.initSize = is.read_int64()?;
                        },
                        24 => {
                            self.useSize = is.read_int64()?;
                        },
                        32 => {
                            self.maxSize = is.read_int64()?;
                        },
                        41 => {
                            self.useRate = is.read_double()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.name.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.name);
                }
                if self.initSize != 0 {
                    my_size += ::protobuf::rt::int64_size(2, self.initSize);
                }
                if self.useSize != 0 {
                    my_size += ::protobuf::rt::int64_size(3, self.useSize);
                }
                if self.maxSize != 0 {
                    my_size += ::protobuf::rt::int64_size(4, self.maxSize);
                }
                if self.useRate != 0. {
                    my_size += 1 + 8;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.name.is_empty() {
                    os.write_string(1, &self.name)?;
                }
                if self.initSize != 0 {
                    os.write_int64(2, self.initSize)?;
                }
                if self.useSize != 0 {
                    os.write_int64(3, self.useSize)?;
                }
                if self.maxSize != 0 {
                    os.write_int64(4, self.maxSize)?;
                }
                if self.useRate != 0. {
                    os.write_double(5, self.useRate)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> MemoryDescInfo {
                MemoryDescInfo::new()
            }

            fn clear(&mut self) {
                self.name.clear();
                self.initSize = 0;
                self.useSize = 0;
                self.maxSize = 0;
                self.useRate = 0.;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static MemoryDescInfo {
                static instance: MemoryDescInfo = MemoryDescInfo {
                    name: ::std::string::String::new(),
                    initSize: 0,
                    useSize: 0,
                    maxSize: 0,
                    useRate: 0.,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for MemoryDescInfo {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("NodeInfo.MachineInfo.MemoryDescInfo").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for MemoryDescInfo {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for MemoryDescInfo {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo)
        pub struct DeadLockThreadInfo {
            // message fields
            // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.name)
            pub name: ::std::string::String,
            // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.lockName)
            pub lockName: ::std::string::String,
            // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.lockOwner)
            pub lockOwner: ::std::string::String,
            // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.state)
            pub state: ::std::string::String,
            // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.blockTime)
            pub blockTime: i64,
            // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.waitTime)
            pub waitTime: i64,
            // @@protoc_insertion_point(field:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.stackTrace)
            pub stackTrace: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a DeadLockThreadInfo {
            fn default() -> &'a DeadLockThreadInfo {
                <DeadLockThreadInfo as ::protobuf::Message>::default_instance()
            }
        }

        impl DeadLockThreadInfo {
            pub fn new() -> DeadLockThreadInfo {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(7);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "name",
                    |m: &DeadLockThreadInfo| { &m.name },
                    |m: &mut DeadLockThreadInfo| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "lockName",
                    |m: &DeadLockThreadInfo| { &m.lockName },
                    |m: &mut DeadLockThreadInfo| { &mut m.lockName },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "lockOwner",
                    |m: &DeadLockThreadInfo| { &m.lockOwner },
                    |m: &mut DeadLockThreadInfo| { &mut m.lockOwner },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "state",
                    |m: &DeadLockThreadInfo| { &m.state },
                    |m: &mut DeadLockThreadInfo| { &mut m.state },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "blockTime",
                    |m: &DeadLockThreadInfo| { &m.blockTime },
                    |m: &mut DeadLockThreadInfo| { &mut m.blockTime },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "waitTime",
                    |m: &DeadLockThreadInfo| { &m.waitTime },
                    |m: &mut DeadLockThreadInfo| { &mut m.waitTime },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "stackTrace",
                    |m: &DeadLockThreadInfo| { &m.stackTrace },
                    |m: &mut DeadLockThreadInfo| { &mut m.stackTrace },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeadLockThreadInfo>(
                    "NodeInfo.MachineInfo.DeadLockThreadInfo",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for DeadLockThreadInfo {
            const NAME: &'static str = "DeadLockThreadInfo";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.name = is.read_string()?;
                        },
                        18 => {
                            self.lockName = is.read_string()?;
                        },
                        26 => {
                            self.lockOwner = is.read_string()?;
                        },
                        34 => {
                            self.state = is.read_string()?;
                        },
                        40 => {
                            self.blockTime = is.read_int64()?;
                        },
                        48 => {
                            self.waitTime = is.read_int64()?;
                        },
                        58 => {
                            self.stackTrace = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.name.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.name);
                }
                if !self.lockName.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.lockName);
                }
                if !self.lockOwner.is_empty() {
                    my_size += ::protobuf::rt::string_size(3, &self.lockOwner);
                }
                if !self.state.is_empty() {
                    my_size += ::protobuf::rt::string_size(4, &self.state);
                }
                if self.blockTime != 0 {
                    my_size += ::protobuf::rt::int64_size(5, self.blockTime);
                }
                if self.waitTime != 0 {
                    my_size += ::protobuf::rt::int64_size(6, self.waitTime);
                }
                if !self.stackTrace.is_empty() {
                    my_size += ::protobuf::rt::string_size(7, &self.stackTrace);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.name.is_empty() {
                    os.write_string(1, &self.name)?;
                }
                if !self.lockName.is_empty() {
                    os.write_string(2, &self.lockName)?;
                }
                if !self.lockOwner.is_empty() {
                    os.write_string(3, &self.lockOwner)?;
                }
                if !self.state.is_empty() {
                    os.write_string(4, &self.state)?;
                }
                if self.blockTime != 0 {
                    os.write_int64(5, self.blockTime)?;
                }
                if self.waitTime != 0 {
                    os.write_int64(6, self.waitTime)?;
                }
                if !self.stackTrace.is_empty() {
                    os.write_string(7, &self.stackTrace)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> DeadLockThreadInfo {
                DeadLockThreadInfo::new()
            }

            fn clear(&mut self) {
                self.name.clear();
                self.lockName.clear();
                self.lockOwner.clear();
                self.state.clear();
                self.blockTime = 0;
                self.waitTime = 0;
                self.stackTrace.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static DeadLockThreadInfo {
                static instance: DeadLockThreadInfo = DeadLockThreadInfo {
                    name: ::std::string::String::new(),
                    lockName: ::std::string::String::new(),
                    lockOwner: ::std::string::String::new(),
                    state: ::std::string::String::new(),
                    blockTime: 0,
                    waitTime: 0,
                    stackTrace: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for DeadLockThreadInfo {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("NodeInfo.MachineInfo.DeadLockThreadInfo").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for DeadLockThreadInfo {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for DeadLockThreadInfo {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.MetricsInfo)
pub struct MetricsInfo {
    // message fields
    // @@protoc_insertion_point(field:protocol.MetricsInfo.interval)
    pub interval: i64,
    // @@protoc_insertion_point(field:protocol.MetricsInfo.node)
    pub node: ::protobuf::MessageField<metrics_info::NodeInfo>,
    // @@protoc_insertion_point(field:protocol.MetricsInfo.blockchain)
    pub blockchain: ::protobuf::MessageField<metrics_info::BlockChainInfo>,
    // @@protoc_insertion_point(field:protocol.MetricsInfo.net)
    pub net: ::protobuf::MessageField<metrics_info::NetInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.MetricsInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MetricsInfo {
    fn default() -> &'a MetricsInfo {
        <MetricsInfo as ::protobuf::Message>::default_instance()
    }
}

impl MetricsInfo {
    pub fn new() -> MetricsInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "interval",
            |m: &MetricsInfo| { &m.interval },
            |m: &mut MetricsInfo| { &mut m.interval },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, metrics_info::NodeInfo>(
            "node",
            |m: &MetricsInfo| { &m.node },
            |m: &mut MetricsInfo| { &mut m.node },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, metrics_info::BlockChainInfo>(
            "blockchain",
            |m: &MetricsInfo| { &m.blockchain },
            |m: &mut MetricsInfo| { &mut m.blockchain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, metrics_info::NetInfo>(
            "net",
            |m: &MetricsInfo| { &m.net },
            |m: &mut MetricsInfo| { &mut m.net },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MetricsInfo>(
            "MetricsInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MetricsInfo {
    const NAME: &'static str = "MetricsInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.interval = is.read_int64()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.node)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.blockchain)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.net)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.interval != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.interval);
        }
        if let Some(v) = self.node.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.blockchain.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.net.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.interval != 0 {
            os.write_int64(1, self.interval)?;
        }
        if let Some(v) = self.node.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.blockchain.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.net.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MetricsInfo {
        MetricsInfo::new()
    }

    fn clear(&mut self) {
        self.interval = 0;
        self.node.clear();
        self.blockchain.clear();
        self.net.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MetricsInfo {
        static instance: MetricsInfo = MetricsInfo {
            interval: 0,
            node: ::protobuf::MessageField::none(),
            blockchain: ::protobuf::MessageField::none(),
            net: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MetricsInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MetricsInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MetricsInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetricsInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MetricsInfo`
pub mod metrics_info {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:protocol.MetricsInfo.NodeInfo)
    pub struct NodeInfo {
        // message fields
        // @@protoc_insertion_point(field:protocol.MetricsInfo.NodeInfo.ip)
        pub ip: ::std::string::String,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.NodeInfo.nodeType)
        pub nodeType: i32,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.NodeInfo.version)
        pub version: ::std::string::String,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.NodeInfo.backupStatus)
        pub backupStatus: i32,
        // special fields
        // @@protoc_insertion_point(special_field:protocol.MetricsInfo.NodeInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NodeInfo {
        fn default() -> &'a NodeInfo {
            <NodeInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl NodeInfo {
        pub fn new() -> NodeInfo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "ip",
                |m: &NodeInfo| { &m.ip },
                |m: &mut NodeInfo| { &mut m.ip },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "nodeType",
                |m: &NodeInfo| { &m.nodeType },
                |m: &mut NodeInfo| { &mut m.nodeType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "version",
                |m: &NodeInfo| { &m.version },
                |m: &mut NodeInfo| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "backupStatus",
                |m: &NodeInfo| { &m.backupStatus },
                |m: &mut NodeInfo| { &mut m.backupStatus },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeInfo>(
                "MetricsInfo.NodeInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for NodeInfo {
        const NAME: &'static str = "NodeInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.ip = is.read_string()?;
                    },
                    16 => {
                        self.nodeType = is.read_int32()?;
                    },
                    26 => {
                        self.version = is.read_string()?;
                    },
                    32 => {
                        self.backupStatus = is.read_int32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.ip.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.ip);
            }
            if self.nodeType != 0 {
                my_size += ::protobuf::rt::int32_size(2, self.nodeType);
            }
            if !self.version.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.version);
            }
            if self.backupStatus != 0 {
                my_size += ::protobuf::rt::int32_size(4, self.backupStatus);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.ip.is_empty() {
                os.write_string(1, &self.ip)?;
            }
            if self.nodeType != 0 {
                os.write_int32(2, self.nodeType)?;
            }
            if !self.version.is_empty() {
                os.write_string(3, &self.version)?;
            }
            if self.backupStatus != 0 {
                os.write_int32(4, self.backupStatus)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NodeInfo {
            NodeInfo::new()
        }

        fn clear(&mut self) {
            self.ip.clear();
            self.nodeType = 0;
            self.version.clear();
            self.backupStatus = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NodeInfo {
            static instance: NodeInfo = NodeInfo {
                ip: ::std::string::String::new(),
                nodeType: 0,
                version: ::std::string::String::new(),
                backupStatus: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for NodeInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MetricsInfo.NodeInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for NodeInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for NodeInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:protocol.MetricsInfo.BlockChainInfo)
    pub struct BlockChainInfo {
        // message fields
        // @@protoc_insertion_point(field:protocol.MetricsInfo.BlockChainInfo.headBlockNum)
        pub headBlockNum: i64,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.BlockChainInfo.headBlockTimestamp)
        pub headBlockTimestamp: i64,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.BlockChainInfo.headBlockHash)
        pub headBlockHash: ::std::string::String,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.BlockChainInfo.forkCount)
        pub forkCount: i32,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.BlockChainInfo.failForkCount)
        pub failForkCount: i32,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.BlockChainInfo.blockProcessTime)
        pub blockProcessTime: ::protobuf::MessageField<RateInfo>,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.BlockChainInfo.tps)
        pub tps: ::protobuf::MessageField<RateInfo>,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.BlockChainInfo.transactionCacheSize)
        pub transactionCacheSize: i32,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.BlockChainInfo.missedTransaction)
        pub missedTransaction: ::protobuf::MessageField<RateInfo>,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.BlockChainInfo.witnesses)
        pub witnesses: ::std::vec::Vec<block_chain_info::Witness>,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.BlockChainInfo.failProcessBlockNum)
        pub failProcessBlockNum: i64,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.BlockChainInfo.failProcessBlockReason)
        pub failProcessBlockReason: ::std::string::String,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.BlockChainInfo.dupWitness)
        pub dupWitness: ::std::vec::Vec<block_chain_info::DupWitness>,
        // special fields
        // @@protoc_insertion_point(special_field:protocol.MetricsInfo.BlockChainInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BlockChainInfo {
        fn default() -> &'a BlockChainInfo {
            <BlockChainInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl BlockChainInfo {
        pub fn new() -> BlockChainInfo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(13);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "headBlockNum",
                |m: &BlockChainInfo| { &m.headBlockNum },
                |m: &mut BlockChainInfo| { &mut m.headBlockNum },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "headBlockTimestamp",
                |m: &BlockChainInfo| { &m.headBlockTimestamp },
                |m: &mut BlockChainInfo| { &mut m.headBlockTimestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "headBlockHash",
                |m: &BlockChainInfo| { &m.headBlockHash },
                |m: &mut BlockChainInfo| { &mut m.headBlockHash },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "forkCount",
                |m: &BlockChainInfo| { &m.forkCount },
                |m: &mut BlockChainInfo| { &mut m.forkCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "failForkCount",
                |m: &BlockChainInfo| { &m.failForkCount },
                |m: &mut BlockChainInfo| { &mut m.failForkCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RateInfo>(
                "blockProcessTime",
                |m: &BlockChainInfo| { &m.blockProcessTime },
                |m: &mut BlockChainInfo| { &mut m.blockProcessTime },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RateInfo>(
                "tps",
                |m: &BlockChainInfo| { &m.tps },
                |m: &mut BlockChainInfo| { &mut m.tps },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "transactionCacheSize",
                |m: &BlockChainInfo| { &m.transactionCacheSize },
                |m: &mut BlockChainInfo| { &mut m.transactionCacheSize },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RateInfo>(
                "missedTransaction",
                |m: &BlockChainInfo| { &m.missedTransaction },
                |m: &mut BlockChainInfo| { &mut m.missedTransaction },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "witnesses",
                |m: &BlockChainInfo| { &m.witnesses },
                |m: &mut BlockChainInfo| { &mut m.witnesses },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "failProcessBlockNum",
                |m: &BlockChainInfo| { &m.failProcessBlockNum },
                |m: &mut BlockChainInfo| { &mut m.failProcessBlockNum },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "failProcessBlockReason",
                |m: &BlockChainInfo| { &m.failProcessBlockReason },
                |m: &mut BlockChainInfo| { &mut m.failProcessBlockReason },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "dupWitness",
                |m: &BlockChainInfo| { &m.dupWitness },
                |m: &mut BlockChainInfo| { &mut m.dupWitness },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockChainInfo>(
                "MetricsInfo.BlockChainInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BlockChainInfo {
        const NAME: &'static str = "BlockChainInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.headBlockNum = is.read_int64()?;
                    },
                    16 => {
                        self.headBlockTimestamp = is.read_int64()?;
                    },
                    26 => {
                        self.headBlockHash = is.read_string()?;
                    },
                    32 => {
                        self.forkCount = is.read_int32()?;
                    },
                    40 => {
                        self.failForkCount = is.read_int32()?;
                    },
                    50 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.blockProcessTime)?;
                    },
                    58 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.tps)?;
                    },
                    64 => {
                        self.transactionCacheSize = is.read_int32()?;
                    },
                    74 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.missedTransaction)?;
                    },
                    82 => {
                        self.witnesses.push(is.read_message()?);
                    },
                    88 => {
                        self.failProcessBlockNum = is.read_int64()?;
                    },
                    98 => {
                        self.failProcessBlockReason = is.read_string()?;
                    },
                    106 => {
                        self.dupWitness.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.headBlockNum != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.headBlockNum);
            }
            if self.headBlockTimestamp != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.headBlockTimestamp);
            }
            if !self.headBlockHash.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.headBlockHash);
            }
            if self.forkCount != 0 {
                my_size += ::protobuf::rt::int32_size(4, self.forkCount);
            }
            if self.failForkCount != 0 {
                my_size += ::protobuf::rt::int32_size(5, self.failForkCount);
            }
            if let Some(v) = self.blockProcessTime.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.tps.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.transactionCacheSize != 0 {
                my_size += ::protobuf::rt::int32_size(8, self.transactionCacheSize);
            }
            if let Some(v) = self.missedTransaction.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.witnesses {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if self.failProcessBlockNum != 0 {
                my_size += ::protobuf::rt::int64_size(11, self.failProcessBlockNum);
            }
            if !self.failProcessBlockReason.is_empty() {
                my_size += ::protobuf::rt::string_size(12, &self.failProcessBlockReason);
            }
            for value in &self.dupWitness {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.headBlockNum != 0 {
                os.write_int64(1, self.headBlockNum)?;
            }
            if self.headBlockTimestamp != 0 {
                os.write_int64(2, self.headBlockTimestamp)?;
            }
            if !self.headBlockHash.is_empty() {
                os.write_string(3, &self.headBlockHash)?;
            }
            if self.forkCount != 0 {
                os.write_int32(4, self.forkCount)?;
            }
            if self.failForkCount != 0 {
                os.write_int32(5, self.failForkCount)?;
            }
            if let Some(v) = self.blockProcessTime.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            if let Some(v) = self.tps.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            }
            if self.transactionCacheSize != 0 {
                os.write_int32(8, self.transactionCacheSize)?;
            }
            if let Some(v) = self.missedTransaction.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
            }
            for v in &self.witnesses {
                ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
            };
            if self.failProcessBlockNum != 0 {
                os.write_int64(11, self.failProcessBlockNum)?;
            }
            if !self.failProcessBlockReason.is_empty() {
                os.write_string(12, &self.failProcessBlockReason)?;
            }
            for v in &self.dupWitness {
                ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BlockChainInfo {
            BlockChainInfo::new()
        }

        fn clear(&mut self) {
            self.headBlockNum = 0;
            self.headBlockTimestamp = 0;
            self.headBlockHash.clear();
            self.forkCount = 0;
            self.failForkCount = 0;
            self.blockProcessTime.clear();
            self.tps.clear();
            self.transactionCacheSize = 0;
            self.missedTransaction.clear();
            self.witnesses.clear();
            self.failProcessBlockNum = 0;
            self.failProcessBlockReason.clear();
            self.dupWitness.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BlockChainInfo {
            static instance: BlockChainInfo = BlockChainInfo {
                headBlockNum: 0,
                headBlockTimestamp: 0,
                headBlockHash: ::std::string::String::new(),
                forkCount: 0,
                failForkCount: 0,
                blockProcessTime: ::protobuf::MessageField::none(),
                tps: ::protobuf::MessageField::none(),
                transactionCacheSize: 0,
                missedTransaction: ::protobuf::MessageField::none(),
                witnesses: ::std::vec::Vec::new(),
                failProcessBlockNum: 0,
                failProcessBlockReason: ::std::string::String::new(),
                dupWitness: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BlockChainInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MetricsInfo.BlockChainInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BlockChainInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BlockChainInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `BlockChainInfo`
    pub mod block_chain_info {
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:protocol.MetricsInfo.BlockChainInfo.Witness)
        pub struct Witness {
            // message fields
            // @@protoc_insertion_point(field:protocol.MetricsInfo.BlockChainInfo.Witness.address)
            pub address: ::std::string::String,
            // @@protoc_insertion_point(field:protocol.MetricsInfo.BlockChainInfo.Witness.version)
            pub version: i32,
            // special fields
            // @@protoc_insertion_point(special_field:protocol.MetricsInfo.BlockChainInfo.Witness.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Witness {
            fn default() -> &'a Witness {
                <Witness as ::protobuf::Message>::default_instance()
            }
        }

        impl Witness {
            pub fn new() -> Witness {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "address",
                    |m: &Witness| { &m.address },
                    |m: &mut Witness| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "version",
                    |m: &Witness| { &m.version },
                    |m: &mut Witness| { &mut m.version },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Witness>(
                    "MetricsInfo.BlockChainInfo.Witness",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Witness {
            const NAME: &'static str = "Witness";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.address = is.read_string()?;
                        },
                        16 => {
                            self.version = is.read_int32()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.address.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.address);
                }
                if self.version != 0 {
                    my_size += ::protobuf::rt::int32_size(2, self.version);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.address.is_empty() {
                    os.write_string(1, &self.address)?;
                }
                if self.version != 0 {
                    os.write_int32(2, self.version)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Witness {
                Witness::new()
            }

            fn clear(&mut self) {
                self.address.clear();
                self.version = 0;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Witness {
                static instance: Witness = Witness {
                    address: ::std::string::String::new(),
                    version: 0,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Witness {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("MetricsInfo.BlockChainInfo.Witness").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Witness {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Witness {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:protocol.MetricsInfo.BlockChainInfo.DupWitness)
        pub struct DupWitness {
            // message fields
            // @@protoc_insertion_point(field:protocol.MetricsInfo.BlockChainInfo.DupWitness.address)
            pub address: ::std::string::String,
            // @@protoc_insertion_point(field:protocol.MetricsInfo.BlockChainInfo.DupWitness.blockNum)
            pub blockNum: i64,
            // @@protoc_insertion_point(field:protocol.MetricsInfo.BlockChainInfo.DupWitness.count)
            pub count: i32,
            // special fields
            // @@protoc_insertion_point(special_field:protocol.MetricsInfo.BlockChainInfo.DupWitness.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a DupWitness {
            fn default() -> &'a DupWitness {
                <DupWitness as ::protobuf::Message>::default_instance()
            }
        }

        impl DupWitness {
            pub fn new() -> DupWitness {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "address",
                    |m: &DupWitness| { &m.address },
                    |m: &mut DupWitness| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "blockNum",
                    |m: &DupWitness| { &m.blockNum },
                    |m: &mut DupWitness| { &mut m.blockNum },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "count",
                    |m: &DupWitness| { &m.count },
                    |m: &mut DupWitness| { &mut m.count },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DupWitness>(
                    "MetricsInfo.BlockChainInfo.DupWitness",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for DupWitness {
            const NAME: &'static str = "DupWitness";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.address = is.read_string()?;
                        },
                        16 => {
                            self.blockNum = is.read_int64()?;
                        },
                        24 => {
                            self.count = is.read_int32()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.address.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.address);
                }
                if self.blockNum != 0 {
                    my_size += ::protobuf::rt::int64_size(2, self.blockNum);
                }
                if self.count != 0 {
                    my_size += ::protobuf::rt::int32_size(3, self.count);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.address.is_empty() {
                    os.write_string(1, &self.address)?;
                }
                if self.blockNum != 0 {
                    os.write_int64(2, self.blockNum)?;
                }
                if self.count != 0 {
                    os.write_int32(3, self.count)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> DupWitness {
                DupWitness::new()
            }

            fn clear(&mut self) {
                self.address.clear();
                self.blockNum = 0;
                self.count = 0;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static DupWitness {
                static instance: DupWitness = DupWitness {
                    address: ::std::string::String::new(),
                    blockNum: 0,
                    count: 0,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for DupWitness {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("MetricsInfo.BlockChainInfo.DupWitness").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for DupWitness {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for DupWitness {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:protocol.MetricsInfo.RateInfo)
    pub struct RateInfo {
        // message fields
        // @@protoc_insertion_point(field:protocol.MetricsInfo.RateInfo.count)
        pub count: i64,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.RateInfo.meanRate)
        pub meanRate: f64,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.RateInfo.oneMinuteRate)
        pub oneMinuteRate: f64,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.RateInfo.fiveMinuteRate)
        pub fiveMinuteRate: f64,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.RateInfo.fifteenMinuteRate)
        pub fifteenMinuteRate: f64,
        // special fields
        // @@protoc_insertion_point(special_field:protocol.MetricsInfo.RateInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RateInfo {
        fn default() -> &'a RateInfo {
            <RateInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl RateInfo {
        pub fn new() -> RateInfo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "count",
                |m: &RateInfo| { &m.count },
                |m: &mut RateInfo| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "meanRate",
                |m: &RateInfo| { &m.meanRate },
                |m: &mut RateInfo| { &mut m.meanRate },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "oneMinuteRate",
                |m: &RateInfo| { &m.oneMinuteRate },
                |m: &mut RateInfo| { &mut m.oneMinuteRate },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "fiveMinuteRate",
                |m: &RateInfo| { &m.fiveMinuteRate },
                |m: &mut RateInfo| { &mut m.fiveMinuteRate },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "fifteenMinuteRate",
                |m: &RateInfo| { &m.fifteenMinuteRate },
                |m: &mut RateInfo| { &mut m.fifteenMinuteRate },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RateInfo>(
                "MetricsInfo.RateInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RateInfo {
        const NAME: &'static str = "RateInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.count = is.read_int64()?;
                    },
                    17 => {
                        self.meanRate = is.read_double()?;
                    },
                    25 => {
                        self.oneMinuteRate = is.read_double()?;
                    },
                    33 => {
                        self.fiveMinuteRate = is.read_double()?;
                    },
                    41 => {
                        self.fifteenMinuteRate = is.read_double()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.count != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.count);
            }
            if self.meanRate != 0. {
                my_size += 1 + 8;
            }
            if self.oneMinuteRate != 0. {
                my_size += 1 + 8;
            }
            if self.fiveMinuteRate != 0. {
                my_size += 1 + 8;
            }
            if self.fifteenMinuteRate != 0. {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.count != 0 {
                os.write_int64(1, self.count)?;
            }
            if self.meanRate != 0. {
                os.write_double(2, self.meanRate)?;
            }
            if self.oneMinuteRate != 0. {
                os.write_double(3, self.oneMinuteRate)?;
            }
            if self.fiveMinuteRate != 0. {
                os.write_double(4, self.fiveMinuteRate)?;
            }
            if self.fifteenMinuteRate != 0. {
                os.write_double(5, self.fifteenMinuteRate)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RateInfo {
            RateInfo::new()
        }

        fn clear(&mut self) {
            self.count = 0;
            self.meanRate = 0.;
            self.oneMinuteRate = 0.;
            self.fiveMinuteRate = 0.;
            self.fifteenMinuteRate = 0.;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RateInfo {
            static instance: RateInfo = RateInfo {
                count: 0,
                meanRate: 0.,
                oneMinuteRate: 0.,
                fiveMinuteRate: 0.,
                fifteenMinuteRate: 0.,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RateInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MetricsInfo.RateInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RateInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RateInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:protocol.MetricsInfo.NetInfo)
    pub struct NetInfo {
        // message fields
        // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.errorProtoCount)
        pub errorProtoCount: i32,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.api)
        pub api: ::protobuf::MessageField<net_info::ApiInfo>,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.connectionCount)
        pub connectionCount: i32,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.validConnectionCount)
        pub validConnectionCount: i32,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.tcpInTraffic)
        pub tcpInTraffic: ::protobuf::MessageField<RateInfo>,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.tcpOutTraffic)
        pub tcpOutTraffic: ::protobuf::MessageField<RateInfo>,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.disconnectionCount)
        pub disconnectionCount: i32,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.disconnectionDetail)
        pub disconnectionDetail: ::std::vec::Vec<net_info::DisconnectionDetailInfo>,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.udpInTraffic)
        pub udpInTraffic: ::protobuf::MessageField<RateInfo>,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.udpOutTraffic)
        pub udpOutTraffic: ::protobuf::MessageField<RateInfo>,
        // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.latency)
        pub latency: ::protobuf::MessageField<net_info::LatencyInfo>,
        // special fields
        // @@protoc_insertion_point(special_field:protocol.MetricsInfo.NetInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NetInfo {
        fn default() -> &'a NetInfo {
            <NetInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl NetInfo {
        pub fn new() -> NetInfo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(11);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "errorProtoCount",
                |m: &NetInfo| { &m.errorProtoCount },
                |m: &mut NetInfo| { &mut m.errorProtoCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, net_info::ApiInfo>(
                "api",
                |m: &NetInfo| { &m.api },
                |m: &mut NetInfo| { &mut m.api },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "connectionCount",
                |m: &NetInfo| { &m.connectionCount },
                |m: &mut NetInfo| { &mut m.connectionCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "validConnectionCount",
                |m: &NetInfo| { &m.validConnectionCount },
                |m: &mut NetInfo| { &mut m.validConnectionCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RateInfo>(
                "tcpInTraffic",
                |m: &NetInfo| { &m.tcpInTraffic },
                |m: &mut NetInfo| { &mut m.tcpInTraffic },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RateInfo>(
                "tcpOutTraffic",
                |m: &NetInfo| { &m.tcpOutTraffic },
                |m: &mut NetInfo| { &mut m.tcpOutTraffic },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "disconnectionCount",
                |m: &NetInfo| { &m.disconnectionCount },
                |m: &mut NetInfo| { &mut m.disconnectionCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "disconnectionDetail",
                |m: &NetInfo| { &m.disconnectionDetail },
                |m: &mut NetInfo| { &mut m.disconnectionDetail },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RateInfo>(
                "udpInTraffic",
                |m: &NetInfo| { &m.udpInTraffic },
                |m: &mut NetInfo| { &mut m.udpInTraffic },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RateInfo>(
                "udpOutTraffic",
                |m: &NetInfo| { &m.udpOutTraffic },
                |m: &mut NetInfo| { &mut m.udpOutTraffic },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, net_info::LatencyInfo>(
                "latency",
                |m: &NetInfo| { &m.latency },
                |m: &mut NetInfo| { &mut m.latency },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NetInfo>(
                "MetricsInfo.NetInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for NetInfo {
        const NAME: &'static str = "NetInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.errorProtoCount = is.read_int32()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.api)?;
                    },
                    24 => {
                        self.connectionCount = is.read_int32()?;
                    },
                    32 => {
                        self.validConnectionCount = is.read_int32()?;
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.tcpInTraffic)?;
                    },
                    50 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.tcpOutTraffic)?;
                    },
                    56 => {
                        self.disconnectionCount = is.read_int32()?;
                    },
                    66 => {
                        self.disconnectionDetail.push(is.read_message()?);
                    },
                    74 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.udpInTraffic)?;
                    },
                    82 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.udpOutTraffic)?;
                    },
                    90 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.latency)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.errorProtoCount != 0 {
                my_size += ::protobuf::rt::int32_size(1, self.errorProtoCount);
            }
            if let Some(v) = self.api.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.connectionCount != 0 {
                my_size += ::protobuf::rt::int32_size(3, self.connectionCount);
            }
            if self.validConnectionCount != 0 {
                my_size += ::protobuf::rt::int32_size(4, self.validConnectionCount);
            }
            if let Some(v) = self.tcpInTraffic.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.tcpOutTraffic.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.disconnectionCount != 0 {
                my_size += ::protobuf::rt::int32_size(7, self.disconnectionCount);
            }
            for value in &self.disconnectionDetail {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.udpInTraffic.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.udpOutTraffic.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.latency.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.errorProtoCount != 0 {
                os.write_int32(1, self.errorProtoCount)?;
            }
            if let Some(v) = self.api.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if self.connectionCount != 0 {
                os.write_int32(3, self.connectionCount)?;
            }
            if self.validConnectionCount != 0 {
                os.write_int32(4, self.validConnectionCount)?;
            }
            if let Some(v) = self.tcpInTraffic.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if let Some(v) = self.tcpOutTraffic.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            if self.disconnectionCount != 0 {
                os.write_int32(7, self.disconnectionCount)?;
            }
            for v in &self.disconnectionDetail {
                ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
            };
            if let Some(v) = self.udpInTraffic.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
            }
            if let Some(v) = self.udpOutTraffic.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
            }
            if let Some(v) = self.latency.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NetInfo {
            NetInfo::new()
        }

        fn clear(&mut self) {
            self.errorProtoCount = 0;
            self.api.clear();
            self.connectionCount = 0;
            self.validConnectionCount = 0;
            self.tcpInTraffic.clear();
            self.tcpOutTraffic.clear();
            self.disconnectionCount = 0;
            self.disconnectionDetail.clear();
            self.udpInTraffic.clear();
            self.udpOutTraffic.clear();
            self.latency.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NetInfo {
            static instance: NetInfo = NetInfo {
                errorProtoCount: 0,
                api: ::protobuf::MessageField::none(),
                connectionCount: 0,
                validConnectionCount: 0,
                tcpInTraffic: ::protobuf::MessageField::none(),
                tcpOutTraffic: ::protobuf::MessageField::none(),
                disconnectionCount: 0,
                disconnectionDetail: ::std::vec::Vec::new(),
                udpInTraffic: ::protobuf::MessageField::none(),
                udpOutTraffic: ::protobuf::MessageField::none(),
                latency: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for NetInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MetricsInfo.NetInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for NetInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for NetInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `NetInfo`
    pub mod net_info {
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:protocol.MetricsInfo.NetInfo.ApiInfo)
        pub struct ApiInfo {
            // message fields
            // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.ApiInfo.qps)
            pub qps: ::protobuf::MessageField<super::RateInfo>,
            // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.ApiInfo.failQps)
            pub failQps: ::protobuf::MessageField<super::RateInfo>,
            // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.ApiInfo.outTraffic)
            pub outTraffic: ::protobuf::MessageField<super::RateInfo>,
            // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.ApiInfo.detail)
            pub detail: ::std::vec::Vec<api_info::ApiDetailInfo>,
            // special fields
            // @@protoc_insertion_point(special_field:protocol.MetricsInfo.NetInfo.ApiInfo.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ApiInfo {
            fn default() -> &'a ApiInfo {
                <ApiInfo as ::protobuf::Message>::default_instance()
            }
        }

        impl ApiInfo {
            pub fn new() -> ApiInfo {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::RateInfo>(
                    "qps",
                    |m: &ApiInfo| { &m.qps },
                    |m: &mut ApiInfo| { &mut m.qps },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::RateInfo>(
                    "failQps",
                    |m: &ApiInfo| { &m.failQps },
                    |m: &mut ApiInfo| { &mut m.failQps },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::RateInfo>(
                    "outTraffic",
                    |m: &ApiInfo| { &m.outTraffic },
                    |m: &mut ApiInfo| { &mut m.outTraffic },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "detail",
                    |m: &ApiInfo| { &m.detail },
                    |m: &mut ApiInfo| { &mut m.detail },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ApiInfo>(
                    "MetricsInfo.NetInfo.ApiInfo",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ApiInfo {
            const NAME: &'static str = "ApiInfo";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.qps)?;
                        },
                        18 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.failQps)?;
                        },
                        26 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.outTraffic)?;
                        },
                        34 => {
                            self.detail.push(is.read_message()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.qps.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if let Some(v) = self.failQps.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if let Some(v) = self.outTraffic.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                for value in &self.detail {
                    let len = value.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.qps.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                }
                if let Some(v) = self.failQps.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                }
                if let Some(v) = self.outTraffic.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                }
                for v in &self.detail {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ApiInfo {
                ApiInfo::new()
            }

            fn clear(&mut self) {
                self.qps.clear();
                self.failQps.clear();
                self.outTraffic.clear();
                self.detail.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ApiInfo {
                static instance: ApiInfo = ApiInfo {
                    qps: ::protobuf::MessageField::none(),
                    failQps: ::protobuf::MessageField::none(),
                    outTraffic: ::protobuf::MessageField::none(),
                    detail: ::std::vec::Vec::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ApiInfo {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("MetricsInfo.NetInfo.ApiInfo").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ApiInfo {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ApiInfo {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `ApiInfo`
        pub mod api_info {
            #[derive(PartialEq,Clone,Default,Debug)]
            // @@protoc_insertion_point(message:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo)
            pub struct ApiDetailInfo {
                // message fields
                // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.name)
                pub name: ::std::string::String,
                // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.qps)
                pub qps: ::protobuf::MessageField<super::super::RateInfo>,
                // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.failQps)
                pub failQps: ::protobuf::MessageField<super::super::RateInfo>,
                // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.outTraffic)
                pub outTraffic: ::protobuf::MessageField<super::super::RateInfo>,
                // special fields
                // @@protoc_insertion_point(special_field:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a ApiDetailInfo {
                fn default() -> &'a ApiDetailInfo {
                    <ApiDetailInfo as ::protobuf::Message>::default_instance()
                }
            }

            impl ApiDetailInfo {
                pub fn new() -> ApiDetailInfo {
                    ::std::default::Default::default()
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(4);
                    let mut oneofs = ::std::vec::Vec::with_capacity(0);
                    fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                        "name",
                        |m: &ApiDetailInfo| { &m.name },
                        |m: &mut ApiDetailInfo| { &mut m.name },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::RateInfo>(
                        "qps",
                        |m: &ApiDetailInfo| { &m.qps },
                        |m: &mut ApiDetailInfo| { &mut m.qps },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::RateInfo>(
                        "failQps",
                        |m: &ApiDetailInfo| { &m.failQps },
                        |m: &mut ApiDetailInfo| { &mut m.failQps },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::RateInfo>(
                        "outTraffic",
                        |m: &ApiDetailInfo| { &m.outTraffic },
                        |m: &mut ApiDetailInfo| { &mut m.outTraffic },
                    ));
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ApiDetailInfo>(
                        "MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for ApiDetailInfo {
                const NAME: &'static str = "ApiDetailInfo";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => {
                                self.name = is.read_string()?;
                            },
                            18 => {
                                ::protobuf::rt::read_singular_message_into_field(is, &mut self.qps)?;
                            },
                            26 => {
                                ::protobuf::rt::read_singular_message_into_field(is, &mut self.failQps)?;
                            },
                            34 => {
                                ::protobuf::rt::read_singular_message_into_field(is, &mut self.outTraffic)?;
                            },
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if !self.name.is_empty() {
                        my_size += ::protobuf::rt::string_size(1, &self.name);
                    }
                    if let Some(v) = self.qps.as_ref() {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    }
                    if let Some(v) = self.failQps.as_ref() {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    }
                    if let Some(v) = self.outTraffic.as_ref() {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    }
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    if !self.name.is_empty() {
                        os.write_string(1, &self.name)?;
                    }
                    if let Some(v) = self.qps.as_ref() {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    }
                    if let Some(v) = self.failQps.as_ref() {
                        ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                    }
                    if let Some(v) = self.outTraffic.as_ref() {
                        ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> ApiDetailInfo {
                    ApiDetailInfo::new()
                }

                fn clear(&mut self) {
                    self.name.clear();
                    self.qps.clear();
                    self.failQps.clear();
                    self.outTraffic.clear();
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static ApiDetailInfo {
                    static instance: ApiDetailInfo = ApiDetailInfo {
                        name: ::std::string::String::new(),
                        qps: ::protobuf::MessageField::none(),
                        failQps: ::protobuf::MessageField::none(),
                        outTraffic: ::protobuf::MessageField::none(),
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for ApiDetailInfo {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for ApiDetailInfo {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for ApiDetailInfo {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }
        }

        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:protocol.MetricsInfo.NetInfo.DisconnectionDetailInfo)
        pub struct DisconnectionDetailInfo {
            // message fields
            // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.DisconnectionDetailInfo.reason)
            pub reason: ::std::string::String,
            // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.DisconnectionDetailInfo.count)
            pub count: i32,
            // special fields
            // @@protoc_insertion_point(special_field:protocol.MetricsInfo.NetInfo.DisconnectionDetailInfo.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a DisconnectionDetailInfo {
            fn default() -> &'a DisconnectionDetailInfo {
                <DisconnectionDetailInfo as ::protobuf::Message>::default_instance()
            }
        }

        impl DisconnectionDetailInfo {
            pub fn new() -> DisconnectionDetailInfo {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "reason",
                    |m: &DisconnectionDetailInfo| { &m.reason },
                    |m: &mut DisconnectionDetailInfo| { &mut m.reason },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "count",
                    |m: &DisconnectionDetailInfo| { &m.count },
                    |m: &mut DisconnectionDetailInfo| { &mut m.count },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DisconnectionDetailInfo>(
                    "MetricsInfo.NetInfo.DisconnectionDetailInfo",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for DisconnectionDetailInfo {
            const NAME: &'static str = "DisconnectionDetailInfo";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.reason = is.read_string()?;
                        },
                        16 => {
                            self.count = is.read_int32()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.reason.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.reason);
                }
                if self.count != 0 {
                    my_size += ::protobuf::rt::int32_size(2, self.count);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.reason.is_empty() {
                    os.write_string(1, &self.reason)?;
                }
                if self.count != 0 {
                    os.write_int32(2, self.count)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> DisconnectionDetailInfo {
                DisconnectionDetailInfo::new()
            }

            fn clear(&mut self) {
                self.reason.clear();
                self.count = 0;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static DisconnectionDetailInfo {
                static instance: DisconnectionDetailInfo = DisconnectionDetailInfo {
                    reason: ::std::string::String::new(),
                    count: 0,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for DisconnectionDetailInfo {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("MetricsInfo.NetInfo.DisconnectionDetailInfo").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for DisconnectionDetailInfo {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for DisconnectionDetailInfo {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:protocol.MetricsInfo.NetInfo.LatencyInfo)
        pub struct LatencyInfo {
            // message fields
            // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.LatencyInfo.top99)
            pub top99: i32,
            // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.LatencyInfo.top95)
            pub top95: i32,
            // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.LatencyInfo.top75)
            pub top75: i32,
            // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.LatencyInfo.totalCount)
            pub totalCount: i32,
            // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.LatencyInfo.delay1S)
            pub delay1S: i32,
            // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.LatencyInfo.delay2S)
            pub delay2S: i32,
            // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.LatencyInfo.delay3S)
            pub delay3S: i32,
            // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.LatencyInfo.detail)
            pub detail: ::std::vec::Vec<latency_info::LatencyDetailInfo>,
            // special fields
            // @@protoc_insertion_point(special_field:protocol.MetricsInfo.NetInfo.LatencyInfo.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a LatencyInfo {
            fn default() -> &'a LatencyInfo {
                <LatencyInfo as ::protobuf::Message>::default_instance()
            }
        }

        impl LatencyInfo {
            pub fn new() -> LatencyInfo {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(8);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "top99",
                    |m: &LatencyInfo| { &m.top99 },
                    |m: &mut LatencyInfo| { &mut m.top99 },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "top95",
                    |m: &LatencyInfo| { &m.top95 },
                    |m: &mut LatencyInfo| { &mut m.top95 },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "top75",
                    |m: &LatencyInfo| { &m.top75 },
                    |m: &mut LatencyInfo| { &mut m.top75 },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "totalCount",
                    |m: &LatencyInfo| { &m.totalCount },
                    |m: &mut LatencyInfo| { &mut m.totalCount },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "delay1S",
                    |m: &LatencyInfo| { &m.delay1S },
                    |m: &mut LatencyInfo| { &mut m.delay1S },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "delay2S",
                    |m: &LatencyInfo| { &m.delay2S },
                    |m: &mut LatencyInfo| { &mut m.delay2S },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "delay3S",
                    |m: &LatencyInfo| { &m.delay3S },
                    |m: &mut LatencyInfo| { &mut m.delay3S },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "detail",
                    |m: &LatencyInfo| { &m.detail },
                    |m: &mut LatencyInfo| { &mut m.detail },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LatencyInfo>(
                    "MetricsInfo.NetInfo.LatencyInfo",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for LatencyInfo {
            const NAME: &'static str = "LatencyInfo";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.top99 = is.read_int32()?;
                        },
                        16 => {
                            self.top95 = is.read_int32()?;
                        },
                        24 => {
                            self.top75 = is.read_int32()?;
                        },
                        32 => {
                            self.totalCount = is.read_int32()?;
                        },
                        40 => {
                            self.delay1S = is.read_int32()?;
                        },
                        48 => {
                            self.delay2S = is.read_int32()?;
                        },
                        56 => {
                            self.delay3S = is.read_int32()?;
                        },
                        66 => {
                            self.detail.push(is.read_message()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.top99 != 0 {
                    my_size += ::protobuf::rt::int32_size(1, self.top99);
                }
                if self.top95 != 0 {
                    my_size += ::protobuf::rt::int32_size(2, self.top95);
                }
                if self.top75 != 0 {
                    my_size += ::protobuf::rt::int32_size(3, self.top75);
                }
                if self.totalCount != 0 {
                    my_size += ::protobuf::rt::int32_size(4, self.totalCount);
                }
                if self.delay1S != 0 {
                    my_size += ::protobuf::rt::int32_size(5, self.delay1S);
                }
                if self.delay2S != 0 {
                    my_size += ::protobuf::rt::int32_size(6, self.delay2S);
                }
                if self.delay3S != 0 {
                    my_size += ::protobuf::rt::int32_size(7, self.delay3S);
                }
                for value in &self.detail {
                    let len = value.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.top99 != 0 {
                    os.write_int32(1, self.top99)?;
                }
                if self.top95 != 0 {
                    os.write_int32(2, self.top95)?;
                }
                if self.top75 != 0 {
                    os.write_int32(3, self.top75)?;
                }
                if self.totalCount != 0 {
                    os.write_int32(4, self.totalCount)?;
                }
                if self.delay1S != 0 {
                    os.write_int32(5, self.delay1S)?;
                }
                if self.delay2S != 0 {
                    os.write_int32(6, self.delay2S)?;
                }
                if self.delay3S != 0 {
                    os.write_int32(7, self.delay3S)?;
                }
                for v in &self.detail {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> LatencyInfo {
                LatencyInfo::new()
            }

            fn clear(&mut self) {
                self.top99 = 0;
                self.top95 = 0;
                self.top75 = 0;
                self.totalCount = 0;
                self.delay1S = 0;
                self.delay2S = 0;
                self.delay3S = 0;
                self.detail.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static LatencyInfo {
                static instance: LatencyInfo = LatencyInfo {
                    top99: 0,
                    top95: 0,
                    top75: 0,
                    totalCount: 0,
                    delay1S: 0,
                    delay2S: 0,
                    delay3S: 0,
                    detail: ::std::vec::Vec::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for LatencyInfo {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("MetricsInfo.NetInfo.LatencyInfo").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for LatencyInfo {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for LatencyInfo {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `LatencyInfo`
        pub mod latency_info {
            #[derive(PartialEq,Clone,Default,Debug)]
            // @@protoc_insertion_point(message:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo)
            pub struct LatencyDetailInfo {
                // message fields
                // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.witness)
                pub witness: ::std::string::String,
                // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.top99)
                pub top99: i32,
                // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.top95)
                pub top95: i32,
                // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.top75)
                pub top75: i32,
                // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.count)
                pub count: i32,
                // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.delay1S)
                pub delay1S: i32,
                // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.delay2S)
                pub delay2S: i32,
                // @@protoc_insertion_point(field:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.delay3S)
                pub delay3S: i32,
                // special fields
                // @@protoc_insertion_point(special_field:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a LatencyDetailInfo {
                fn default() -> &'a LatencyDetailInfo {
                    <LatencyDetailInfo as ::protobuf::Message>::default_instance()
                }
            }

            impl LatencyDetailInfo {
                pub fn new() -> LatencyDetailInfo {
                    ::std::default::Default::default()
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(8);
                    let mut oneofs = ::std::vec::Vec::with_capacity(0);
                    fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                        "witness",
                        |m: &LatencyDetailInfo| { &m.witness },
                        |m: &mut LatencyDetailInfo| { &mut m.witness },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                        "top99",
                        |m: &LatencyDetailInfo| { &m.top99 },
                        |m: &mut LatencyDetailInfo| { &mut m.top99 },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                        "top95",
                        |m: &LatencyDetailInfo| { &m.top95 },
                        |m: &mut LatencyDetailInfo| { &mut m.top95 },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                        "top75",
                        |m: &LatencyDetailInfo| { &m.top75 },
                        |m: &mut LatencyDetailInfo| { &mut m.top75 },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                        "count",
                        |m: &LatencyDetailInfo| { &m.count },
                        |m: &mut LatencyDetailInfo| { &mut m.count },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                        "delay1S",
                        |m: &LatencyDetailInfo| { &m.delay1S },
                        |m: &mut LatencyDetailInfo| { &mut m.delay1S },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                        "delay2S",
                        |m: &LatencyDetailInfo| { &m.delay2S },
                        |m: &mut LatencyDetailInfo| { &mut m.delay2S },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                        "delay3S",
                        |m: &LatencyDetailInfo| { &m.delay3S },
                        |m: &mut LatencyDetailInfo| { &mut m.delay3S },
                    ));
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LatencyDetailInfo>(
                        "MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for LatencyDetailInfo {
                const NAME: &'static str = "LatencyDetailInfo";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => {
                                self.witness = is.read_string()?;
                            },
                            16 => {
                                self.top99 = is.read_int32()?;
                            },
                            24 => {
                                self.top95 = is.read_int32()?;
                            },
                            32 => {
                                self.top75 = is.read_int32()?;
                            },
                            40 => {
                                self.count = is.read_int32()?;
                            },
                            48 => {
                                self.delay1S = is.read_int32()?;
                            },
                            56 => {
                                self.delay2S = is.read_int32()?;
                            },
                            64 => {
                                self.delay3S = is.read_int32()?;
                            },
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if !self.witness.is_empty() {
                        my_size += ::protobuf::rt::string_size(1, &self.witness);
                    }
                    if self.top99 != 0 {
                        my_size += ::protobuf::rt::int32_size(2, self.top99);
                    }
                    if self.top95 != 0 {
                        my_size += ::protobuf::rt::int32_size(3, self.top95);
                    }
                    if self.top75 != 0 {
                        my_size += ::protobuf::rt::int32_size(4, self.top75);
                    }
                    if self.count != 0 {
                        my_size += ::protobuf::rt::int32_size(5, self.count);
                    }
                    if self.delay1S != 0 {
                        my_size += ::protobuf::rt::int32_size(6, self.delay1S);
                    }
                    if self.delay2S != 0 {
                        my_size += ::protobuf::rt::int32_size(7, self.delay2S);
                    }
                    if self.delay3S != 0 {
                        my_size += ::protobuf::rt::int32_size(8, self.delay3S);
                    }
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    if !self.witness.is_empty() {
                        os.write_string(1, &self.witness)?;
                    }
                    if self.top99 != 0 {
                        os.write_int32(2, self.top99)?;
                    }
                    if self.top95 != 0 {
                        os.write_int32(3, self.top95)?;
                    }
                    if self.top75 != 0 {
                        os.write_int32(4, self.top75)?;
                    }
                    if self.count != 0 {
                        os.write_int32(5, self.count)?;
                    }
                    if self.delay1S != 0 {
                        os.write_int32(6, self.delay1S)?;
                    }
                    if self.delay2S != 0 {
                        os.write_int32(7, self.delay2S)?;
                    }
                    if self.delay3S != 0 {
                        os.write_int32(8, self.delay3S)?;
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> LatencyDetailInfo {
                    LatencyDetailInfo::new()
                }

                fn clear(&mut self) {
                    self.witness.clear();
                    self.top99 = 0;
                    self.top95 = 0;
                    self.top75 = 0;
                    self.count = 0;
                    self.delay1S = 0;
                    self.delay2S = 0;
                    self.delay3S = 0;
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static LatencyDetailInfo {
                    static instance: LatencyDetailInfo = LatencyDetailInfo {
                        witness: ::std::string::String::new(),
                        top99: 0,
                        top95: 0,
                        top75: 0,
                        count: 0,
                        delay1S: 0,
                        delay2S: 0,
                        delay3S: 0,
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for LatencyDetailInfo {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for LatencyDetailInfo {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for LatencyDetailInfo {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.PBFTMessage)
pub struct PBFTMessage {
    // message fields
    // @@protoc_insertion_point(field:protocol.PBFTMessage.raw_data)
    pub raw_data: ::protobuf::MessageField<pbftmessage::Raw>,
    // @@protoc_insertion_point(field:protocol.PBFTMessage.signature)
    pub signature: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.PBFTMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PBFTMessage {
    fn default() -> &'a PBFTMessage {
        <PBFTMessage as ::protobuf::Message>::default_instance()
    }
}

impl PBFTMessage {
    pub fn new() -> PBFTMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, pbftmessage::Raw>(
            "raw_data",
            |m: &PBFTMessage| { &m.raw_data },
            |m: &mut PBFTMessage| { &mut m.raw_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signature",
            |m: &PBFTMessage| { &m.signature },
            |m: &mut PBFTMessage| { &mut m.signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PBFTMessage>(
            "PBFTMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PBFTMessage {
    const NAME: &'static str = "PBFTMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.raw_data)?;
                },
                18 => {
                    self.signature = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.raw_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.raw_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(2, &self.signature)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PBFTMessage {
        PBFTMessage::new()
    }

    fn clear(&mut self) {
        self.raw_data.clear();
        self.signature.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PBFTMessage {
        static instance: PBFTMessage = PBFTMessage {
            raw_data: ::protobuf::MessageField::none(),
            signature: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PBFTMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PBFTMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PBFTMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFTMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PBFTMessage`
pub mod pbftmessage {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:protocol.PBFTMessage.Raw)
    pub struct Raw {
        // message fields
        // @@protoc_insertion_point(field:protocol.PBFTMessage.Raw.msg_type)
        pub msg_type: ::protobuf::EnumOrUnknown<MsgType>,
        // @@protoc_insertion_point(field:protocol.PBFTMessage.Raw.data_type)
        pub data_type: ::protobuf::EnumOrUnknown<DataType>,
        // @@protoc_insertion_point(field:protocol.PBFTMessage.Raw.view_n)
        pub view_n: i64,
        // @@protoc_insertion_point(field:protocol.PBFTMessage.Raw.epoch)
        pub epoch: i64,
        // @@protoc_insertion_point(field:protocol.PBFTMessage.Raw.data)
        pub data: ::std::vec::Vec<u8>,
        // special fields
        // @@protoc_insertion_point(special_field:protocol.PBFTMessage.Raw.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Raw {
        fn default() -> &'a Raw {
            <Raw as ::protobuf::Message>::default_instance()
        }
    }

    impl Raw {
        pub fn new() -> Raw {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "msg_type",
                |m: &Raw| { &m.msg_type },
                |m: &mut Raw| { &mut m.msg_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data_type",
                |m: &Raw| { &m.data_type },
                |m: &mut Raw| { &mut m.data_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "view_n",
                |m: &Raw| { &m.view_n },
                |m: &mut Raw| { &mut m.view_n },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "epoch",
                |m: &Raw| { &m.epoch },
                |m: &mut Raw| { &mut m.epoch },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data",
                |m: &Raw| { &m.data },
                |m: &mut Raw| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Raw>(
                "PBFTMessage.Raw",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Raw {
        const NAME: &'static str = "Raw";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.msg_type = is.read_enum_or_unknown()?;
                    },
                    16 => {
                        self.data_type = is.read_enum_or_unknown()?;
                    },
                    24 => {
                        self.view_n = is.read_int64()?;
                    },
                    32 => {
                        self.epoch = is.read_int64()?;
                    },
                    42 => {
                        self.data = is.read_bytes()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.msg_type != ::protobuf::EnumOrUnknown::new(MsgType::VIEW_CHANGE) {
                my_size += ::protobuf::rt::int32_size(1, self.msg_type.value());
            }
            if self.data_type != ::protobuf::EnumOrUnknown::new(DataType::BLOCK) {
                my_size += ::protobuf::rt::int32_size(2, self.data_type.value());
            }
            if self.view_n != 0 {
                my_size += ::protobuf::rt::int64_size(3, self.view_n);
            }
            if self.epoch != 0 {
                my_size += ::protobuf::rt::int64_size(4, self.epoch);
            }
            if !self.data.is_empty() {
                my_size += ::protobuf::rt::bytes_size(5, &self.data);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.msg_type != ::protobuf::EnumOrUnknown::new(MsgType::VIEW_CHANGE) {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.msg_type))?;
            }
            if self.data_type != ::protobuf::EnumOrUnknown::new(DataType::BLOCK) {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.data_type))?;
            }
            if self.view_n != 0 {
                os.write_int64(3, self.view_n)?;
            }
            if self.epoch != 0 {
                os.write_int64(4, self.epoch)?;
            }
            if !self.data.is_empty() {
                os.write_bytes(5, &self.data)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Raw {
            Raw::new()
        }

        fn clear(&mut self) {
            self.msg_type = ::protobuf::EnumOrUnknown::new(MsgType::VIEW_CHANGE);
            self.data_type = ::protobuf::EnumOrUnknown::new(DataType::BLOCK);
            self.view_n = 0;
            self.epoch = 0;
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Raw {
            static instance: Raw = Raw {
                msg_type: ::protobuf::EnumOrUnknown::from_i32(0),
                data_type: ::protobuf::EnumOrUnknown::from_i32(0),
                view_n: 0,
                epoch: 0,
                data: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Raw {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("PBFTMessage.Raw").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Raw {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Raw {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:protocol.PBFTMessage.MsgType)
    pub enum MsgType {
        // @@protoc_insertion_point(enum_value:protocol.PBFTMessage.MsgType.VIEW_CHANGE)
        VIEW_CHANGE = 0,
        // @@protoc_insertion_point(enum_value:protocol.PBFTMessage.MsgType.REQUEST)
        REQUEST = 1,
        // @@protoc_insertion_point(enum_value:protocol.PBFTMessage.MsgType.PREPREPARE)
        PREPREPARE = 2,
        // @@protoc_insertion_point(enum_value:protocol.PBFTMessage.MsgType.PREPARE)
        PREPARE = 3,
        // @@protoc_insertion_point(enum_value:protocol.PBFTMessage.MsgType.COMMIT)
        COMMIT = 4,
    }

    impl ::protobuf::Enum for MsgType {
        const NAME: &'static str = "MsgType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<MsgType> {
            match value {
                0 => ::std::option::Option::Some(MsgType::VIEW_CHANGE),
                1 => ::std::option::Option::Some(MsgType::REQUEST),
                2 => ::std::option::Option::Some(MsgType::PREPREPARE),
                3 => ::std::option::Option::Some(MsgType::PREPARE),
                4 => ::std::option::Option::Some(MsgType::COMMIT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [MsgType] = &[
            MsgType::VIEW_CHANGE,
            MsgType::REQUEST,
            MsgType::PREPREPARE,
            MsgType::PREPARE,
            MsgType::COMMIT,
        ];
    }

    impl ::protobuf::EnumFull for MsgType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("PBFTMessage.MsgType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for MsgType {
        fn default() -> Self {
            MsgType::VIEW_CHANGE
        }
    }

    impl MsgType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MsgType>("PBFTMessage.MsgType")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:protocol.PBFTMessage.DataType)
    pub enum DataType {
        // @@protoc_insertion_point(enum_value:protocol.PBFTMessage.DataType.BLOCK)
        BLOCK = 0,
        // @@protoc_insertion_point(enum_value:protocol.PBFTMessage.DataType.SRL)
        SRL = 1,
    }

    impl ::protobuf::Enum for DataType {
        const NAME: &'static str = "DataType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<DataType> {
            match value {
                0 => ::std::option::Option::Some(DataType::BLOCK),
                1 => ::std::option::Option::Some(DataType::SRL),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [DataType] = &[
            DataType::BLOCK,
            DataType::SRL,
        ];
    }

    impl ::protobuf::EnumFull for DataType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("PBFTMessage.DataType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for DataType {
        fn default() -> Self {
            DataType::BLOCK
        }
    }

    impl DataType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DataType>("PBFTMessage.DataType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.PBFTCommitResult)
pub struct PBFTCommitResult {
    // message fields
    // @@protoc_insertion_point(field:protocol.PBFTCommitResult.data)
    pub data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.PBFTCommitResult.signature)
    pub signature: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.PBFTCommitResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PBFTCommitResult {
    fn default() -> &'a PBFTCommitResult {
        <PBFTCommitResult as ::protobuf::Message>::default_instance()
    }
}

impl PBFTCommitResult {
    pub fn new() -> PBFTCommitResult {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &PBFTCommitResult| { &m.data },
            |m: &mut PBFTCommitResult| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "signature",
            |m: &PBFTCommitResult| { &m.signature },
            |m: &mut PBFTCommitResult| { &mut m.signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PBFTCommitResult>(
            "PBFTCommitResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PBFTCommitResult {
    const NAME: &'static str = "PBFTCommitResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = is.read_bytes()?;
                },
                18 => {
                    self.signature.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        for value in &self.signature {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        for v in &self.signature {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PBFTCommitResult {
        PBFTCommitResult::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.signature.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PBFTCommitResult {
        static instance: PBFTCommitResult = PBFTCommitResult {
            data: ::std::vec::Vec::new(),
            signature: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PBFTCommitResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PBFTCommitResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PBFTCommitResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFTCommitResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.SRL)
pub struct SRL {
    // message fields
    // @@protoc_insertion_point(field:protocol.SRL.srAddress)
    pub srAddress: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.SRL.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SRL {
    fn default() -> &'a SRL {
        <SRL as ::protobuf::Message>::default_instance()
    }
}

impl SRL {
    pub fn new() -> SRL {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "srAddress",
            |m: &SRL| { &m.srAddress },
            |m: &mut SRL| { &mut m.srAddress },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SRL>(
            "SRL",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SRL {
    const NAME: &'static str = "SRL";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.srAddress.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.srAddress {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.srAddress {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SRL {
        SRL::new()
    }

    fn clear(&mut self) {
        self.srAddress.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SRL {
        static instance: SRL = SRL {
            srAddress: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SRL {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SRL").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SRL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SRL {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:protocol.AccountType)
pub enum AccountType {
    // @@protoc_insertion_point(enum_value:protocol.AccountType.Normal)
    Normal = 0,
    // @@protoc_insertion_point(enum_value:protocol.AccountType.AssetIssue)
    AssetIssue = 1,
    // @@protoc_insertion_point(enum_value:protocol.AccountType.Contract)
    Contract = 2,
}

impl ::protobuf::Enum for AccountType {
    const NAME: &'static str = "AccountType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AccountType> {
        match value {
            0 => ::std::option::Option::Some(AccountType::Normal),
            1 => ::std::option::Option::Some(AccountType::AssetIssue),
            2 => ::std::option::Option::Some(AccountType::Contract),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AccountType] = &[
        AccountType::Normal,
        AccountType::AssetIssue,
        AccountType::Contract,
    ];
}

impl ::protobuf::EnumFull for AccountType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AccountType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for AccountType {
    fn default() -> Self {
        AccountType::Normal
    }
}

impl AccountType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AccountType>("AccountType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:protocol.ReasonCode)
pub enum ReasonCode {
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.REQUESTED)
    REQUESTED = 0,
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.BAD_PROTOCOL)
    BAD_PROTOCOL = 2,
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.TOO_MANY_PEERS)
    TOO_MANY_PEERS = 4,
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.DUPLICATE_PEER)
    DUPLICATE_PEER = 5,
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.INCOMPATIBLE_PROTOCOL)
    INCOMPATIBLE_PROTOCOL = 6,
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.NULL_IDENTITY)
    NULL_IDENTITY = 7,
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.PEER_QUITING)
    PEER_QUITING = 8,
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.UNEXPECTED_IDENTITY)
    UNEXPECTED_IDENTITY = 9,
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.LOCAL_IDENTITY)
    LOCAL_IDENTITY = 10,
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.PING_TIMEOUT)
    PING_TIMEOUT = 11,
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.USER_REASON)
    USER_REASON = 16,
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.RESET)
    RESET = 17,
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.SYNC_FAIL)
    SYNC_FAIL = 18,
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.FETCH_FAIL)
    FETCH_FAIL = 19,
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.BAD_TX)
    BAD_TX = 20,
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.BAD_BLOCK)
    BAD_BLOCK = 21,
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.FORKED)
    FORKED = 22,
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.UNLINKABLE)
    UNLINKABLE = 23,
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.INCOMPATIBLE_VERSION)
    INCOMPATIBLE_VERSION = 24,
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.INCOMPATIBLE_CHAIN)
    INCOMPATIBLE_CHAIN = 25,
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.TIME_OUT)
    TIME_OUT = 32,
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.CONNECT_FAIL)
    CONNECT_FAIL = 33,
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.TOO_MANY_PEERS_WITH_SAME_IP)
    TOO_MANY_PEERS_WITH_SAME_IP = 34,
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.LIGHT_NODE_SYNC_FAIL)
    LIGHT_NODE_SYNC_FAIL = 35,
    // @@protoc_insertion_point(enum_value:protocol.ReasonCode.UNKNOWN)
    UNKNOWN = 255,
}

impl ::protobuf::Enum for ReasonCode {
    const NAME: &'static str = "ReasonCode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReasonCode> {
        match value {
            0 => ::std::option::Option::Some(ReasonCode::REQUESTED),
            2 => ::std::option::Option::Some(ReasonCode::BAD_PROTOCOL),
            4 => ::std::option::Option::Some(ReasonCode::TOO_MANY_PEERS),
            5 => ::std::option::Option::Some(ReasonCode::DUPLICATE_PEER),
            6 => ::std::option::Option::Some(ReasonCode::INCOMPATIBLE_PROTOCOL),
            7 => ::std::option::Option::Some(ReasonCode::NULL_IDENTITY),
            8 => ::std::option::Option::Some(ReasonCode::PEER_QUITING),
            9 => ::std::option::Option::Some(ReasonCode::UNEXPECTED_IDENTITY),
            10 => ::std::option::Option::Some(ReasonCode::LOCAL_IDENTITY),
            11 => ::std::option::Option::Some(ReasonCode::PING_TIMEOUT),
            16 => ::std::option::Option::Some(ReasonCode::USER_REASON),
            17 => ::std::option::Option::Some(ReasonCode::RESET),
            18 => ::std::option::Option::Some(ReasonCode::SYNC_FAIL),
            19 => ::std::option::Option::Some(ReasonCode::FETCH_FAIL),
            20 => ::std::option::Option::Some(ReasonCode::BAD_TX),
            21 => ::std::option::Option::Some(ReasonCode::BAD_BLOCK),
            22 => ::std::option::Option::Some(ReasonCode::FORKED),
            23 => ::std::option::Option::Some(ReasonCode::UNLINKABLE),
            24 => ::std::option::Option::Some(ReasonCode::INCOMPATIBLE_VERSION),
            25 => ::std::option::Option::Some(ReasonCode::INCOMPATIBLE_CHAIN),
            32 => ::std::option::Option::Some(ReasonCode::TIME_OUT),
            33 => ::std::option::Option::Some(ReasonCode::CONNECT_FAIL),
            34 => ::std::option::Option::Some(ReasonCode::TOO_MANY_PEERS_WITH_SAME_IP),
            35 => ::std::option::Option::Some(ReasonCode::LIGHT_NODE_SYNC_FAIL),
            255 => ::std::option::Option::Some(ReasonCode::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ReasonCode] = &[
        ReasonCode::REQUESTED,
        ReasonCode::BAD_PROTOCOL,
        ReasonCode::TOO_MANY_PEERS,
        ReasonCode::DUPLICATE_PEER,
        ReasonCode::INCOMPATIBLE_PROTOCOL,
        ReasonCode::NULL_IDENTITY,
        ReasonCode::PEER_QUITING,
        ReasonCode::UNEXPECTED_IDENTITY,
        ReasonCode::LOCAL_IDENTITY,
        ReasonCode::PING_TIMEOUT,
        ReasonCode::USER_REASON,
        ReasonCode::RESET,
        ReasonCode::SYNC_FAIL,
        ReasonCode::FETCH_FAIL,
        ReasonCode::BAD_TX,
        ReasonCode::BAD_BLOCK,
        ReasonCode::FORKED,
        ReasonCode::UNLINKABLE,
        ReasonCode::INCOMPATIBLE_VERSION,
        ReasonCode::INCOMPATIBLE_CHAIN,
        ReasonCode::TIME_OUT,
        ReasonCode::CONNECT_FAIL,
        ReasonCode::TOO_MANY_PEERS_WITH_SAME_IP,
        ReasonCode::LIGHT_NODE_SYNC_FAIL,
        ReasonCode::UNKNOWN,
    ];
}

impl ::protobuf::EnumFull for ReasonCode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ReasonCode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ReasonCode::REQUESTED => 0,
            ReasonCode::BAD_PROTOCOL => 1,
            ReasonCode::TOO_MANY_PEERS => 2,
            ReasonCode::DUPLICATE_PEER => 3,
            ReasonCode::INCOMPATIBLE_PROTOCOL => 4,
            ReasonCode::NULL_IDENTITY => 5,
            ReasonCode::PEER_QUITING => 6,
            ReasonCode::UNEXPECTED_IDENTITY => 7,
            ReasonCode::LOCAL_IDENTITY => 8,
            ReasonCode::PING_TIMEOUT => 9,
            ReasonCode::USER_REASON => 10,
            ReasonCode::RESET => 11,
            ReasonCode::SYNC_FAIL => 12,
            ReasonCode::FETCH_FAIL => 13,
            ReasonCode::BAD_TX => 14,
            ReasonCode::BAD_BLOCK => 15,
            ReasonCode::FORKED => 16,
            ReasonCode::UNLINKABLE => 17,
            ReasonCode::INCOMPATIBLE_VERSION => 18,
            ReasonCode::INCOMPATIBLE_CHAIN => 19,
            ReasonCode::TIME_OUT => 20,
            ReasonCode::CONNECT_FAIL => 21,
            ReasonCode::TOO_MANY_PEERS_WITH_SAME_IP => 22,
            ReasonCode::LIGHT_NODE_SYNC_FAIL => 23,
            ReasonCode::UNKNOWN => 24,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ReasonCode {
    fn default() -> Self {
        ReasonCode::REQUESTED
    }
}

impl ReasonCode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ReasonCode>("ReasonCode")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0fcore/Tron.proto\x12\x08protocol\x1a\x19google/protobuf/any.proto\
    \x1a\x13core/Discover.proto\"9\n\tAccountId\x12\x12\n\x04name\x18\x01\
    \x20\x01(\x0cR\x04name\x12\x18\n\x07address\x18\x02\x20\x01(\x0cR\x07add\
    ress\"H\n\x04Vote\x12!\n\x0cvote_address\x18\x01\x20\x01(\x0cR\x0bvoteAd\
    dress\x12\x1d\n\nvote_count\x18\x02\x20\x01(\x03R\tvoteCount\"\xb4\x03\n\
    \x08Proposal\x12\x1f\n\x0bproposal_id\x18\x01\x20\x01(\x03R\nproposalId\
    \x12)\n\x10proposer_address\x18\x02\x20\x01(\x0cR\x0fproposerAddress\x12\
    B\n\nparameters\x18\x03\x20\x03(\x0b2\".protocol.Proposal.ParametersEntr\
    yR\nparameters\x12'\n\x0fexpiration_time\x18\x04\x20\x01(\x03R\x0eexpira\
    tionTime\x12\x1f\n\x0bcreate_time\x18\x05\x20\x01(\x03R\ncreateTime\x12\
    \x1c\n\tapprovals\x18\x06\x20\x03(\x0cR\tapprovals\x12.\n\x05state\x18\
    \x07\x20\x01(\x0e2\x18.protocol.Proposal.StateR\x05state\x1a=\n\x0fParam\
    etersEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x03R\x03key\x12\x14\n\x05va\
    lue\x18\x02\x20\x01(\x03R\x05value:\x028\x01\"A\n\x05State\x12\x0b\n\x07\
    PENDING\x10\0\x12\x0f\n\x0bDISAPPROVED\x10\x01\x12\x0c\n\x08APPROVED\x10\
    \x02\x12\x0c\n\x08CANCELED\x10\x03\"\xa5\x02\n\x08Exchange\x12\x1f\n\x0b\
    exchange_id\x18\x01\x20\x01(\x03R\nexchangeId\x12'\n\x0fcreator_address\
    \x18\x02\x20\x01(\x0cR\x0ecreatorAddress\x12\x1f\n\x0bcreate_time\x18\
    \x03\x20\x01(\x03R\ncreateTime\x12$\n\x0efirst_token_id\x18\x06\x20\x01(\
    \x0cR\x0cfirstTokenId\x12.\n\x13first_token_balance\x18\x07\x20\x01(\x03\
    R\x11firstTokenBalance\x12&\n\x0fsecond_token_id\x18\x08\x20\x01(\x0cR\r\
    secondTokenId\x120\n\x14second_token_balance\x18\t\x20\x01(\x03R\x12seco\
    ndTokenBalance\"\x98\x04\n\x0bMarketOrder\x12\x19\n\x08order_id\x18\x01\
    \x20\x01(\x0cR\x07orderId\x12#\n\rowner_address\x18\x02\x20\x01(\x0cR\
    \x0cownerAddress\x12\x1f\n\x0bcreate_time\x18\x03\x20\x01(\x03R\ncreateT\
    ime\x12\"\n\rsell_token_id\x18\x04\x20\x01(\x0cR\x0bsellTokenId\x12.\n\
    \x13sell_token_quantity\x18\x05\x20\x01(\x03R\x11sellTokenQuantity\x12\
    \x20\n\x0cbuy_token_id\x18\x06\x20\x01(\x0cR\nbuyTokenId\x12,\n\x12buy_t\
    oken_quantity\x18\x07\x20\x01(\x03R\x10buyTokenQuantity\x12;\n\x1asell_t\
    oken_quantity_remain\x18\t\x20\x01(\x03R\x17sellTokenQuantityRemain\x12;\
    \n\x1asell_token_quantity_return\x18\n\x20\x01(\x03R\x17sellTokenQuantit\
    yReturn\x121\n\x05state\x18\x0b\x20\x01(\x0e2\x1b.protocol.MarketOrder.S\
    tateR\x05state\x12\x12\n\x04prev\x18\x0c\x20\x01(\x0cR\x04prev\x12\x12\n\
    \x04next\x18\r\x20\x01(\x0cR\x04next\"/\n\x05State\x12\n\n\x06ACTIVE\x10\
    \0\x12\x0c\n\x08INACTIVE\x10\x01\x12\x0c\n\x08CANCELED\x10\x02\"@\n\x0fM\
    arketOrderList\x12-\n\x06orders\x18\x01\x20\x03(\x0b2\x15.protocol.Marke\
    tOrderR\x06orders\"N\n\x13MarketOrderPairList\x127\n\torderPair\x18\x01\
    \x20\x03(\x0b2\x19.protocol.MarketOrderPairR\torderPair\"W\n\x0fMarketOr\
    derPair\x12\"\n\rsell_token_id\x18\x01\x20\x01(\x0cR\x0bsellTokenId\x12\
    \x20\n\x0cbuy_token_id\x18\x02\x20\x01(\x0cR\nbuyTokenId\"\x88\x01\n\x12\
    MarketAccountOrder\x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerA\
    ddress\x12\x16\n\x06orders\x18\x02\x20\x03(\x0cR\x06orders\x12\x14\n\x05\
    count\x18\x03\x20\x01(\x03R\x05count\x12\x1f\n\x0btotal_count\x18\x04\
    \x20\x01(\x03R\ntotalCount\"k\n\x0bMarketPrice\x12.\n\x13sell_token_quan\
    tity\x18\x01\x20\x01(\x03R\x11sellTokenQuantity\x12,\n\x12buy_token_quan\
    tity\x18\x02\x20\x01(\x03R\x10buyTokenQuantity\"\x86\x01\n\x0fMarketPric\
    eList\x12\"\n\rsell_token_id\x18\x01\x20\x01(\x0cR\x0bsellTokenId\x12\
    \x20\n\x0cbuy_token_id\x18\x02\x20\x01(\x0cR\nbuyTokenId\x12-\n\x06price\
    s\x18\x03\x20\x03(\x0b2\x15.protocol.MarketPriceR\x06prices\";\n\x11Mark\
    etOrderIdList\x12\x12\n\x04head\x18\x01\x20\x01(\x0cR\x04head\x12\x12\n\
    \x04tail\x18\x02\x20\x01(\x0cR\x04tail\"\x9d\x01\n\x0fChainParameters\
    \x12P\n\x0echainParameter\x18\x01\x20\x03(\x0b2(.protocol.ChainParameter\
    s.ChainParameterR\x0echainParameter\x1a8\n\x0eChainParameter\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \x03R\x05value\"\xb8\x17\n\x07Account\x12!\n\x0caccount_name\x18\x01\x20\
    \x01(\x0cR\x0baccountName\x12)\n\x04type\x18\x02\x20\x01(\x0e2\x15.proto\
    col.AccountTypeR\x04type\x12\x18\n\x07address\x18\x03\x20\x01(\x0cR\x07a\
    ddress\x12\x18\n\x07balance\x18\x04\x20\x01(\x03R\x07balance\x12$\n\x05v\
    otes\x18\x05\x20\x03(\x0b2\x0e.protocol.VoteR\x05votes\x122\n\x05asset\
    \x18\x06\x20\x03(\x0b2\x1c.protocol.Account.AssetEntryR\x05asset\x128\n\
    \x07assetV2\x188\x20\x03(\x0b2\x1e.protocol.Account.AssetV2EntryR\x07ass\
    etV2\x120\n\x06frozen\x18\x07\x20\x03(\x0b2\x18.protocol.Account.FrozenR\
    \x06frozen\x12\x1b\n\tnet_usage\x18\x08\x20\x01(\x03R\x08netUsage\x12c\n\
    /acquired_delegated_frozen_balance_for_bandwidth\x18)\x20\x01(\x03R*acqu\
    iredDelegatedFrozenBalanceForBandwidth\x12R\n&delegated_frozen_balance_f\
    or_bandwidth\x18*\x20\x01(\x03R\"delegatedFrozenBalanceForBandwidth\x12$\
    \n\x0eold_tron_power\x18.\x20\x01(\x03R\x0coldTronPower\x127\n\ntron_pow\
    er\x18/\x20\x01(\x0b2\x18.protocol.Account.FrozenR\ttronPower\x12'\n\x0f\
    asset_optimized\x18<\x20\x01(\x08R\x0eassetOptimized\x12\x1f\n\x0bcreate\
    _time\x18\t\x20\x01(\x03R\ncreateTime\x120\n\x14latest_opration_time\x18\
    \n\x20\x01(\x03R\x12latestOprationTime\x12\x1c\n\tallowance\x18\x0b\x20\
    \x01(\x03R\tallowance\x120\n\x14latest_withdraw_time\x18\x0c\x20\x01(\
    \x03R\x12latestWithdrawTime\x12\x12\n\x04code\x18\r\x20\x01(\x0cR\x04cod\
    e\x12\x1d\n\nis_witness\x18\x0e\x20\x01(\x08R\tisWitness\x12!\n\x0cis_co\
    mmittee\x18\x0f\x20\x01(\x08R\x0bisCommittee\x12=\n\rfrozen_supply\x18\
    \x10\x20\x03(\x0b2\x18.protocol.Account.FrozenR\x0cfrozenSupply\x12*\n\
    \x11asset_issued_name\x18\x11\x20\x01(\x0cR\x0fassetIssuedName\x12&\n\
    \x0fasset_issued_ID\x189\x20\x01(\x0cR\rassetIssuedID\x12n\n\x1blatest_a\
    sset_operation_time\x18\x12\x20\x03(\x0b2/.protocol.Account.LatestAssetO\
    perationTimeEntryR\x18latestAssetOperationTime\x12t\n\x1dlatest_asset_op\
    eration_timeV2\x18:\x20\x03(\x0b21.protocol.Account.LatestAssetOperation\
    TimeV2EntryR\x1alatestAssetOperationTimeV2\x12$\n\x0efree_net_usage\x18\
    \x13\x20\x01(\x03R\x0cfreeNetUsage\x12Y\n\x14free_asset_net_usage\x18\
    \x14\x20\x03(\x0b2(.protocol.Account.FreeAssetNetUsageEntryR\x11freeAsse\
    tNetUsage\x12_\n\x16free_asset_net_usageV2\x18;\x20\x03(\x0b2*.protocol.\
    Account.FreeAssetNetUsageV2EntryR\x13freeAssetNetUsageV2\x12.\n\x13lates\
    t_consume_time\x18\x15\x20\x01(\x03R\x11latestConsumeTime\x127\n\x18late\
    st_consume_free_time\x18\x16\x20\x01(\x03R\x15latestConsumeFreeTime\x12\
    \x1d\n\naccount_id\x18\x17\x20\x01(\x0cR\taccountId\x12L\n\x10account_re\
    source\x18\x1a\x20\x01(\x0b2!.protocol.Account.AccountResourceR\x0faccou\
    ntResource\x12\x1a\n\x08codeHash\x18\x1e\x20\x01(\x0cR\x08codeHash\x12?\
    \n\x10owner_permission\x18\x1f\x20\x01(\x0b2\x14.protocol.PermissionR\
    \x0fownerPermission\x12C\n\x12witness_permission\x18\x20\x20\x01(\x0b2\
    \x14.protocol.PermissionR\x11witnessPermission\x12A\n\x11active_permissi\
    on\x18!\x20\x03(\x0b2\x14.protocol.PermissionR\x10activePermission\x1aP\
    \n\x06Frozen\x12%\n\x0efrozen_balance\x18\x01\x20\x01(\x03R\rfrozenBalan\
    ce\x12\x1f\n\x0bexpire_time\x18\x02\x20\x01(\x03R\nexpireTime\x1a8\n\nAs\
    setEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\x03R\x05value:\x028\x01\x1a:\n\x0cAssetV2Entry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \x03R\x05value:\x028\x01\x1aK\n\x1dLatestAssetOperationTimeEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \x03R\x05value:\x028\x01\x1aM\n\x1fLatestAssetOperationTimeV2Entry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\x03R\x05value:\x028\x01\x1aD\n\x16FreeAssetNetUsageEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \x03R\x05value:\x028\x01\x1aF\n\x18FreeAssetNetUsageV2Entry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \x03R\x05value:\x028\x01\x1a\x85\x04\n\x0fAccountResource\x12!\n\x0cener\
    gy_usage\x18\x01\x20\x01(\x03R\x0benergyUsage\x12S\n\x19frozen_balance_f\
    or_energy\x18\x02\x20\x01(\x0b2\x18.protocol.Account.FrozenR\x16frozenBa\
    lanceForEnergy\x12B\n\x1elatest_consume_time_for_energy\x18\x03\x20\x01(\
    \x03R\x1alatestConsumeTimeForEnergy\x12]\n,acquired_delegated_frozen_bal\
    ance_for_energy\x18\x04\x20\x01(\x03R'acquiredDelegatedFrozenBalanceForE\
    nergy\x12L\n#delegated_frozen_balance_for_energy\x18\x05\x20\x01(\x03R\
    \x1fdelegatedFrozenBalanceForEnergy\x12#\n\rstorage_limit\x18\x06\x20\
    \x01(\x03R\x0cstorageLimit\x12#\n\rstorage_usage\x18\x07\x20\x01(\x03R\
    \x0cstorageUsage\x12?\n\x1clatest_exchange_storage_time\x18\x08\x20\x01(\
    \x03R\x19latestExchangeStorageTime\"7\n\x03Key\x12\x18\n\x07address\x18\
    \x01\x20\x01(\x0cR\x07address\x12\x16\n\x06weight\x18\x02\x20\x01(\x03R\
    \x06weight\"\xa3\x02\n\x11DelegatedResource\x12\x12\n\x04from\x18\x01\
    \x20\x01(\x0cR\x04from\x12\x0e\n\x02to\x18\x02\x20\x01(\x0cR\x02to\x12?\
    \n\x1cfrozen_balance_for_bandwidth\x18\x03\x20\x01(\x03R\x19frozenBalanc\
    eForBandwidth\x129\n\x19frozen_balance_for_energy\x18\x04\x20\x01(\x03R\
    \x16frozenBalanceForEnergy\x129\n\x19expire_time_for_bandwidth\x18\x05\
    \x20\x01(\x03R\x16expireTimeForBandwidth\x123\n\x16expire_time_for_energ\
    y\x18\x06\x20\x01(\x03R\x13expireTimeForEnergy\"c\n\tauthority\x12-\n\
    \x07account\x18\x01\x20\x01(\x0b2\x13.protocol.AccountIdR\x07account\x12\
    '\n\x0fpermission_name\x18\x02\x20\x01(\x0cR\x0epermissionName\"\xb2\x02\
    \n\nPermission\x127\n\x04type\x18\x01\x20\x01(\x0e2#.protocol.Permission\
    .PermissionTypeR\x04type\x12\x0e\n\x02id\x18\x02\x20\x01(\x05R\x02id\x12\
    '\n\x0fpermission_name\x18\x03\x20\x01(\tR\x0epermissionName\x12\x1c\n\t\
    threshold\x18\x04\x20\x01(\x03R\tthreshold\x12\x1b\n\tparent_id\x18\x05\
    \x20\x01(\x05R\x08parentId\x12\x1e\n\noperations\x18\x06\x20\x01(\x0cR\n\
    operations\x12!\n\x04keys\x18\x07\x20\x03(\x0b2\r.protocol.KeyR\x04keys\
    \"4\n\x0ePermissionType\x12\t\n\x05Owner\x10\0\x12\x0b\n\x07Witness\x10\
    \x01\x12\n\n\x06Active\x10\x02\"\x99\x02\n\x07Witness\x12\x18\n\x07addre\
    ss\x18\x01\x20\x01(\x0cR\x07address\x12\x1c\n\tvoteCount\x18\x02\x20\x01\
    (\x03R\tvoteCount\x12\x16\n\x06pubKey\x18\x03\x20\x01(\x0cR\x06pubKey\
    \x12\x10\n\x03url\x18\x04\x20\x01(\tR\x03url\x12$\n\rtotalProduced\x18\
    \x05\x20\x01(\x03R\rtotalProduced\x12\x20\n\x0btotalMissed\x18\x06\x20\
    \x01(\x03R\x0btotalMissed\x12&\n\x0elatestBlockNum\x18\x07\x20\x01(\x03R\
    \x0elatestBlockNum\x12$\n\rlatestSlotNum\x18\x08\x20\x01(\x03R\rlatestSl\
    otNum\x12\x16\n\x06isJobs\x18\t\x20\x01(\x08R\x06isJobs\"{\n\x05Votes\
    \x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\x07address\x12+\n\told_votes\
    \x18\x02\x20\x03(\x0b2\x0e.protocol.VoteR\x08oldVotes\x12+\n\tnew_votes\
    \x18\x03\x20\x03(\x0b2\x0e.protocol.VoteR\x08newVotes\"@\n\x08TXOutput\
    \x12\x14\n\x05value\x18\x01\x20\x01(\x03R\x05value\x12\x1e\n\npubKeyHash\
    \x18\x02\x20\x01(\x0cR\npubKeyHash\"\xa0\x01\n\x07TXInput\x120\n\x08raw_\
    data\x18\x01\x20\x01(\x0b2\x15.protocol.TXInput.rawR\x07rawData\x12\x1c\
    \n\tsignature\x18\x04\x20\x01(\x0cR\tsignature\x1aE\n\x03raw\x12\x12\n\
    \x04txID\x18\x01\x20\x01(\x0cR\x04txID\x12\x12\n\x04vout\x18\x02\x20\x01\
    (\x03R\x04vout\x12\x16\n\x06pubKey\x18\x03\x20\x01(\x0cR\x06pubKey\"9\n\
    \tTXOutputs\x12,\n\x07outputs\x18\x01\x20\x03(\x0b2\x12.protocol.TXOutpu\
    tR\x07outputs\"\xac\x02\n\x0fResourceReceipt\x12!\n\x0cenergy_usage\x18\
    \x01\x20\x01(\x03R\x0benergyUsage\x12\x1d\n\nenergy_fee\x18\x02\x20\x01(\
    \x03R\tenergyFee\x12.\n\x13origin_energy_usage\x18\x03\x20\x01(\x03R\x11\
    originEnergyUsage\x12,\n\x12energy_usage_total\x18\x04\x20\x01(\x03R\x10\
    energyUsageTotal\x12\x1b\n\tnet_usage\x18\x05\x20\x01(\x03R\x08netUsage\
    \x12\x17\n\x07net_fee\x18\x06\x20\x01(\x03R\x06netFee\x12C\n\x06result\
    \x18\x07\x20\x01(\x0e2+.protocol.Transaction.Result.contractResultR\x06r\
    esult\"\xb1\x01\n\x11MarketOrderDetail\x12\"\n\x0cmakerOrderId\x18\x01\
    \x20\x01(\x0cR\x0cmakerOrderId\x12\"\n\x0ctakerOrderId\x18\x02\x20\x01(\
    \x0cR\x0ctakerOrderId\x12*\n\x10fillSellQuantity\x18\x03\x20\x01(\x03R\
    \x10fillSellQuantity\x12(\n\x0ffillBuyQuantity\x18\x04\x20\x01(\x03R\x0f\
    fillBuyQuantity\"\xa9\x15\n\x0bTransaction\x124\n\x08raw_data\x18\x01\
    \x20\x01(\x0b2\x19.protocol.Transaction.rawR\x07rawData\x12\x1c\n\tsigna\
    ture\x18\x02\x20\x03(\x0cR\tsignature\x12.\n\x03ret\x18\x05\x20\x03(\x0b\
    2\x1c.protocol.Transaction.ResultR\x03ret\x1a\xb0\t\n\x08Contract\x12?\n\
    \x04type\x18\x01\x20\x01(\x0e2+.protocol.Transaction.Contract.ContractTy\
    peR\x04type\x122\n\tparameter\x18\x02\x20\x01(\x0b2\x14.google.protobuf.\
    AnyR\tparameter\x12\x1a\n\x08provider\x18\x03\x20\x01(\x0cR\x08provider\
    \x12\"\n\x0cContractName\x18\x04\x20\x01(\x0cR\x0cContractName\x12#\n\rP\
    ermission_id\x18\x05\x20\x01(\x05R\x0cPermissionId\"\xc9\x07\n\x0cContra\
    ctType\x12\x19\n\x15AccountCreateContract\x10\0\x12\x14\n\x10TransferCon\
    tract\x10\x01\x12\x19\n\x15TransferAssetContract\x10\x02\x12\x15\n\x11Vo\
    teAssetContract\x10\x03\x12\x17\n\x13VoteWitnessContract\x10\x04\x12\x19\
    \n\x15WitnessCreateContract\x10\x05\x12\x16\n\x12AssetIssueContract\x10\
    \x06\x12\x19\n\x15WitnessUpdateContract\x10\x08\x12!\n\x1dParticipateAss\
    etIssueContract\x10\t\x12\x19\n\x15AccountUpdateContract\x10\n\x12\x19\n\
    \x15FreezeBalanceContract\x10\x0b\x12\x1b\n\x17UnfreezeBalanceContract\
    \x10\x0c\x12\x1b\n\x17WithdrawBalanceContract\x10\r\x12\x19\n\x15Unfreez\
    eAssetContract\x10\x0e\x12\x17\n\x13UpdateAssetContract\x10\x0f\x12\x1a\
    \n\x16ProposalCreateContract\x10\x10\x12\x1b\n\x17ProposalApproveContrac\
    t\x10\x11\x12\x1a\n\x16ProposalDeleteContract\x10\x12\x12\x18\n\x14SetAc\
    countIdContract\x10\x13\x12\x12\n\x0eCustomContract\x10\x14\x12\x17\n\
    \x13CreateSmartContract\x10\x1e\x12\x18\n\x14TriggerSmartContract\x10\
    \x1f\x12\x0f\n\x0bGetContract\x10\x20\x12\x19\n\x15UpdateSettingContract\
    \x10!\x12\x1a\n\x16ExchangeCreateContract\x10)\x12\x1a\n\x16ExchangeInje\
    ctContract\x10*\x12\x1c\n\x18ExchangeWithdrawContract\x10+\x12\x1f\n\x1b\
    ExchangeTransactionContract\x10,\x12\x1d\n\x19UpdateEnergyLimitContract\
    \x10-\x12#\n\x1fAccountPermissionUpdateContract\x10.\x12\x14\n\x10ClearA\
    BIContract\x100\x12\x1b\n\x17UpdateBrokerageContract\x101\x12\x1c\n\x18S\
    hieldedTransferContract\x103\x12\x1b\n\x17MarketSellAssetContract\x104\
    \x12\x1d\n\x19MarketCancelOrderContract\x105\x1a\xf8\x07\n\x06Result\x12\
    \x10\n\x03fee\x18\x01\x20\x01(\x03R\x03fee\x123\n\x03ret\x18\x02\x20\x01\
    (\x0e2!.protocol.Transaction.Result.codeR\x03ret\x12M\n\x0bcontractRet\
    \x18\x03\x20\x01(\x0e2+.protocol.Transaction.Result.contractResultR\x0bc\
    ontractRet\x12\"\n\x0cassetIssueID\x18\x0e\x20\x01(\tR\x0cassetIssueID\
    \x12'\n\x0fwithdraw_amount\x18\x0f\x20\x01(\x03R\x0ewithdrawAmount\x12'\
    \n\x0funfreeze_amount\x18\x10\x20\x01(\x03R\x0eunfreezeAmount\x128\n\x18\
    exchange_received_amount\x18\x12\x20\x01(\x03R\x16exchangeReceivedAmount\
    \x12C\n\x1eexchange_inject_another_amount\x18\x13\x20\x01(\x03R\x1bexcha\
    ngeInjectAnotherAmount\x12G\n\x20exchange_withdraw_another_amount\x18\
    \x14\x20\x01(\x03R\x1dexchangeWithdrawAnotherAmount\x12\x1f\n\x0bexchang\
    e_id\x18\x15\x20\x01(\x03R\nexchangeId\x128\n\x18shielded_transaction_fe\
    e\x18\x16\x20\x01(\x03R\x16shieldedTransactionFee\x12\x18\n\x07orderId\
    \x18\x19\x20\x01(\x0cR\x07orderId\x12?\n\x0corderDetails\x18\x1a\x20\x03\
    (\x0b2\x1b.protocol.MarketOrderDetailR\x0corderDetails\"\x1e\n\x04code\
    \x12\n\n\x06SUCESS\x10\0\x12\n\n\x06FAILED\x10\x01\"\xc3\x02\n\x0econtra\
    ctResult\x12\x0b\n\x07DEFAULT\x10\0\x12\x0b\n\x07SUCCESS\x10\x01\x12\n\n\
    \x06REVERT\x10\x02\x12\x18\n\x14BAD_JUMP_DESTINATION\x10\x03\x12\x11\n\r\
    OUT_OF_MEMORY\x10\x04\x12\x18\n\x14PRECOMPILED_CONTRACT\x10\x05\x12\x13\
    \n\x0fSTACK_TOO_SMALL\x10\x06\x12\x13\n\x0fSTACK_TOO_LARGE\x10\x07\x12\
    \x15\n\x11ILLEGAL_OPERATION\x10\x08\x12\x12\n\x0eSTACK_OVERFLOW\x10\t\
    \x12\x11\n\rOUT_OF_ENERGY\x10\n\x12\x0f\n\x0bOUT_OF_TIME\x10\x0b\x12\x17\
    \n\x13JVM_STACK_OVER_FLOW\x10\x0c\x12\x0b\n\x07UNKNOWN\x10\r\x12\x13\n\
    \x0fTRANSFER_FAILED\x10\x0e\x12\x10\n\x0cINVALID_CODE\x10\x0f\x1a\xe7\
    \x02\n\x03raw\x12&\n\x0fref_block_bytes\x18\x01\x20\x01(\x0cR\rrefBlockB\
    ytes\x12\"\n\rref_block_num\x18\x03\x20\x01(\x03R\x0brefBlockNum\x12$\n\
    \x0eref_block_hash\x18\x04\x20\x01(\x0cR\x0crefBlockHash\x12\x1e\n\nexpi\
    ration\x18\x08\x20\x01(\x03R\nexpiration\x12)\n\x05auths\x18\t\x20\x03(\
    \x0b2\x13.protocol.authorityR\x05auths\x12\x12\n\x04data\x18\n\x20\x01(\
    \x0cR\x04data\x12:\n\x08contract\x18\x0b\x20\x03(\x0b2\x1e.protocol.Tran\
    saction.ContractR\x08contract\x12\x18\n\x07scripts\x18\x0c\x20\x01(\x0cR\
    \x07scripts\x12\x1c\n\ttimestamp\x18\x0e\x20\x01(\x03R\ttimestamp\x12\
    \x1b\n\tfee_limit\x18\x12\x20\x01(\x03R\x08feeLimit\"\xe3\x08\n\x0fTrans\
    actionInfo\x12\x0e\n\x02id\x18\x01\x20\x01(\x0cR\x02id\x12\x10\n\x03fee\
    \x18\x02\x20\x01(\x03R\x03fee\x12\x20\n\x0bblockNumber\x18\x03\x20\x01(\
    \x03R\x0bblockNumber\x12&\n\x0eblockTimeStamp\x18\x04\x20\x01(\x03R\x0eb\
    lockTimeStamp\x12&\n\x0econtractResult\x18\x05\x20\x03(\x0cR\x0econtract\
    Result\x12)\n\x10contract_address\x18\x06\x20\x01(\x0cR\x0fcontractAddre\
    ss\x123\n\x07receipt\x18\x07\x20\x01(\x0b2\x19.protocol.ResourceReceiptR\
    \x07receipt\x12/\n\x03log\x18\x08\x20\x03(\x0b2\x1d.protocol.Transaction\
    Info.LogR\x03log\x126\n\x06result\x18\t\x20\x01(\x0e2\x1e.protocol.Trans\
    actionInfo.codeR\x06result\x12\x1e\n\nresMessage\x18\n\x20\x01(\x0cR\nre\
    sMessage\x12\"\n\x0cassetIssueID\x18\x0e\x20\x01(\tR\x0cassetIssueID\x12\
    '\n\x0fwithdraw_amount\x18\x0f\x20\x01(\x03R\x0ewithdrawAmount\x12'\n\
    \x0funfreeze_amount\x18\x10\x20\x01(\x03R\x0eunfreezeAmount\x12R\n\x15in\
    ternal_transactions\x18\x11\x20\x03(\x0b2\x1d.protocol.InternalTransacti\
    onR\x14internalTransactions\x128\n\x18exchange_received_amount\x18\x12\
    \x20\x01(\x03R\x16exchangeReceivedAmount\x12C\n\x1eexchange_inject_anoth\
    er_amount\x18\x13\x20\x01(\x03R\x1bexchangeInjectAnotherAmount\x12G\n\
    \x20exchange_withdraw_another_amount\x18\x14\x20\x01(\x03R\x1dexchangeWi\
    thdrawAnotherAmount\x12\x1f\n\x0bexchange_id\x18\x15\x20\x01(\x03R\nexch\
    angeId\x128\n\x18shielded_transaction_fee\x18\x16\x20\x01(\x03R\x16shiel\
    dedTransactionFee\x12\x18\n\x07orderId\x18\x19\x20\x01(\x0cR\x07orderId\
    \x12?\n\x0corderDetails\x18\x1a\x20\x03(\x0b2\x1b.protocol.MarketOrderDe\
    tailR\x0corderDetails\x12\x1e\n\npackingFee\x18\x1b\x20\x01(\x03R\npacki\
    ngFee\x1aK\n\x03Log\x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\x07addres\
    s\x12\x16\n\x06topics\x18\x02\x20\x03(\x0cR\x06topics\x12\x12\n\x04data\
    \x18\x03\x20\x01(\x0cR\x04data\"\x1e\n\x04code\x12\n\n\x06SUCESS\x10\0\
    \x12\n\n\x06FAILED\x10\x01\"\x9f\x01\n\x0eTransactionRet\x12\x20\n\x0bbl\
    ockNumber\x18\x01\x20\x01(\x03R\x0bblockNumber\x12&\n\x0eblockTimeStamp\
    \x18\x02\x20\x01(\x03R\x0eblockTimeStamp\x12C\n\x0ftransactioninfo\x18\
    \x03\x20\x03(\x0b2\x19.protocol.TransactionInfoR\x0ftransactioninfo\"I\n\
    \x0cTransactions\x129\n\x0ctransactions\x18\x01\x20\x03(\x0b2\x15.protoc\
    ol.TransactionR\x0ctransactions\"j\n\x0fTransactionSign\x127\n\x0btransa\
    ction\x18\x01\x20\x01(\x0b2\x15.protocol.TransactionR\x0btransaction\x12\
    \x1e\n\nprivateKey\x18\x02\x20\x01(\x0cR\nprivateKey\"\xfc\x02\n\x0bBloc\
    kHeader\x124\n\x08raw_data\x18\x01\x20\x01(\x0b2\x19.protocol.BlockHeade\
    r.rawR\x07rawData\x12+\n\x11witness_signature\x18\x02\x20\x01(\x0cR\x10w\
    itnessSignature\x1a\x89\x02\n\x03raw\x12\x1c\n\ttimestamp\x18\x01\x20\
    \x01(\x03R\ttimestamp\x12\x1e\n\ntxTrieRoot\x18\x02\x20\x01(\x0cR\ntxTri\
    eRoot\x12\x1e\n\nparentHash\x18\x03\x20\x01(\x0cR\nparentHash\x12\x16\n\
    \x06number\x18\x07\x20\x01(\x03R\x06number\x12\x1d\n\nwitness_id\x18\x08\
    \x20\x01(\x03R\twitnessId\x12'\n\x0fwitness_address\x18\t\x20\x01(\x0cR\
    \x0ewitnessAddress\x12\x18\n\x07version\x18\n\x20\x01(\x05R\x07version\
    \x12*\n\x10accountStateRoot\x18\x0b\x20\x01(\x0cR\x10accountStateRoot\"|\
    \n\x05Block\x129\n\x0ctransactions\x18\x01\x20\x03(\x0b2\x15.protocol.Tr\
    ansactionR\x0ctransactions\x128\n\x0cblock_header\x18\x02\x20\x01(\x0b2\
    \x15.protocol.BlockHeaderR\x0bblockHeader\"\x9a\x01\n\x0eChainInventory\
    \x122\n\x03ids\x18\x01\x20\x03(\x0b2\x20.protocol.ChainInventory.BlockId\
    R\x03ids\x12\x1d\n\nremain_num\x18\x02\x20\x01(\x03R\tremainNum\x1a5\n\
    \x07BlockId\x12\x12\n\x04hash\x18\x01\x20\x01(\x0cR\x04hash\x12\x16\n\
    \x06number\x18\x02\x20\x01(\x03R\x06number\"\xd8\x01\n\x0eBlockInventory\
    \x122\n\x03ids\x18\x01\x20\x03(\x0b2\x20.protocol.BlockInventory.BlockId\
    R\x03ids\x121\n\x04type\x18\x02\x20\x01(\x0e2\x1d.protocol.BlockInventor\
    y.TypeR\x04type\x1a5\n\x07BlockId\x12\x12\n\x04hash\x18\x01\x20\x01(\x0c\
    R\x04hash\x12\x16\n\x06number\x18\x02\x20\x01(\x03R\x06number\"(\n\x04Ty\
    pe\x12\x08\n\x04SYNC\x10\0\x12\x0b\n\x07ADVTISE\x10\x01\x12\t\n\x05FETCH\
    \x10\x02\"y\n\tInventory\x125\n\x04type\x18\x01\x20\x01(\x0e2!.protocol.\
    Inventory.InventoryTypeR\x04type\x12\x10\n\x03ids\x18\x02\x20\x03(\x0cR\
    \x03ids\"#\n\rInventoryType\x12\x07\n\x03TRX\x10\0\x12\t\n\x05BLOCK\x10\
    \x01\"\x8f\x02\n\x05Items\x12,\n\x04type\x18\x01\x20\x01(\x0e2\x18.proto\
    col.Items.ItemTypeR\x04type\x12'\n\x06blocks\x18\x02\x20\x03(\x0b2\x0f.p\
    rotocol.BlockR\x06blocks\x12:\n\rblock_headers\x18\x03\x20\x03(\x0b2\x15\
    .protocol.BlockHeaderR\x0cblockHeaders\x129\n\x0ctransactions\x18\x04\
    \x20\x03(\x0b2\x15.protocol.TransactionR\x0ctransactions\"8\n\x08ItemTyp\
    e\x12\x07\n\x03ERR\x10\0\x12\x07\n\x03TRX\x10\x01\x12\t\n\x05BLOCK\x10\
    \x02\x12\x0f\n\x0bBLOCKHEADER\x10\x03\"J\n\x11DynamicProperties\x125\n\
    \x17last_solidity_block_num\x18\x01\x20\x01(\x03R\x14lastSolidityBlockNu\
    m\"A\n\x11DisconnectMessage\x12,\n\x06reason\x18\x01\x20\x01(\x0e2\x14.p\
    rotocol.ReasonCodeR\x06reason\"\xef\x03\n\x0cHelloMessage\x12&\n\x04from\
    \x18\x01\x20\x01(\x0b2\x12.protocol.EndpointR\x04from\x12\x18\n\x07versi\
    on\x18\x02\x20\x01(\x05R\x07version\x12\x1c\n\ttimestamp\x18\x03\x20\x01\
    (\x03R\ttimestamp\x12F\n\x0egenesisBlockId\x18\x04\x20\x01(\x0b2\x1e.pro\
    tocol.HelloMessage.BlockIdR\x0egenesisBlockId\x12B\n\x0csolidBlockId\x18\
    \x05\x20\x01(\x0b2\x1e.protocol.HelloMessage.BlockIdR\x0csolidBlockId\
    \x12@\n\x0bheadBlockId\x18\x06\x20\x01(\x0b2\x1e.protocol.HelloMessage.B\
    lockIdR\x0bheadBlockId\x12\x18\n\x07address\x18\x07\x20\x01(\x0cR\x07add\
    ress\x12\x1c\n\tsignature\x18\x08\x20\x01(\x0cR\tsignature\x12\x1a\n\x08\
    nodeType\x18\t\x20\x01(\x05R\x08nodeType\x12&\n\x0elowestBlockNum\x18\n\
    \x20\x01(\x03R\x0elowestBlockNum\x1a5\n\x07BlockId\x12\x12\n\x04hash\x18\
    \x01\x20\x01(\x0cR\x04hash\x12\x16\n\x06number\x18\x02\x20\x01(\x03R\x06\
    number\"\xe1\x02\n\x13InternalTransaction\x12\x12\n\x04hash\x18\x01\x20\
    \x01(\x0cR\x04hash\x12%\n\x0ecaller_address\x18\x02\x20\x01(\x0cR\rcalle\
    rAddress\x12-\n\x12transferTo_address\x18\x03\x20\x01(\x0cR\x11transferT\
    oAddress\x12Q\n\rcallValueInfo\x18\x04\x20\x03(\x0b2+.protocol.InternalT\
    ransaction.CallValueInfoR\rcallValueInfo\x12\x12\n\x04note\x18\x05\x20\
    \x01(\x0cR\x04note\x12\x1a\n\x08rejected\x18\x06\x20\x01(\x08R\x08reject\
    ed\x12\x14\n\x05extra\x18\x07\x20\x01(\tR\x05extra\x1aG\n\rCallValueInfo\
    \x12\x1c\n\tcallValue\x18\x01\x20\x01(\x03R\tcallValue\x12\x18\n\x07toke\
    nId\x18\x02\x20\x01(\tR\x07tokenId\"}\n\x1dDelegatedResourceAccountIndex\
    \x12\x18\n\x07account\x18\x01\x20\x01(\x0cR\x07account\x12\"\n\x0cfromAc\
    counts\x18\x02\x20\x03(\x0cR\x0cfromAccounts\x12\x1e\n\ntoAccounts\x18\
    \x03\x20\x03(\x0cR\ntoAccounts\"\xbd\x1a\n\x08NodeInfo\x12\"\n\x0cbeginS\
    yncNum\x18\x01\x20\x01(\x03R\x0cbeginSyncNum\x12\x14\n\x05block\x18\x02\
    \x20\x01(\tR\x05block\x12$\n\rsolidityBlock\x18\x03\x20\x01(\tR\rsolidit\
    yBlock\x120\n\x13currentConnectCount\x18\x04\x20\x01(\x05R\x13currentCon\
    nectCount\x12.\n\x12activeConnectCount\x18\x05\x20\x01(\x05R\x12activeCo\
    nnectCount\x120\n\x13passiveConnectCount\x18\x06\x20\x01(\x05R\x13passiv\
    eConnectCount\x12\x1c\n\ttotalFlow\x18\x07\x20\x01(\x03R\ttotalFlow\x12?\
    \n\x0cpeerInfoList\x18\x08\x20\x03(\x0b2\x1b.protocol.NodeInfo.PeerInfoR\
    \x0cpeerInfoList\x12I\n\x0econfigNodeInfo\x18\t\x20\x01(\x0b2!.protocol.\
    NodeInfo.ConfigNodeInfoR\x0econfigNodeInfo\x12@\n\x0bmachineInfo\x18\n\
    \x20\x01(\x0b2\x1e.protocol.NodeInfo.MachineInfoR\x0bmachineInfo\x12]\n\
    \x13cheatWitnessInfoMap\x18\x0b\x20\x03(\x0b2+.protocol.NodeInfo.CheatWi\
    tnessInfoMapEntryR\x13cheatWitnessInfoMap\x1aF\n\x18CheatWitnessInfoMapE\
    ntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\x1a\xc8\x07\n\x08PeerInfo\x12$\n\rla\
    stSyncBlock\x18\x01\x20\x01(\tR\rlastSyncBlock\x12\x1c\n\tremainNum\x18\
    \x02\x20\x01(\x03R\tremainNum\x120\n\x13lastBlockUpdateTime\x18\x03\x20\
    \x01(\x03R\x13lastBlockUpdateTime\x12\x1a\n\x08syncFlag\x18\x04\x20\x01(\
    \x08R\x08syncFlag\x128\n\x17headBlockTimeWeBothHave\x18\x05\x20\x01(\x03\
    R\x17headBlockTimeWeBothHave\x12*\n\x10needSyncFromPeer\x18\x06\x20\x01(\
    \x08R\x10needSyncFromPeer\x12&\n\x0eneedSyncFromUs\x18\x07\x20\x01(\x08R\
    \x0eneedSyncFromUs\x12\x12\n\x04host\x18\x08\x20\x01(\tR\x04host\x12\x12\
    \n\x04port\x18\t\x20\x01(\x05R\x04port\x12\x16\n\x06nodeId\x18\n\x20\x01\
    (\tR\x06nodeId\x12\x20\n\x0bconnectTime\x18\x0b\x20\x01(\x03R\x0bconnect\
    Time\x12\x1e\n\navgLatency\x18\x0c\x20\x01(\x01R\navgLatency\x12(\n\x0fs\
    yncToFetchSize\x18\r\x20\x01(\x05R\x0fsyncToFetchSize\x126\n\x16syncToFe\
    tchSizePeekNum\x18\x0e\x20\x01(\x03R\x16syncToFetchSizePeekNum\x126\n\
    \x16syncBlockRequestedSize\x18\x0f\x20\x01(\x05R\x16syncBlockRequestedSi\
    ze\x12$\n\runFetchSynNum\x18\x10\x20\x01(\x03R\runFetchSynNum\x12(\n\x0f\
    blockInPorcSize\x18\x11\x20\x01(\x05R\x0fblockInPorcSize\x120\n\x13headB\
    lockWeBothHave\x18\x12\x20\x01(\tR\x13headBlockWeBothHave\x12\x1a\n\x08i\
    sActive\x18\x13\x20\x01(\x08R\x08isActive\x12\x14\n\x05score\x18\x14\x20\
    \x01(\x05R\x05score\x12\x1c\n\tnodeCount\x18\x15\x20\x01(\x05R\tnodeCoun\
    t\x12\x16\n\x06inFlow\x18\x16\x20\x01(\x03R\x06inFlow\x12(\n\x0fdisconne\
    ctTimes\x18\x17\x20\x01(\x05R\x0fdisconnectTimes\x124\n\x15localDisconne\
    ctReason\x18\x18\x20\x01(\tR\x15localDisconnectReason\x126\n\x16remoteDi\
    sconnectReason\x18\x19\x20\x01(\tR\x16remoteDisconnectReason\x1a\xa2\x06\
    \n\x0eConfigNodeInfo\x12\x20\n\x0bcodeVersion\x18\x01\x20\x01(\tR\x0bcod\
    eVersion\x12\x1e\n\np2pVersion\x18\x02\x20\x01(\tR\np2pVersion\x12\x1e\n\
    \nlistenPort\x18\x03\x20\x01(\x05R\nlistenPort\x12&\n\x0ediscoverEnable\
    \x18\x04\x20\x01(\x08R\x0ediscoverEnable\x12&\n\x0eactiveNodeSize\x18\
    \x05\x20\x01(\x05R\x0eactiveNodeSize\x12(\n\x0fpassiveNodeSize\x18\x06\
    \x20\x01(\x05R\x0fpassiveNodeSize\x12\"\n\x0csendNodeSize\x18\x07\x20\
    \x01(\x05R\x0csendNodeSize\x12(\n\x0fmaxConnectCount\x18\x08\x20\x01(\
    \x05R\x0fmaxConnectCount\x124\n\x15sameIpMaxConnectCount\x18\t\x20\x01(\
    \x05R\x15sameIpMaxConnectCount\x12*\n\x10backupListenPort\x18\n\x20\x01(\
    \x05R\x10backupListenPort\x12*\n\x10backupMemberSize\x18\x0b\x20\x01(\
    \x05R\x10backupMemberSize\x12&\n\x0ebackupPriority\x18\x0c\x20\x01(\x05R\
    \x0ebackupPriority\x12\x1c\n\tdbVersion\x18\r\x20\x01(\x05R\tdbVersion\
    \x122\n\x14minParticipationRate\x18\x0e\x20\x01(\x05R\x14minParticipatio\
    nRate\x12(\n\x0fsupportConstant\x18\x0f\x20\x01(\x08R\x0fsupportConstant\
    \x12\"\n\x0cminTimeRatio\x18\x10\x20\x01(\x01R\x0cminTimeRatio\x12\"\n\
    \x0cmaxTimeRatio\x18\x11\x20\x01(\x01R\x0cmaxTimeRatio\x12:\n\x18allowCr\
    eationOfContracts\x18\x12\x20\x01(\x03R\x18allowCreationOfContracts\x120\
    \n\x13allowAdaptiveEnergy\x18\x13\x20\x01(\x03R\x13allowAdaptiveEnergy\
    \x1a\xb9\x07\n\x0bMachineInfo\x12\x20\n\x0bthreadCount\x18\x01\x20\x01(\
    \x05R\x0bthreadCount\x120\n\x13deadLockThreadCount\x18\x02\x20\x01(\x05R\
    \x13deadLockThreadCount\x12\x1a\n\x08cpuCount\x18\x03\x20\x01(\x05R\x08c\
    puCount\x12\x20\n\x0btotalMemory\x18\x04\x20\x01(\x03R\x0btotalMemory\
    \x12\x1e\n\nfreeMemory\x18\x05\x20\x01(\x03R\nfreeMemory\x12\x18\n\x07cp\
    uRate\x18\x06\x20\x01(\x01R\x07cpuRate\x12\x20\n\x0bjavaVersion\x18\x07\
    \x20\x01(\tR\x0bjavaVersion\x12\x16\n\x06osName\x18\x08\x20\x01(\tR\x06o\
    sName\x12&\n\x0ejvmTotalMemory\x18\t\x20\x01(\x03R\x0ejvmTotalMemory\x12\
    $\n\rjvmFreeMemory\x18\n\x20\x01(\x03R\rjvmFreeMemory\x12&\n\x0eprocessC\
    puRate\x18\x0b\x20\x01(\x01R\x0eprocessCpuRate\x12]\n\x12memoryDescInfoL\
    ist\x18\x0c\x20\x03(\x0b2-.protocol.NodeInfo.MachineInfo.MemoryDescInfoR\
    \x12memoryDescInfoList\x12i\n\x16deadLockThreadInfoList\x18\r\x20\x03(\
    \x0b21.protocol.NodeInfo.MachineInfo.DeadLockThreadInfoR\x16deadLockThre\
    adInfoList\x1a\x8e\x01\n\x0eMemoryDescInfo\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12\x1a\n\x08initSize\x18\x02\x20\x01(\x03R\x08initSize\
    \x12\x18\n\x07useSize\x18\x03\x20\x01(\x03R\x07useSize\x12\x18\n\x07maxS\
    ize\x18\x04\x20\x01(\x03R\x07maxSize\x12\x18\n\x07useRate\x18\x05\x20\
    \x01(\x01R\x07useRate\x1a\xd2\x01\n\x12DeadLockThreadInfo\x12\x12\n\x04n\
    ame\x18\x01\x20\x01(\tR\x04name\x12\x1a\n\x08lockName\x18\x02\x20\x01(\t\
    R\x08lockName\x12\x1c\n\tlockOwner\x18\x03\x20\x01(\tR\tlockOwner\x12\
    \x14\n\x05state\x18\x04\x20\x01(\tR\x05state\x12\x1c\n\tblockTime\x18\
    \x05\x20\x01(\x03R\tblockTime\x12\x1a\n\x08waitTime\x18\x06\x20\x01(\x03\
    R\x08waitTime\x12\x1e\n\nstackTrace\x18\x07\x20\x01(\tR\nstackTrace\"\
    \xc0\x18\n\x0bMetricsInfo\x12\x1a\n\x08interval\x18\x01\x20\x01(\x03R\
    \x08interval\x122\n\x04node\x18\x02\x20\x01(\x0b2\x1e.protocol.MetricsIn\
    fo.NodeInfoR\x04node\x12D\n\nblockchain\x18\x03\x20\x01(\x0b2$.protocol.\
    MetricsInfo.BlockChainInfoR\nblockchain\x12/\n\x03net\x18\x04\x20\x01(\
    \x0b2\x1d.protocol.MetricsInfo.NetInfoR\x03net\x1at\n\x08NodeInfo\x12\
    \x0e\n\x02ip\x18\x01\x20\x01(\tR\x02ip\x12\x1a\n\x08nodeType\x18\x02\x20\
    \x01(\x05R\x08nodeType\x12\x18\n\x07version\x18\x03\x20\x01(\tR\x07versi\
    on\x12\"\n\x0cbackupStatus\x18\x04\x20\x01(\x05R\x0cbackupStatus\x1a\xee\
    \x06\n\x0eBlockChainInfo\x12\"\n\x0cheadBlockNum\x18\x01\x20\x01(\x03R\
    \x0cheadBlockNum\x12.\n\x12headBlockTimestamp\x18\x02\x20\x01(\x03R\x12h\
    eadBlockTimestamp\x12$\n\rheadBlockHash\x18\x03\x20\x01(\tR\rheadBlockHa\
    sh\x12\x1c\n\tforkCount\x18\x04\x20\x01(\x05R\tforkCount\x12$\n\rfailFor\
    kCount\x18\x05\x20\x01(\x05R\rfailForkCount\x12J\n\x10blockProcessTime\
    \x18\x06\x20\x01(\x0b2\x1e.protocol.MetricsInfo.RateInfoR\x10blockProces\
    sTime\x120\n\x03tps\x18\x07\x20\x01(\x0b2\x1e.protocol.MetricsInfo.RateI\
    nfoR\x03tps\x122\n\x14transactionCacheSize\x18\x08\x20\x01(\x05R\x14tran\
    sactionCacheSize\x12L\n\x11missedTransaction\x18\t\x20\x01(\x0b2\x1e.pro\
    tocol.MetricsInfo.RateInfoR\x11missedTransaction\x12J\n\twitnesses\x18\n\
    \x20\x03(\x0b2,.protocol.MetricsInfo.BlockChainInfo.WitnessR\twitnesses\
    \x120\n\x13failProcessBlockNum\x18\x0b\x20\x01(\x03R\x13failProcessBlock\
    Num\x126\n\x16failProcessBlockReason\x18\x0c\x20\x01(\tR\x16failProcessB\
    lockReason\x12O\n\ndupWitness\x18\r\x20\x03(\x0b2/.protocol.MetricsInfo.\
    BlockChainInfo.DupWitnessR\ndupWitness\x1a=\n\x07Witness\x12\x18\n\x07ad\
    dress\x18\x01\x20\x01(\tR\x07address\x12\x18\n\x07version\x18\x02\x20\
    \x01(\x05R\x07version\x1aX\n\nDupWitness\x12\x18\n\x07address\x18\x01\
    \x20\x01(\tR\x07address\x12\x1a\n\x08blockNum\x18\x02\x20\x01(\x03R\x08b\
    lockNum\x12\x14\n\x05count\x18\x03\x20\x01(\x05R\x05count\x1a\xb8\x01\n\
    \x08RateInfo\x12\x14\n\x05count\x18\x01\x20\x01(\x03R\x05count\x12\x1a\n\
    \x08meanRate\x18\x02\x20\x01(\x01R\x08meanRate\x12$\n\roneMinuteRate\x18\
    \x03\x20\x01(\x01R\roneMinuteRate\x12&\n\x0efiveMinuteRate\x18\x04\x20\
    \x01(\x01R\x0efiveMinuteRate\x12,\n\x11fifteenMinuteRate\x18\x05\x20\x01\
    (\x01R\x11fifteenMinuteRate\x1a\xc7\r\n\x07NetInfo\x12(\n\x0ferrorProtoC\
    ount\x18\x01\x20\x01(\x05R\x0ferrorProtoCount\x127\n\x03api\x18\x02\x20\
    \x01(\x0b2%.protocol.MetricsInfo.NetInfo.ApiInfoR\x03api\x12(\n\x0fconne\
    ctionCount\x18\x03\x20\x01(\x05R\x0fconnectionCount\x122\n\x14validConne\
    ctionCount\x18\x04\x20\x01(\x05R\x14validConnectionCount\x12B\n\x0ctcpIn\
    Traffic\x18\x05\x20\x01(\x0b2\x1e.protocol.MetricsInfo.RateInfoR\x0ctcpI\
    nTraffic\x12D\n\rtcpOutTraffic\x18\x06\x20\x01(\x0b2\x1e.protocol.Metric\
    sInfo.RateInfoR\rtcpOutTraffic\x12.\n\x12disconnectionCount\x18\x07\x20\
    \x01(\x05R\x12disconnectionCount\x12g\n\x13disconnectionDetail\x18\x08\
    \x20\x03(\x0b25.protocol.MetricsInfo.NetInfo.DisconnectionDetailInfoR\
    \x13disconnectionDetail\x12B\n\x0cudpInTraffic\x18\t\x20\x01(\x0b2\x1e.p\
    rotocol.MetricsInfo.RateInfoR\x0cudpInTraffic\x12D\n\rudpOutTraffic\x18\
    \n\x20\x01(\x0b2\x1e.protocol.MetricsInfo.RateInfoR\rudpOutTraffic\x12C\
    \n\x07latency\x18\x0b\x20\x01(\x0b2).protocol.MetricsInfo.NetInfo.Latenc\
    yInfoR\x07latency\x1a\xd4\x03\n\x07ApiInfo\x120\n\x03qps\x18\x01\x20\x01\
    (\x0b2\x1e.protocol.MetricsInfo.RateInfoR\x03qps\x128\n\x07failQps\x18\
    \x02\x20\x01(\x0b2\x1e.protocol.MetricsInfo.RateInfoR\x07failQps\x12>\n\
    \noutTraffic\x18\x03\x20\x01(\x0b2\x1e.protocol.MetricsInfo.RateInfoR\no\
    utTraffic\x12K\n\x06detail\x18\x04\x20\x03(\x0b23.protocol.MetricsInfo.N\
    etInfo.ApiInfo.ApiDetailInfoR\x06detail\x1a\xcf\x01\n\rApiDetailInfo\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x120\n\x03qps\x18\x02\x20\x01\
    (\x0b2\x1e.protocol.MetricsInfo.RateInfoR\x03qps\x128\n\x07failQps\x18\
    \x03\x20\x01(\x0b2\x1e.protocol.MetricsInfo.RateInfoR\x07failQps\x12>\n\
    \noutTraffic\x18\x04\x20\x01(\x0b2\x1e.protocol.MetricsInfo.RateInfoR\no\
    utTraffic\x1aG\n\x17DisconnectionDetailInfo\x12\x16\n\x06reason\x18\x01\
    \x20\x01(\tR\x06reason\x12\x14\n\x05count\x18\x02\x20\x01(\x05R\x05count\
    \x1a\xe8\x03\n\x0bLatencyInfo\x12\x14\n\x05top99\x18\x01\x20\x01(\x05R\
    \x05top99\x12\x14\n\x05top95\x18\x02\x20\x01(\x05R\x05top95\x12\x14\n\
    \x05top75\x18\x03\x20\x01(\x05R\x05top75\x12\x1e\n\ntotalCount\x18\x04\
    \x20\x01(\x05R\ntotalCount\x12\x18\n\x07delay1S\x18\x05\x20\x01(\x05R\
    \x07delay1S\x12\x18\n\x07delay2S\x18\x06\x20\x01(\x05R\x07delay2S\x12\
    \x18\n\x07delay3S\x18\x07\x20\x01(\x05R\x07delay3S\x12S\n\x06detail\x18\
    \x08\x20\x03(\x0b2;.protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDeta\
    ilInfoR\x06detail\x1a\xd3\x01\n\x11LatencyDetailInfo\x12\x18\n\x07witnes\
    s\x18\x01\x20\x01(\tR\x07witness\x12\x14\n\x05top99\x18\x02\x20\x01(\x05\
    R\x05top99\x12\x14\n\x05top95\x18\x03\x20\x01(\x05R\x05top95\x12\x14\n\
    \x05top75\x18\x04\x20\x01(\x05R\x05top75\x12\x14\n\x05count\x18\x05\x20\
    \x01(\x05R\x05count\x12\x18\n\x07delay1S\x18\x06\x20\x01(\x05R\x07delay1\
    S\x12\x18\n\x07delay2S\x18\x07\x20\x01(\x05R\x07delay2S\x12\x18\n\x07del\
    ay3S\x18\x08\x20\x01(\x05R\x07delay3S\"\x93\x03\n\x0bPBFTMessage\x124\n\
    \x08raw_data\x18\x01\x20\x01(\x0b2\x19.protocol.PBFTMessage.RawR\x07rawD\
    ata\x12\x1c\n\tsignature\x18\x02\x20\x01(\x0cR\tsignature\x1a\xbd\x01\n\
    \x03Raw\x128\n\x08msg_type\x18\x01\x20\x01(\x0e2\x1d.protocol.PBFTMessag\
    e.MsgTypeR\x07msgType\x12;\n\tdata_type\x18\x02\x20\x01(\x0e2\x1e.protoc\
    ol.PBFTMessage.DataTypeR\x08dataType\x12\x15\n\x06view_n\x18\x03\x20\x01\
    (\x03R\x05viewN\x12\x14\n\x05epoch\x18\x04\x20\x01(\x03R\x05epoch\x12\
    \x12\n\x04data\x18\x05\x20\x01(\x0cR\x04data\"P\n\x07MsgType\x12\x0f\n\
    \x0bVIEW_CHANGE\x10\0\x12\x0b\n\x07REQUEST\x10\x01\x12\x0e\n\nPREPREPARE\
    \x10\x02\x12\x0b\n\x07PREPARE\x10\x03\x12\n\n\x06COMMIT\x10\x04\"\x1e\n\
    \x08DataType\x12\t\n\x05BLOCK\x10\0\x12\x07\n\x03SRL\x10\x01\"D\n\x10PBF\
    TCommitResult\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\x12\x1c\n\
    \tsignature\x18\x02\x20\x03(\x0cR\tsignature\"#\n\x03SRL\x12\x1c\n\tsrAd\
    dress\x18\x01\x20\x03(\x0cR\tsrAddress*7\n\x0bAccountType\x12\n\n\x06Nor\
    mal\x10\0\x12\x0e\n\nAssetIssue\x10\x01\x12\x0c\n\x08Contract\x10\x02*\
    \xe1\x03\n\nReasonCode\x12\r\n\tREQUESTED\x10\0\x12\x10\n\x0cBAD_PROTOCO\
    L\x10\x02\x12\x12\n\x0eTOO_MANY_PEERS\x10\x04\x12\x12\n\x0eDUPLICATE_PEE\
    R\x10\x05\x12\x19\n\x15INCOMPATIBLE_PROTOCOL\x10\x06\x12\x11\n\rNULL_IDE\
    NTITY\x10\x07\x12\x10\n\x0cPEER_QUITING\x10\x08\x12\x17\n\x13UNEXPECTED_\
    IDENTITY\x10\t\x12\x12\n\x0eLOCAL_IDENTITY\x10\n\x12\x10\n\x0cPING_TIMEO\
    UT\x10\x0b\x12\x0f\n\x0bUSER_REASON\x10\x10\x12\t\n\x05RESET\x10\x11\x12\
    \r\n\tSYNC_FAIL\x10\x12\x12\x0e\n\nFETCH_FAIL\x10\x13\x12\n\n\x06BAD_TX\
    \x10\x14\x12\r\n\tBAD_BLOCK\x10\x15\x12\n\n\x06FORKED\x10\x16\x12\x0e\n\
    \nUNLINKABLE\x10\x17\x12\x18\n\x14INCOMPATIBLE_VERSION\x10\x18\x12\x16\n\
    \x12INCOMPATIBLE_CHAIN\x10\x19\x12\x0c\n\x08TIME_OUT\x10\x20\x12\x10\n\
    \x0cCONNECT_FAIL\x10!\x12\x1f\n\x1bTOO_MANY_PEERS_WITH_SAME_IP\x10\"\x12\
    \x18\n\x14LIGHT_NODE_SYNC_FAIL\x10#\x12\x0c\n\x07UNKNOWN\x10\xff\x01BF\n\
    \x0forg.tron.protosB\x08ProtocolZ)github.com/tronprotocol/grpc-gateway/c\
    oreJ\xc2\xa4\x02\n\x07\x12\x05\0\0\xd7\x06\x01\n\x08\n\x01\x0c\x12\x03\0\
    \0\x12\n\t\n\x02\x03\0\x12\x03\x02\0#\n\t\n\x02\x03\x01\x12\x03\x03\0\
    \x1d\n\x08\n\x01\x02\x12\x03\x05\0\x11\n\x08\n\x01\x08\x12\x03\x08\0(\nH\
    \n\x02\x08\x01\x12\x03\x08\0(\"=Specify\x20the\x20name\x20of\x20the\x20p\
    ackage\x20that\x20generated\x20the\x20Java\x20file\n\n\x08\n\x01\x08\x12\
    \x03\t\0)\n=\n\x02\x08\x08\x12\x03\t\0)\"2Specify\x20the\x20class\x20nam\
    e\x20of\x20the\x20generated\x20Java\x20file\n\n\x08\n\x01\x08\x12\x03\n\
    \0@\n\t\n\x02\x08\x0b\x12\x03\n\0@\n\n\n\x02\x05\0\x12\x04\x0c\0\x10\x01\
    \n\n\n\x03\x05\0\x01\x12\x03\x0c\x05\x10\n\x0b\n\x04\x05\0\x02\0\x12\x03\
    \r\x02\r\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\r\x02\x08\n\x0c\n\x05\x05\0\
    \x02\0\x02\x12\x03\r\x0b\x0c\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x0e\x02\
    \x11\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x0e\x02\x0c\n\x0c\n\x05\x05\0\
    \x02\x01\x02\x12\x03\x0e\x0f\x10\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x0f\
    \x02\x0f\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x0f\x02\n\n\x0c\n\x05\x05\
    \0\x02\x02\x02\x12\x03\x0f\r\x0e\nf\n\x02\x04\0\x12\x04\x13\0\x16\x01\
    \x1aZ\x20AccountId,\x20(name,\x20address)\x20use\x20name,\x20(null,\x20a\
    ddress)\x20use\x20address,\x20(name,\x20null)\x20use\x20name,\n\n\n\n\
    \x03\x04\0\x01\x12\x03\x13\x08\x11\n\x0b\n\x04\x04\0\x02\0\x12\x03\x14\
    \x02\x11\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x14\x02\x07\n\x0c\n\x05\x04\
    \0\x02\0\x01\x12\x03\x14\x08\x0c\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x14\
    \x0f\x10\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x15\x02\x14\n\x0c\n\x05\x04\0\
    \x02\x01\x05\x12\x03\x15\x02\x07\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\
    \x15\x08\x0f\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x15\x12\x13\n\x1a\n\
    \x02\x04\x01\x12\x04\x19\0\x1e\x01\x1a\x0e\x20vote\x20message\n\n\n\n\
    \x03\x04\x01\x01\x12\x03\x19\x08\x0c\n$\n\x04\x04\x01\x02\0\x12\x03\x1b\
    \x02\x19\x1a\x17\x20the\x20super\x20rep\x20address\n\n\x0c\n\x05\x04\x01\
    \x02\0\x05\x12\x03\x1b\x02\x07\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x1b\
    \x08\x14\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x1b\x17\x18\n.\n\x04\x04\
    \x01\x02\x01\x12\x03\x1d\x02\x17\x1a!\x20the\x20vote\x20num\x20to\x20thi\
    s\x20super\x20rep.\n\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\x1d\x02\x07\
    \n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x1d\x08\x12\n\x0c\n\x05\x04\x01\
    \x02\x01\x03\x12\x03\x1d\x15\x16\n\x16\n\x02\x04\x02\x12\x04!\0/\x01\x1a\
    \n\x20Proposal\n\n\n\n\x03\x04\x02\x01\x12\x03!\x08\x10\n\x0b\n\x04\x04\
    \x02\x02\0\x12\x03\"\x02\x18\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03\"\x02\
    \x07\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\"\x08\x13\n\x0c\n\x05\x04\x02\
    \x02\0\x03\x12\x03\"\x16\x17\n\x0b\n\x04\x04\x02\x02\x01\x12\x03#\x02\
    \x1d\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03#\x02\x07\n\x0c\n\x05\x04\
    \x02\x02\x01\x01\x12\x03#\x08\x18\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\
    \x03#\x1b\x1c\n\x0b\n\x04\x04\x02\x02\x02\x12\x03$\x02#\n\x0c\n\x05\x04\
    \x02\x02\x02\x06\x12\x03$\x02\x13\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\
    \x03$\x14\x1e\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03$!\"\n\x0b\n\x04\
    \x04\x02\x02\x03\x12\x03%\x02\x1c\n\x0c\n\x05\x04\x02\x02\x03\x05\x12\
    \x03%\x02\x07\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03%\x08\x17\n\x0c\n\
    \x05\x04\x02\x02\x03\x03\x12\x03%\x1a\x1b\n\x0b\n\x04\x04\x02\x02\x04\
    \x12\x03&\x02\x18\n\x0c\n\x05\x04\x02\x02\x04\x05\x12\x03&\x02\x07\n\x0c\
    \n\x05\x04\x02\x02\x04\x01\x12\x03&\x08\x13\n\x0c\n\x05\x04\x02\x02\x04\
    \x03\x12\x03&\x16\x17\n\x0b\n\x04\x04\x02\x02\x05\x12\x03'\x02\x1f\n\x0c\
    \n\x05\x04\x02\x02\x05\x04\x12\x03'\x02\n\n\x0c\n\x05\x04\x02\x02\x05\
    \x05\x12\x03'\x0b\x10\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x03'\x11\x1a\n\
    \x0c\n\x05\x04\x02\x02\x05\x03\x12\x03'\x1d\x1e\n\x0c\n\x04\x04\x02\x04\
    \0\x12\x04(\x02-\x03\n\x0c\n\x05\x04\x02\x04\0\x01\x12\x03(\x07\x0c\n\r\
    \n\x06\x04\x02\x04\0\x02\0\x12\x03)\x04\x10\n\x0e\n\x07\x04\x02\x04\0\
    \x02\0\x01\x12\x03)\x04\x0b\n\x0e\n\x07\x04\x02\x04\0\x02\0\x02\x12\x03)\
    \x0e\x0f\n\r\n\x06\x04\x02\x04\0\x02\x01\x12\x03*\x04\x14\n\x0e\n\x07\
    \x04\x02\x04\0\x02\x01\x01\x12\x03*\x04\x0f\n\x0e\n\x07\x04\x02\x04\0\
    \x02\x01\x02\x12\x03*\x12\x13\n\r\n\x06\x04\x02\x04\0\x02\x02\x12\x03+\
    \x04\x11\n\x0e\n\x07\x04\x02\x04\0\x02\x02\x01\x12\x03+\x04\x0c\n\x0e\n\
    \x07\x04\x02\x04\0\x02\x02\x02\x12\x03+\x0f\x10\n\r\n\x06\x04\x02\x04\0\
    \x02\x03\x12\x03,\x04\x11\n\x0e\n\x07\x04\x02\x04\0\x02\x03\x01\x12\x03,\
    \x04\x0c\n\x0e\n\x07\x04\x02\x04\0\x02\x03\x02\x12\x03,\x0f\x10\n\x0b\n\
    \x04\x04\x02\x02\x06\x12\x03.\x02\x12\n\x0c\n\x05\x04\x02\x02\x06\x06\
    \x12\x03.\x02\x07\n\x0c\n\x05\x04\x02\x02\x06\x01\x12\x03.\x08\r\n\x0c\n\
    \x05\x04\x02\x02\x06\x03\x12\x03.\x10\x11\n\x16\n\x02\x04\x03\x12\x042\0\
    :\x01\x1a\n\x20Exchange\n\n\n\n\x03\x04\x03\x01\x12\x032\x08\x10\n\x0b\n\
    \x04\x04\x03\x02\0\x12\x033\x02\x18\n\x0c\n\x05\x04\x03\x02\0\x05\x12\
    \x033\x02\x07\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x033\x08\x13\n\x0c\n\x05\
    \x04\x03\x02\0\x03\x12\x033\x16\x17\n\x0b\n\x04\x04\x03\x02\x01\x12\x034\
    \x02\x1c\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x034\x02\x07\n\x0c\n\x05\
    \x04\x03\x02\x01\x01\x12\x034\x08\x17\n\x0c\n\x05\x04\x03\x02\x01\x03\
    \x12\x034\x1a\x1b\n\x0b\n\x04\x04\x03\x02\x02\x12\x035\x02\x18\n\x0c\n\
    \x05\x04\x03\x02\x02\x05\x12\x035\x02\x07\n\x0c\n\x05\x04\x03\x02\x02\
    \x01\x12\x035\x08\x13\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x035\x16\x17\n\
    \x0b\n\x04\x04\x03\x02\x03\x12\x036\x02\x1b\n\x0c\n\x05\x04\x03\x02\x03\
    \x05\x12\x036\x02\x07\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x036\x08\x16\n\
    \x0c\n\x05\x04\x03\x02\x03\x03\x12\x036\x19\x1a\n\x0b\n\x04\x04\x03\x02\
    \x04\x12\x037\x02\x20\n\x0c\n\x05\x04\x03\x02\x04\x05\x12\x037\x02\x07\n\
    \x0c\n\x05\x04\x03\x02\x04\x01\x12\x037\x08\x1b\n\x0c\n\x05\x04\x03\x02\
    \x04\x03\x12\x037\x1e\x1f\n\x0b\n\x04\x04\x03\x02\x05\x12\x038\x02\x1c\n\
    \x0c\n\x05\x04\x03\x02\x05\x05\x12\x038\x02\x07\n\x0c\n\x05\x04\x03\x02\
    \x05\x01\x12\x038\x08\x17\n\x0c\n\x05\x04\x03\x02\x05\x03\x12\x038\x1a\
    \x1b\n\x0b\n\x04\x04\x03\x02\x06\x12\x039\x02!\n\x0c\n\x05\x04\x03\x02\
    \x06\x05\x12\x039\x02\x07\n\x0c\n\x05\x04\x03\x02\x06\x01\x12\x039\x08\
    \x1c\n\x0c\n\x05\x04\x03\x02\x06\x03\x12\x039\x1f\x20\n\x14\n\x02\x04\
    \x04\x12\x04=\0S\x01\x1a\x08\x20market\n\n\n\n\x03\x04\x04\x01\x12\x03=\
    \x08\x13\n\x0b\n\x04\x04\x04\x02\0\x12\x03>\x04\x17\n\x0c\n\x05\x04\x04\
    \x02\0\x05\x12\x03>\x04\t\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03>\n\x12\n\
    \x0c\n\x05\x04\x04\x02\0\x03\x12\x03>\x15\x16\n\x0b\n\x04\x04\x04\x02\
    \x01\x12\x03?\x04\x1c\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03?\x04\t\n\
    \x0c\n\x05\x04\x04\x02\x01\x01\x12\x03?\n\x17\n\x0c\n\x05\x04\x04\x02\
    \x01\x03\x12\x03?\x1a\x1b\n\x0b\n\x04\x04\x04\x02\x02\x12\x03@\x04\x1a\n\
    \x0c\n\x05\x04\x04\x02\x02\x05\x12\x03@\x04\t\n\x0c\n\x05\x04\x04\x02\
    \x02\x01\x12\x03@\n\x15\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03@\x18\x19\
    \n\x0b\n\x04\x04\x04\x02\x03\x12\x03A\x04\x1c\n\x0c\n\x05\x04\x04\x02\
    \x03\x05\x12\x03A\x04\t\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\x03A\n\x17\n\
    \x0c\n\x05\x04\x04\x02\x03\x03\x12\x03A\x1a\x1b\n\x0b\n\x04\x04\x04\x02\
    \x04\x12\x03B\x04\"\n\x0c\n\x05\x04\x04\x02\x04\x05\x12\x03B\x04\t\n\x0c\
    \n\x05\x04\x04\x02\x04\x01\x12\x03B\n\x1d\n\x0c\n\x05\x04\x04\x02\x04\
    \x03\x12\x03B\x20!\n\x0b\n\x04\x04\x04\x02\x05\x12\x03C\x04\x1b\n\x0c\n\
    \x05\x04\x04\x02\x05\x05\x12\x03C\x04\t\n\x0c\n\x05\x04\x04\x02\x05\x01\
    \x12\x03C\n\x16\n\x0c\n\x05\x04\x04\x02\x05\x03\x12\x03C\x19\x1a\n\x1d\n\
    \x04\x04\x04\x02\x06\x12\x03D\x04!\"\x10\x20min\x20to\x20receive\n\n\x0c\
    \n\x05\x04\x04\x02\x06\x05\x12\x03D\x04\t\n\x0c\n\x05\x04\x04\x02\x06\
    \x01\x12\x03D\n\x1c\n\x0c\n\x05\x04\x04\x02\x06\x03\x12\x03D\x1f\x20\n\
    \x0b\n\x04\x04\x04\x02\x07\x12\x03E\x04)\n\x0c\n\x05\x04\x04\x02\x07\x05\
    \x12\x03E\x04\t\n\x0c\n\x05\x04\x04\x02\x07\x01\x12\x03E\n$\n\x0c\n\x05\
    \x04\x04\x02\x07\x03\x12\x03E'(\n\xa8\x01\n\x04\x04\x04\x02\x08\x12\x03H\
    \x04*\x1a\x9a\x01\x20When\x20state\x20!=\x20ACTIVE\x20and\x20sell_token_\
    quantity_return\x20!=0,\nit\x20means\x20that\x20some\x20sell\x20tokens\
    \x20are\x20returned\x20to\x20the\x20account\x20due\x20to\x20insufficient\
    \x20remaining\x20amount\n\n\x0c\n\x05\x04\x04\x02\x08\x05\x12\x03H\x04\t\
    \n\x0c\n\x05\x04\x04\x02\x08\x01\x12\x03H\n$\n\x0c\n\x05\x04\x04\x02\x08\
    \x03\x12\x03H')\n\x0c\n\x04\x04\x04\x04\0\x12\x04J\x04N\x05\n\x0c\n\x05\
    \x04\x04\x04\0\x01\x12\x03J\t\x0e\n\r\n\x06\x04\x04\x04\0\x02\0\x12\x03K\
    \x06\x11\n\x0e\n\x07\x04\x04\x04\0\x02\0\x01\x12\x03K\x06\x0c\n\x0e\n\
    \x07\x04\x04\x04\0\x02\0\x02\x12\x03K\x0f\x10\n\r\n\x06\x04\x04\x04\0\
    \x02\x01\x12\x03L\x06\x13\n\x0e\n\x07\x04\x04\x04\0\x02\x01\x01\x12\x03L\
    \x06\x0e\n\x0e\n\x07\x04\x04\x04\0\x02\x01\x02\x12\x03L\x11\x12\n\r\n\
    \x06\x04\x04\x04\0\x02\x02\x12\x03M\x06\x13\n\x0e\n\x07\x04\x04\x04\0\
    \x02\x02\x01\x12\x03M\x06\x0e\n\x0e\n\x07\x04\x04\x04\0\x02\x02\x02\x12\
    \x03M\x11\x12\n\x0b\n\x04\x04\x04\x02\t\x12\x03O\x04\x15\n\x0c\n\x05\x04\
    \x04\x02\t\x06\x12\x03O\x04\t\n\x0c\n\x05\x04\x04\x02\t\x01\x12\x03O\n\
    \x0f\n\x0c\n\x05\x04\x04\x02\t\x03\x12\x03O\x12\x14\n\x0b\n\x04\x04\x04\
    \x02\n\x12\x03Q\x04\x14\n\x0c\n\x05\x04\x04\x02\n\x05\x12\x03Q\x04\t\n\
    \x0c\n\x05\x04\x04\x02\n\x01\x12\x03Q\n\x0e\n\x0c\n\x05\x04\x04\x02\n\
    \x03\x12\x03Q\x11\x13\n\x0b\n\x04\x04\x04\x02\x0b\x12\x03R\x04\x14\n\x0c\
    \n\x05\x04\x04\x02\x0b\x05\x12\x03R\x04\t\n\x0c\n\x05\x04\x04\x02\x0b\
    \x01\x12\x03R\n\x0e\n\x0c\n\x05\x04\x04\x02\x0b\x03\x12\x03R\x11\x13\n\n\
    \n\x02\x04\x05\x12\x04U\0W\x01\n\n\n\x03\x04\x05\x01\x12\x03U\x08\x17\n\
    \x0b\n\x04\x04\x05\x02\0\x12\x03V\x04$\n\x0c\n\x05\x04\x05\x02\0\x04\x12\
    \x03V\x04\x0c\n\x0c\n\x05\x04\x05\x02\0\x06\x12\x03V\r\x18\n\x0c\n\x05\
    \x04\x05\x02\0\x01\x12\x03V\x19\x1f\n\x0c\n\x05\x04\x05\x02\0\x03\x12\
    \x03V\"#\n\n\n\x02\x04\x06\x12\x04Y\0[\x01\n\n\n\x03\x04\x06\x01\x12\x03\
    Y\x08\x1b\n\x0b\n\x04\x04\x06\x02\0\x12\x03Z\x02)\n\x0c\n\x05\x04\x06\
    \x02\0\x04\x12\x03Z\x02\n\n\x0c\n\x05\x04\x06\x02\0\x06\x12\x03Z\x0b\x1a\
    \n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03Z\x1b$\n\x0c\n\x05\x04\x06\x02\0\
    \x03\x12\x03Z'(\n\n\n\x02\x04\x07\x12\x04]\0`\x01\n\n\n\x03\x04\x07\x01\
    \x12\x03]\x08\x17\n\x0b\n\x04\x04\x07\x02\0\x12\x03^\x04\x1c\n\x0c\n\x05\
    \x04\x07\x02\0\x05\x12\x03^\x04\t\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03^\
    \n\x17\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03^\x1a\x1b\n\x0b\n\x04\x04\
    \x07\x02\x01\x12\x03_\x04\x1b\n\x0c\n\x05\x04\x07\x02\x01\x05\x12\x03_\
    \x04\t\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03_\n\x16\n\x0c\n\x05\x04\
    \x07\x02\x01\x03\x12\x03_\x19\x1a\n\n\n\x02\x04\x08\x12\x04b\0g\x01\n\n\
    \n\x03\x04\x08\x01\x12\x03b\x08\x1a\n\x0b\n\x04\x04\x08\x02\0\x12\x03c\
    \x02\x1a\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03c\x02\x07\n\x0c\n\x05\x04\
    \x08\x02\0\x01\x12\x03c\x08\x15\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03c\
    \x18\x19\n\x1c\n\x04\x04\x08\x02\x01\x12\x03d\x02\x1c\"\x0f\x20order_id\
    \x20list\n\n\x0c\n\x05\x04\x08\x02\x01\x04\x12\x03d\x02\n\n\x0c\n\x05\
    \x04\x08\x02\x01\x05\x12\x03d\x0b\x10\n\x0c\n\x05\x04\x08\x02\x01\x01\
    \x12\x03d\x11\x17\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\x03d\x1a\x1b\n\x1b\
    \n\x04\x04\x08\x02\x02\x12\x03e\x02\x12\"\x0e\x20active\x20count\n\n\x0c\
    \n\x05\x04\x08\x02\x02\x05\x12\x03e\x02\x07\n\x0c\n\x05\x04\x08\x02\x02\
    \x01\x12\x03e\x08\r\n\x0c\n\x05\x04\x08\x02\x02\x03\x12\x03e\x10\x11\n\
    \x0b\n\x04\x04\x08\x02\x03\x12\x03f\x02\x18\n\x0c\n\x05\x04\x08\x02\x03\
    \x05\x12\x03f\x02\x07\n\x0c\n\x05\x04\x08\x02\x03\x01\x12\x03f\x08\x13\n\
    \x0c\n\x05\x04\x08\x02\x03\x03\x12\x03f\x16\x17\n\n\n\x02\x04\t\x12\x04i\
    \0l\x01\n\n\n\x03\x04\t\x01\x12\x03i\x08\x13\n\x0b\n\x04\x04\t\x02\0\x12\
    \x03j\x02\x20\n\x0c\n\x05\x04\t\x02\0\x05\x12\x03j\x02\x07\n\x0c\n\x05\
    \x04\t\x02\0\x01\x12\x03j\x08\x1b\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03j\
    \x1e\x1f\n\x0b\n\x04\x04\t\x02\x01\x12\x03k\x02\x1f\n\x0c\n\x05\x04\t\
    \x02\x01\x05\x12\x03k\x02\x07\n\x0c\n\x05\x04\t\x02\x01\x01\x12\x03k\x08\
    \x1a\n\x0c\n\x05\x04\t\x02\x01\x03\x12\x03k\x1d\x1e\n\n\n\x02\x04\n\x12\
    \x04n\0r\x01\n\n\n\x03\x04\n\x01\x12\x03n\x08\x17\n\x0b\n\x04\x04\n\x02\
    \0\x12\x03o\x02\x1a\n\x0c\n\x05\x04\n\x02\0\x05\x12\x03o\x02\x07\n\x0c\n\
    \x05\x04\n\x02\0\x01\x12\x03o\x08\x15\n\x0c\n\x05\x04\n\x02\0\x03\x12\
    \x03o\x18\x19\n\x0b\n\x04\x04\n\x02\x01\x12\x03p\x02\x19\n\x0c\n\x05\x04\
    \n\x02\x01\x05\x12\x03p\x02\x07\n\x0c\n\x05\x04\n\x02\x01\x01\x12\x03p\
    \x08\x14\n\x0c\n\x05\x04\n\x02\x01\x03\x12\x03p\x17\x18\n\x0b\n\x04\x04\
    \n\x02\x02\x12\x03q\x02\"\n\x0c\n\x05\x04\n\x02\x02\x04\x12\x03q\x02\n\n\
    \x0c\n\x05\x04\n\x02\x02\x06\x12\x03q\x0b\x16\n\x0c\n\x05\x04\n\x02\x02\
    \x01\x12\x03q\x17\x1d\n\x0c\n\x05\x04\n\x02\x02\x03\x12\x03q\x20!\n\n\n\
    \x02\x04\x0b\x12\x04t\0w\x01\n\n\n\x03\x04\x0b\x01\x12\x03t\x08\x19\n\
    \x0b\n\x04\x04\x0b\x02\0\x12\x03u\x02\x11\n\x0c\n\x05\x04\x0b\x02\0\x05\
    \x12\x03u\x02\x07\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03u\x08\x0c\n\x0c\n\
    \x05\x04\x0b\x02\0\x03\x12\x03u\x0f\x10\n\x0b\n\x04\x04\x0b\x02\x01\x12\
    \x03v\x02\x11\n\x0c\n\x05\x04\x0b\x02\x01\x05\x12\x03v\x02\x07\n\x0c\n\
    \x05\x04\x0b\x02\x01\x01\x12\x03v\x08\x0c\n\x0c\n\x05\x04\x0b\x02\x01\
    \x03\x12\x03v\x0f\x10\n\n\n\x02\x04\x0c\x12\x04y\0\x7f\x01\n\n\n\x03\x04\
    \x0c\x01\x12\x03y\x08\x17\n\x0b\n\x04\x04\x0c\x02\0\x12\x03z\x02-\n\x0c\
    \n\x05\x04\x0c\x02\0\x04\x12\x03z\x02\n\n\x0c\n\x05\x04\x0c\x02\0\x06\
    \x12\x03z\x0b\x19\n\x0c\n\x05\x04\x0c\x02\0\x01\x12\x03z\x1a(\n\x0c\n\
    \x05\x04\x0c\x02\0\x03\x12\x03z+,\n\x0c\n\x04\x04\x0c\x03\0\x12\x04{\x02\
    ~\x03\n\x0c\n\x05\x04\x0c\x03\0\x01\x12\x03{\n\x18\n\r\n\x06\x04\x0c\x03\
    \0\x02\0\x12\x03|\x04\x13\n\x0e\n\x07\x04\x0c\x03\0\x02\0\x05\x12\x03|\
    \x04\n\n\x0e\n\x07\x04\x0c\x03\0\x02\0\x01\x12\x03|\x0b\x0e\n\x0e\n\x07\
    \x04\x0c\x03\0\x02\0\x03\x12\x03|\x11\x12\n\r\n\x06\x04\x0c\x03\0\x02\
    \x01\x12\x03}\x04\x14\n\x0e\n\x07\x04\x0c\x03\0\x02\x01\x05\x12\x03}\x04\
    \t\n\x0e\n\x07\x04\x0c\x03\0\x02\x01\x01\x12\x03}\n\x0f\n\x0e\n\x07\x04\
    \x0c\x03\0\x02\x01\x03\x12\x03}\x12\x13\n\x17\n\x02\x04\r\x12\x06\x82\
    \x01\0\xd8\x01\x01\x1a\t\x20Account\x20\n\x0b\n\x03\x04\r\x01\x12\x04\
    \x82\x01\x08\x0f\n\x20\n\x04\x04\r\x03\0\x12\x06\x84\x01\x02\x87\x01\x03\
    \x1a\x10\x20frozen\x20balance\x20\n\r\n\x05\x04\r\x03\0\x01\x12\x04\x84\
    \x01\n\x10\n(\n\x06\x04\r\x03\0\x02\0\x12\x04\x85\x01\x04\x1d\"\x18\x20t\
    he\x20frozen\x20trx\x20balance\n\n\x0f\n\x07\x04\r\x03\0\x02\0\x05\x12\
    \x04\x85\x01\x04\t\n\x0f\n\x07\x04\r\x03\0\x02\0\x01\x12\x04\x85\x01\n\
    \x18\n\x0f\n\x07\x04\r\x03\0\x02\0\x03\x12\x04\x85\x01\x1b\x1c\n!\n\x06\
    \x04\r\x03\0\x02\x01\x12\x04\x86\x01\x04\x1a\"\x11\x20the\x20expire\x20t\
    ime\n\n\x0f\n\x07\x04\r\x03\0\x02\x01\x05\x12\x04\x86\x01\x04\t\n\x0f\n\
    \x07\x04\r\x03\0\x02\x01\x01\x12\x04\x86\x01\n\x15\n\x0f\n\x07\x04\r\x03\
    \0\x02\x01\x03\x12\x04\x86\x01\x18\x19\n!\n\x04\x04\r\x02\0\x12\x04\x89\
    \x01\x02\x19\x1a\x13\x20account\x20nick\x20name\n\n\r\n\x05\x04\r\x02\0\
    \x05\x12\x04\x89\x01\x02\x07\n\r\n\x05\x04\r\x02\0\x01\x12\x04\x89\x01\
    \x08\x14\n\r\n\x05\x04\r\x02\0\x03\x12\x04\x89\x01\x17\x18\n\x0c\n\x04\
    \x04\r\x02\x01\x12\x04\x8a\x01\x02\x17\n\r\n\x05\x04\r\x02\x01\x06\x12\
    \x04\x8a\x01\x02\r\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\x8a\x01\x0e\x12\n\
    \r\n\x05\x04\r\x02\x01\x03\x12\x04\x8a\x01\x15\x16\n\"\n\x04\x04\r\x02\
    \x02\x12\x04\x8c\x01\x02\x14\x1a\x14\x20the\x20create\x20address\n\n\r\n\
    \x05\x04\r\x02\x02\x05\x12\x04\x8c\x01\x02\x07\n\r\n\x05\x04\r\x02\x02\
    \x01\x12\x04\x8c\x01\x08\x0f\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\x8c\x01\
    \x12\x13\n\x1f\n\x04\x04\r\x02\x03\x12\x04\x8e\x01\x02\x14\x1a\x11\x20th\
    e\x20trx\x20balance\n\n\r\n\x05\x04\r\x02\x03\x05\x12\x04\x8e\x01\x02\
    \x07\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\x8e\x01\x08\x0f\n\r\n\x05\x04\r\
    \x02\x03\x03\x12\x04\x8e\x01\x12\x13\n\x19\n\x04\x04\r\x02\x04\x12\x04\
    \x90\x01\x02\x1a\x1a\x0b\x20the\x20votes\n\n\r\n\x05\x04\r\x02\x04\x04\
    \x12\x04\x90\x01\x02\n\n\r\n\x05\x04\r\x02\x04\x06\x12\x04\x90\x01\x0b\
    \x0f\n\r\n\x05\x04\r\x02\x04\x01\x12\x04\x90\x01\x10\x15\n\r\n\x05\x04\r\
    \x02\x04\x03\x12\x04\x90\x01\x18\x19\n5\n\x04\x04\r\x02\x05\x12\x04\x92\
    \x01\x02\x1f\x1a'\x20the\x20other\x20asset\x20owned\x20by\x20this\x20acc\
    ount\n\n\r\n\x05\x04\r\x02\x05\x06\x12\x04\x92\x01\x02\x14\n\r\n\x05\x04\
    \r\x02\x05\x01\x12\x04\x92\x01\x15\x1a\n\r\n\x05\x04\r\x02\x05\x03\x12\
    \x04\x92\x01\x1d\x1e\nF\n\x04\x04\r\x02\x06\x12\x04\x95\x01\x02\"\x1a8\
    \x20the\x20other\x20asset\x20owned\x20by\x20this\x20account\xef\xbc\x8ck\
    ey\x20is\x20assetId\n\n\r\n\x05\x04\r\x02\x06\x06\x12\x04\x95\x01\x02\
    \x14\n\r\n\x05\x04\r\x02\x06\x01\x12\x04\x95\x01\x15\x1c\n\r\n\x05\x04\r\
    \x02\x06\x03\x12\x04\x95\x01\x1f!\n0\n\x04\x04\r\x02\x07\x12\x04\x98\x01\
    \x02\x1d\x1a\"\x20the\x20frozen\x20balance\x20for\x20bandwidth\n\n\r\n\
    \x05\x04\r\x02\x07\x04\x12\x04\x98\x01\x02\n\n\r\n\x05\x04\r\x02\x07\x06\
    \x12\x04\x98\x01\x0b\x11\n\r\n\x05\x04\r\x02\x07\x01\x12\x04\x98\x01\x12\
    \x18\n\r\n\x05\x04\r\x02\x07\x03\x12\x04\x98\x01\x1b\x1c\n*\n\x04\x04\r\
    \x02\x08\x12\x04\x9a\x01\x02\x16\x1a\x1c\x20bandwidth,\x20get\x20from\
    \x20frozen\n\n\r\n\x05\x04\r\x02\x08\x05\x12\x04\x9a\x01\x02\x07\n\r\n\
    \x05\x04\r\x02\x08\x01\x12\x04\x9a\x01\x08\x11\n\r\n\x05\x04\r\x02\x08\
    \x03\x12\x04\x9a\x01\x14\x15\nH\n\x04\x04\r\x02\t\x12\x04\x9c\x01\x02=\
    \x1a:Frozen\x20balance\x20provided\x20by\x20other\x20accounts\x20to\x20t\
    his\x20account\n\n\r\n\x05\x04\r\x02\t\x05\x12\x04\x9c\x01\x02\x07\n\r\n\
    \x05\x04\r\x02\t\x01\x12\x04\x9c\x01\x087\n\r\n\x05\x04\r\x02\t\x03\x12\
    \x04\x9c\x01:<\n<\n\x04\x04\r\x02\n\x12\x04\x9e\x01\x024\x1a.Freeze\x20a\
    nd\x20provide\x20balances\x20to\x20other\x20accounts\n\n\r\n\x05\x04\r\
    \x02\n\x05\x12\x04\x9e\x01\x02\x07\n\r\n\x05\x04\r\x02\n\x01\x12\x04\x9e\
    \x01\x08.\n\r\n\x05\x04\r\x02\n\x03\x12\x04\x9e\x0113\n\x0c\n\x04\x04\r\
    \x02\x0b\x12\x04\xa0\x01\x02\x1c\n\r\n\x05\x04\r\x02\x0b\x05\x12\x04\xa0\
    \x01\x02\x07\n\r\n\x05\x04\r\x02\x0b\x01\x12\x04\xa0\x01\x08\x16\n\r\n\
    \x05\x04\r\x02\x0b\x03\x12\x04\xa0\x01\x19\x1b\n\x0c\n\x04\x04\r\x02\x0c\
    \x12\x04\xa1\x01\x02\x19\n\r\n\x05\x04\r\x02\x0c\x06\x12\x04\xa1\x01\x02\
    \x08\n\r\n\x05\x04\r\x02\x0c\x01\x12\x04\xa1\x01\t\x13\n\r\n\x05\x04\r\
    \x02\x0c\x03\x12\x04\xa1\x01\x16\x18\n\x0c\n\x04\x04\r\x02\r\x12\x04\xa3\
    \x01\x02\x1c\n\r\n\x05\x04\r\x02\r\x05\x12\x04\xa3\x01\x02\x06\n\r\n\x05\
    \x04\r\x02\r\x01\x12\x04\xa3\x01\x07\x16\n\r\n\x05\x04\r\x02\r\x03\x12\
    \x04\xa3\x01\x19\x1b\n(\n\x04\x04\r\x02\x0e\x12\x04\xa6\x01\x02\x1b\x1a\
    \x1a\x20this\x20account\x20create\x20time\n\n\r\n\x05\x04\r\x02\x0e\x05\
    \x12\x04\xa6\x01\x02\x07\n\r\n\x05\x04\r\x02\x0e\x01\x12\x04\xa6\x01\x08\
    \x13\n\r\n\x05\x04\r\x02\x0e\x03\x12\x04\xa6\x01\x16\x1a\nc\n\x04\x04\r\
    \x02\x0f\x12\x04\xa8\x01\x02\"\x1aU\x20this\x20last\x20operation\x20time\
    ,\x20including\x20transfer,\x20voting\x20and\x20so\x20on.\x20//FIXME\x20\
    fix\x20grammar\n\n\r\n\x05\x04\r\x02\x0f\x05\x12\x04\xa8\x01\x02\x07\n\r\
    \n\x05\x04\r\x02\x0f\x01\x12\x04\xa8\x01\x08\x1c\n\r\n\x05\x04\r\x02\x0f\
    \x03\x12\x04\xa8\x01\x1f!\n1\n\x04\x04\r\x02\x10\x12\x04\xaa\x01\x02\x19\
    \x1a#\x20witness\x20block\x20producing\x20allowance\n\n\r\n\x05\x04\r\
    \x02\x10\x05\x12\x04\xaa\x01\x02\x07\n\r\n\x05\x04\r\x02\x10\x01\x12\x04\
    \xaa\x01\x08\x11\n\r\n\x05\x04\r\x02\x10\x03\x12\x04\xaa\x01\x14\x18\n\"\
    \n\x04\x04\r\x02\x11\x12\x04\xac\x01\x02$\x1a\x14\x20last\x20withdraw\
    \x20time\n\n\r\n\x05\x04\r\x02\x11\x05\x12\x04\xac\x01\x02\x07\n\r\n\x05\
    \x04\r\x02\x11\x01\x12\x04\xac\x01\x08\x1c\n\r\n\x05\x04\r\x02\x11\x03\
    \x12\x04\xac\x01\x1f#\n\x1f\n\x04\x04\r\x02\x12\x12\x04\xae\x01\x02\x12\
    \x1a\x11\x20not\x20used\x20so\x20far\n\n\r\n\x05\x04\r\x02\x12\x05\x12\
    \x04\xae\x01\x02\x07\n\r\n\x05\x04\r\x02\x12\x01\x12\x04\xae\x01\x08\x0c\
    \n\r\n\x05\x04\r\x02\x12\x03\x12\x04\xae\x01\x0f\x11\n\x0c\n\x04\x04\r\
    \x02\x13\x12\x04\xaf\x01\x02\x17\n\r\n\x05\x04\r\x02\x13\x05\x12\x04\xaf\
    \x01\x02\x06\n\r\n\x05\x04\r\x02\x13\x01\x12\x04\xaf\x01\x07\x11\n\r\n\
    \x05\x04\r\x02\x13\x03\x12\x04\xaf\x01\x14\x16\n\x0c\n\x04\x04\r\x02\x14\
    \x12\x04\xb0\x01\x02\x19\n\r\n\x05\x04\r\x02\x14\x05\x12\x04\xb0\x01\x02\
    \x06\n\r\n\x05\x04\r\x02\x14\x01\x12\x04\xb0\x01\x07\x13\n\r\n\x05\x04\r\
    \x02\x14\x03\x12\x04\xb0\x01\x16\x18\n.\n\x04\x04\r\x02\x15\x12\x04\xb2\
    \x01\x02%\x1a\x20\x20frozen\x20asset(for\x20asset\x20issuer)\n\n\r\n\x05\
    \x04\r\x02\x15\x04\x12\x04\xb2\x01\x02\n\n\r\n\x05\x04\r\x02\x15\x06\x12\
    \x04\xb2\x01\x0b\x11\n\r\n\x05\x04\r\x02\x15\x01\x12\x04\xb2\x01\x12\x1f\
    \n\r\n\x05\x04\r\x02\x15\x03\x12\x04\xb2\x01\"$\n!\n\x04\x04\r\x02\x16\
    \x12\x04\xb4\x01\x02\x1f\x1a\x13\x20asset_issued_name\n\n\r\n\x05\x04\r\
    \x02\x16\x05\x12\x04\xb4\x01\x02\x07\n\r\n\x05\x04\r\x02\x16\x01\x12\x04\
    \xb4\x01\x08\x19\n\r\n\x05\x04\r\x02\x16\x03\x12\x04\xb4\x01\x1c\x1e\n\
    \x0c\n\x04\x04\r\x02\x17\x12\x04\xb5\x01\x02\x1d\n\r\n\x05\x04\r\x02\x17\
    \x05\x12\x04\xb5\x01\x02\x07\n\r\n\x05\x04\r\x02\x17\x01\x12\x04\xb5\x01\
    \x08\x17\n\r\n\x05\x04\r\x02\x17\x03\x12\x04\xb5\x01\x1a\x1c\n\x0c\n\x04\
    \x04\r\x02\x18\x12\x04\xb6\x01\x026\n\r\n\x05\x04\r\x02\x18\x06\x12\x04\
    \xb6\x01\x02\x14\n\r\n\x05\x04\r\x02\x18\x01\x12\x04\xb6\x01\x150\n\r\n\
    \x05\x04\r\x02\x18\x03\x12\x04\xb6\x0135\n\x0c\n\x04\x04\r\x02\x19\x12\
    \x04\xb7\x01\x028\n\r\n\x05\x04\r\x02\x19\x06\x12\x04\xb7\x01\x02\x14\n\
    \r\n\x05\x04\r\x02\x19\x01\x12\x04\xb7\x01\x152\n\r\n\x05\x04\r\x02\x19\
    \x03\x12\x04\xb7\x0157\n\x0c\n\x04\x04\r\x02\x1a\x12\x04\xb8\x01\x02\x1c\
    \n\r\n\x05\x04\r\x02\x1a\x05\x12\x04\xb8\x01\x02\x07\n\r\n\x05\x04\r\x02\
    \x1a\x01\x12\x04\xb8\x01\x08\x16\n\r\n\x05\x04\r\x02\x1a\x03\x12\x04\xb8\
    \x01\x19\x1b\n\x0c\n\x04\x04\r\x02\x1b\x12\x04\xb9\x01\x02/\n\r\n\x05\
    \x04\r\x02\x1b\x06\x12\x04\xb9\x01\x02\x14\n\r\n\x05\x04\r\x02\x1b\x01\
    \x12\x04\xb9\x01\x15)\n\r\n\x05\x04\r\x02\x1b\x03\x12\x04\xb9\x01,.\n\
    \x0c\n\x04\x04\r\x02\x1c\x12\x04\xba\x01\x021\n\r\n\x05\x04\r\x02\x1c\
    \x06\x12\x04\xba\x01\x02\x14\n\r\n\x05\x04\r\x02\x1c\x01\x12\x04\xba\x01\
    \x15+\n\r\n\x05\x04\r\x02\x1c\x03\x12\x04\xba\x01.0\n\x0c\n\x04\x04\r\
    \x02\x1d\x12\x04\xbb\x01\x02!\n\r\n\x05\x04\r\x02\x1d\x05\x12\x04\xbb\
    \x01\x02\x07\n\r\n\x05\x04\r\x02\x1d\x01\x12\x04\xbb\x01\x08\x1b\n\r\n\
    \x05\x04\r\x02\x1d\x03\x12\x04\xbb\x01\x1e\x20\n\x0c\n\x04\x04\r\x02\x1e\
    \x12\x04\xbc\x01\x02&\n\r\n\x05\x04\r\x02\x1e\x05\x12\x04\xbc\x01\x02\
    \x07\n\r\n\x05\x04\r\x02\x1e\x01\x12\x04\xbc\x01\x08\x20\n\r\n\x05\x04\r\
    \x02\x1e\x03\x12\x04\xbc\x01#%\n>\n\x04\x04\r\x02\x1f\x12\x04\xbf\x01\
    \x02\x18\x1a0\x20the\x20identity\x20of\x20this\x20account,\x20case\x20in\
    sensitive\n\n\r\n\x05\x04\r\x02\x1f\x05\x12\x04\xbf\x01\x02\x07\n\r\n\
    \x05\x04\r\x02\x1f\x01\x12\x04\xbf\x01\x08\x12\n\r\n\x05\x04\r\x02\x1f\
    \x03\x12\x04\xbf\x01\x15\x17\n\x0e\n\x04\x04\r\x03\x07\x12\x06\xc1\x01\
    \x02\xd2\x01\x03\n\r\n\x05\x04\r\x03\x07\x01\x12\x04\xc1\x01\n\x19\n2\n\
    \x06\x04\r\x03\x07\x02\0\x12\x04\xc3\x01\x04\x1b\x1a\"\x20energy\x20reso\
    urce,\x20get\x20from\x20frozen\n\n\x0f\n\x07\x04\r\x03\x07\x02\0\x05\x12\
    \x04\xc3\x01\x04\t\n\x0f\n\x07\x04\r\x03\x07\x02\0\x01\x12\x04\xc3\x01\n\
    \x16\n\x0f\n\x07\x04\r\x03\x07\x02\0\x03\x12\x04\xc3\x01\x19\x1a\n/\n\
    \x06\x04\r\x03\x07\x02\x01\x12\x04\xc5\x01\x04)\x1a\x1f\x20the\x20frozen\
    \x20balance\x20for\x20energy\n\n\x0f\n\x07\x04\r\x03\x07\x02\x01\x06\x12\
    \x04\xc5\x01\x04\n\n\x0f\n\x07\x04\r\x03\x07\x02\x01\x01\x12\x04\xc5\x01\
    \x0b$\n\x0f\n\x07\x04\r\x03\x07\x02\x01\x03\x12\x04\xc5\x01'(\n\x0e\n\
    \x06\x04\r\x03\x07\x02\x02\x12\x04\xc6\x01\x04-\n\x0f\n\x07\x04\r\x03\
    \x07\x02\x02\x05\x12\x04\xc6\x01\x04\t\n\x0f\n\x07\x04\r\x03\x07\x02\x02\
    \x01\x12\x04\xc6\x01\n(\n\x0f\n\x07\x04\r\x03\x07\x02\x02\x03\x12\x04\
    \xc6\x01+,\nJ\n\x06\x04\r\x03\x07\x02\x03\x12\x04\xc9\x01\x04;\x1a:Froze\
    n\x20balance\x20provided\x20by\x20other\x20accounts\x20to\x20this\x20acc\
    ount\n\n\x0f\n\x07\x04\r\x03\x07\x02\x03\x05\x12\x04\xc9\x01\x04\t\n\x0f\
    \n\x07\x04\r\x03\x07\x02\x03\x01\x12\x04\xc9\x01\n6\n\x0f\n\x07\x04\r\
    \x03\x07\x02\x03\x03\x12\x04\xc9\x019:\n;\n\x06\x04\r\x03\x07\x02\x04\
    \x12\x04\xcb\x01\x042\x1a+Frozen\x20balances\x20provided\x20to\x20other\
    \x20accounts\n\n\x0f\n\x07\x04\r\x03\x07\x02\x04\x05\x12\x04\xcb\x01\x04\
    \t\n\x0f\n\x07\x04\r\x03\x07\x02\x04\x01\x12\x04\xcb\x01\n-\n\x0f\n\x07\
    \x04\r\x03\x07\x02\x04\x03\x12\x04\xcb\x0101\n3\n\x06\x04\r\x03\x07\x02\
    \x05\x12\x04\xce\x01\x04\x1c\x1a#\x20storage\x20resource,\x20get\x20from\
    \x20market\n\n\x0f\n\x07\x04\r\x03\x07\x02\x05\x05\x12\x04\xce\x01\x04\t\
    \n\x0f\n\x07\x04\r\x03\x07\x02\x05\x01\x12\x04\xce\x01\n\x17\n\x0f\n\x07\
    \x04\r\x03\x07\x02\x05\x03\x12\x04\xce\x01\x1a\x1b\n\x0e\n\x06\x04\r\x03\
    \x07\x02\x06\x12\x04\xcf\x01\x04\x1c\n\x0f\n\x07\x04\r\x03\x07\x02\x06\
    \x05\x12\x04\xcf\x01\x04\t\n\x0f\n\x07\x04\r\x03\x07\x02\x06\x01\x12\x04\
    \xcf\x01\n\x17\n\x0f\n\x07\x04\r\x03\x07\x02\x06\x03\x12\x04\xcf\x01\x1a\
    \x1b\n\x0e\n\x06\x04\r\x03\x07\x02\x07\x12\x04\xd0\x01\x04+\n\x0f\n\x07\
    \x04\r\x03\x07\x02\x07\x05\x12\x04\xd0\x01\x04\t\n\x0f\n\x07\x04\r\x03\
    \x07\x02\x07\x01\x12\x04\xd0\x01\n&\n\x0f\n\x07\x04\r\x03\x07\x02\x07\
    \x03\x12\x04\xd0\x01)*\n\x0c\n\x04\x04\r\x02\x20\x12\x04\xd3\x01\x02(\n\
    \r\n\x05\x04\r\x02\x20\x06\x12\x04\xd3\x01\x02\x11\n\r\n\x05\x04\r\x02\
    \x20\x01\x12\x04\xd3\x01\x12\"\n\r\n\x05\x04\r\x02\x20\x03\x12\x04\xd3\
    \x01%'\n\x0c\n\x04\x04\r\x02!\x12\x04\xd4\x01\x02\x16\n\r\n\x05\x04\r\
    \x02!\x05\x12\x04\xd4\x01\x02\x07\n\r\n\x05\x04\r\x02!\x01\x12\x04\xd4\
    \x01\x08\x10\n\r\n\x05\x04\r\x02!\x03\x12\x04\xd4\x01\x13\x15\n\x0c\n\
    \x04\x04\r\x02\"\x12\x04\xd5\x01\x02#\n\r\n\x05\x04\r\x02\"\x06\x12\x04\
    \xd5\x01\x02\x0c\n\r\n\x05\x04\r\x02\"\x01\x12\x04\xd5\x01\r\x1d\n\r\n\
    \x05\x04\r\x02\"\x03\x12\x04\xd5\x01\x20\"\n\x0c\n\x04\x04\r\x02#\x12\
    \x04\xd6\x01\x02%\n\r\n\x05\x04\r\x02#\x06\x12\x04\xd6\x01\x02\x0c\n\r\n\
    \x05\x04\r\x02#\x01\x12\x04\xd6\x01\r\x1f\n\r\n\x05\x04\r\x02#\x03\x12\
    \x04\xd6\x01\"$\n\x0c\n\x04\x04\r\x02$\x12\x04\xd7\x01\x02-\n\r\n\x05\
    \x04\r\x02$\x04\x12\x04\xd7\x01\x02\n\n\r\n\x05\x04\r\x02$\x06\x12\x04\
    \xd7\x01\x0b\x15\n\r\n\x05\x04\r\x02$\x01\x12\x04\xd7\x01\x16'\n\r\n\x05\
    \x04\r\x02$\x03\x12\x04\xd7\x01*,\n\x0c\n\x02\x04\x0e\x12\x06\xda\x01\0\
    \xdd\x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xda\x01\x08\x0b\n\x0c\n\x04\
    \x04\x0e\x02\0\x12\x04\xdb\x01\x02\x14\n\r\n\x05\x04\x0e\x02\0\x05\x12\
    \x04\xdb\x01\x02\x07\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xdb\x01\x08\x0f\
    \n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xdb\x01\x12\x13\n\x0c\n\x04\x04\x0e\
    \x02\x01\x12\x04\xdc\x01\x02\x13\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\
    \xdc\x01\x02\x07\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xdc\x01\x08\x0e\n\
    \r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xdc\x01\x11\x12\n\x0c\n\x02\x04\x0f\
    \x12\x06\xdf\x01\0\xe6\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xdf\x01\
    \x08\x19\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xe0\x01\x02\x11\n\r\n\x05\x04\
    \x0f\x02\0\x05\x12\x04\xe0\x01\x02\x07\n\r\n\x05\x04\x0f\x02\0\x01\x12\
    \x04\xe0\x01\x08\x0c\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xe0\x01\x0f\x10\
    \n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\xe1\x01\x02\x0f\n\r\n\x05\x04\x0f\
    \x02\x01\x05\x12\x04\xe1\x01\x02\x07\n\r\n\x05\x04\x0f\x02\x01\x01\x12\
    \x04\xe1\x01\x08\n\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xe1\x01\r\x0e\n\
    \x0c\n\x04\x04\x0f\x02\x02\x12\x04\xe2\x01\x02)\n\r\n\x05\x04\x0f\x02\
    \x02\x05\x12\x04\xe2\x01\x02\x07\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\
    \xe2\x01\x08$\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\xe2\x01'(\n\x0c\n\
    \x04\x04\x0f\x02\x03\x12\x04\xe3\x01\x02&\n\r\n\x05\x04\x0f\x02\x03\x05\
    \x12\x04\xe3\x01\x02\x07\n\r\n\x05\x04\x0f\x02\x03\x01\x12\x04\xe3\x01\
    \x08!\n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\xe3\x01$%\n\x0c\n\x04\x04\
    \x0f\x02\x04\x12\x04\xe4\x01\x02&\n\r\n\x05\x04\x0f\x02\x04\x05\x12\x04\
    \xe4\x01\x02\x07\n\r\n\x05\x04\x0f\x02\x04\x01\x12\x04\xe4\x01\x08!\n\r\
    \n\x05\x04\x0f\x02\x04\x03\x12\x04\xe4\x01$%\n\x0c\n\x04\x04\x0f\x02\x05\
    \x12\x04\xe5\x01\x02#\n\r\n\x05\x04\x0f\x02\x05\x05\x12\x04\xe5\x01\x02\
    \x07\n\r\n\x05\x04\x0f\x02\x05\x01\x12\x04\xe5\x01\x08\x1e\n\r\n\x05\x04\
    \x0f\x02\x05\x03\x12\x04\xe5\x01!\"\n\x0c\n\x02\x04\x10\x12\x06\xe8\x01\
    \0\xeb\x01\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\xe8\x01\x08\x11\n\x0c\n\
    \x04\x04\x10\x02\0\x12\x04\xe9\x01\x02\x18\n\r\n\x05\x04\x10\x02\0\x06\
    \x12\x04\xe9\x01\x02\x0b\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xe9\x01\x0c\
    \x13\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xe9\x01\x16\x17\n\x0c\n\x04\x04\
    \x10\x02\x01\x12\x04\xea\x01\x02\x1c\n\r\n\x05\x04\x10\x02\x01\x05\x12\
    \x04\xea\x01\x02\x07\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xea\x01\x08\
    \x17\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xea\x01\x1a\x1b\n\x0c\n\x02\
    \x04\x11\x12\x06\xed\x01\0\xfa\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\
    \xed\x01\x08\x12\n\x0e\n\x04\x04\x11\x04\0\x12\x06\xee\x01\x02\xf2\x01\
    \x03\n\r\n\x05\x04\x11\x04\0\x01\x12\x04\xee\x01\x07\x15\n\x0e\n\x06\x04\
    \x11\x04\0\x02\0\x12\x04\xef\x01\x04\x0e\n\x0f\n\x07\x04\x11\x04\0\x02\0\
    \x01\x12\x04\xef\x01\x04\t\n\x0f\n\x07\x04\x11\x04\0\x02\0\x02\x12\x04\
    \xef\x01\x0c\r\n\x0e\n\x06\x04\x11\x04\0\x02\x01\x12\x04\xf0\x01\x04\x10\
    \n\x0f\n\x07\x04\x11\x04\0\x02\x01\x01\x12\x04\xf0\x01\x04\x0b\n\x0f\n\
    \x07\x04\x11\x04\0\x02\x01\x02\x12\x04\xf0\x01\x0e\x0f\n\x0e\n\x06\x04\
    \x11\x04\0\x02\x02\x12\x04\xf1\x01\x04\x0f\n\x0f\n\x07\x04\x11\x04\0\x02\
    \x02\x01\x12\x04\xf1\x01\x04\n\n\x0f\n\x07\x04\x11\x04\0\x02\x02\x02\x12\
    \x04\xf1\x01\r\x0e\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xf3\x01\x02\x1a\n\r\
    \n\x05\x04\x11\x02\0\x06\x12\x04\xf3\x01\x02\x10\n\r\n\x05\x04\x11\x02\0\
    \x01\x12\x04\xf3\x01\x11\x15\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xf3\x01\
    \x18\x19\n=\n\x04\x04\x11\x02\x01\x12\x04\xf4\x01\x02\x0f\"/Owner\x20id=\
    0,\x20Witness\x20id=1,\x20Active\x20id\x20start\x20by\x202\n\n\r\n\x05\
    \x04\x11\x02\x01\x05\x12\x04\xf4\x01\x02\x07\n\r\n\x05\x04\x11\x02\x01\
    \x01\x12\x04\xf4\x01\x08\n\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xf4\x01\
    \r\x0e\n\x0c\n\x04\x04\x11\x02\x02\x12\x04\xf5\x01\x02\x1d\n\r\n\x05\x04\
    \x11\x02\x02\x05\x12\x04\xf5\x01\x02\x08\n\r\n\x05\x04\x11\x02\x02\x01\
    \x12\x04\xf5\x01\t\x18\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xf5\x01\x1b\
    \x1c\n\x0c\n\x04\x04\x11\x02\x03\x12\x04\xf6\x01\x02\x16\n\r\n\x05\x04\
    \x11\x02\x03\x05\x12\x04\xf6\x01\x02\x07\n\r\n\x05\x04\x11\x02\x03\x01\
    \x12\x04\xf6\x01\x08\x11\n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\xf6\x01\
    \x14\x15\n\x0c\n\x04\x04\x11\x02\x04\x12\x04\xf7\x01\x02\x16\n\r\n\x05\
    \x04\x11\x02\x04\x05\x12\x04\xf7\x01\x02\x07\n\r\n\x05\x04\x11\x02\x04\
    \x01\x12\x04\xf7\x01\x08\x11\n\r\n\x05\x04\x11\x02\x04\x03\x12\x04\xf7\
    \x01\x14\x15\n\x1f\n\x04\x04\x11\x02\x05\x12\x04\xf8\x01\x02\x17\"\x111\
    \x20bit\x201\x20contract\n\n\r\n\x05\x04\x11\x02\x05\x05\x12\x04\xf8\x01\
    \x02\x07\n\r\n\x05\x04\x11\x02\x05\x01\x12\x04\xf8\x01\x08\x12\n\r\n\x05\
    \x04\x11\x02\x05\x03\x12\x04\xf8\x01\x15\x16\n\x0c\n\x04\x04\x11\x02\x06\
    \x12\x04\xf9\x01\x02\x18\n\r\n\x05\x04\x11\x02\x06\x04\x12\x04\xf9\x01\
    \x02\n\n\r\n\x05\x04\x11\x02\x06\x06\x12\x04\xf9\x01\x0b\x0e\n\r\n\x05\
    \x04\x11\x02\x06\x01\x12\x04\xf9\x01\x0f\x13\n\r\n\x05\x04\x11\x02\x06\
    \x03\x12\x04\xf9\x01\x16\x17\n\x17\n\x02\x04\x12\x12\x06\xfd\x01\0\x87\
    \x02\x01\x1a\t\x20Witness\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xfd\x01\x08\
    \x0f\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xfe\x01\x02\x14\n\r\n\x05\x04\x12\
    \x02\0\x05\x12\x04\xfe\x01\x02\x07\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\
    \xfe\x01\x08\x0f\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xfe\x01\x12\x13\n\
    \x0c\n\x04\x04\x12\x02\x01\x12\x04\xff\x01\x02\x16\n\r\n\x05\x04\x12\x02\
    \x01\x05\x12\x04\xff\x01\x02\x07\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\
    \xff\x01\x08\x11\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\xff\x01\x14\x15\n\
    \x0c\n\x04\x04\x12\x02\x02\x12\x04\x80\x02\x02\x13\n\r\n\x05\x04\x12\x02\
    \x02\x05\x12\x04\x80\x02\x02\x07\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\
    \x80\x02\x08\x0e\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\x80\x02\x11\x12\n\
    \x0c\n\x04\x04\x12\x02\x03\x12\x04\x81\x02\x02\x11\n\r\n\x05\x04\x12\x02\
    \x03\x05\x12\x04\x81\x02\x02\x08\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\
    \x81\x02\t\x0c\n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\x81\x02\x0f\x10\n\
    \x0c\n\x04\x04\x12\x02\x04\x12\x04\x82\x02\x02\x1a\n\r\n\x05\x04\x12\x02\
    \x04\x05\x12\x04\x82\x02\x02\x07\n\r\n\x05\x04\x12\x02\x04\x01\x12\x04\
    \x82\x02\x08\x15\n\r\n\x05\x04\x12\x02\x04\x03\x12\x04\x82\x02\x18\x19\n\
    \x0c\n\x04\x04\x12\x02\x05\x12\x04\x83\x02\x02\x18\n\r\n\x05\x04\x12\x02\
    \x05\x05\x12\x04\x83\x02\x02\x07\n\r\n\x05\x04\x12\x02\x05\x01\x12\x04\
    \x83\x02\x08\x13\n\r\n\x05\x04\x12\x02\x05\x03\x12\x04\x83\x02\x16\x17\n\
    \x0c\n\x04\x04\x12\x02\x06\x12\x04\x84\x02\x02\x1b\n\r\n\x05\x04\x12\x02\
    \x06\x05\x12\x04\x84\x02\x02\x07\n\r\n\x05\x04\x12\x02\x06\x01\x12\x04\
    \x84\x02\x08\x16\n\r\n\x05\x04\x12\x02\x06\x03\x12\x04\x84\x02\x19\x1a\n\
    \x0c\n\x04\x04\x12\x02\x07\x12\x04\x85\x02\x02\x1a\n\r\n\x05\x04\x12\x02\
    \x07\x05\x12\x04\x85\x02\x02\x07\n\r\n\x05\x04\x12\x02\x07\x01\x12\x04\
    \x85\x02\x08\x15\n\r\n\x05\x04\x12\x02\x07\x03\x12\x04\x85\x02\x18\x19\n\
    \x0c\n\x04\x04\x12\x02\x08\x12\x04\x86\x02\x02\x12\n\r\n\x05\x04\x12\x02\
    \x08\x05\x12\x04\x86\x02\x02\x06\n\r\n\x05\x04\x12\x02\x08\x01\x12\x04\
    \x86\x02\x07\r\n\r\n\x05\x04\x12\x02\x08\x03\x12\x04\x86\x02\x10\x11\n\
    \x1b\n\x02\x04\x13\x12\x06\x8a\x02\0\x8e\x02\x01\x1a\r\x20Vote\x20Change\
    \n\n\x0b\n\x03\x04\x13\x01\x12\x04\x8a\x02\x08\r\n\x0c\n\x04\x04\x13\x02\
    \0\x12\x04\x8b\x02\x02\x14\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\x8b\x02\
    \x02\x07\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\x8b\x02\x08\x0f\n\r\n\x05\
    \x04\x13\x02\0\x03\x12\x04\x8b\x02\x12\x13\n\x0c\n\x04\x04\x13\x02\x01\
    \x12\x04\x8c\x02\x02\x1e\n\r\n\x05\x04\x13\x02\x01\x04\x12\x04\x8c\x02\
    \x02\n\n\r\n\x05\x04\x13\x02\x01\x06\x12\x04\x8c\x02\x0b\x0f\n\r\n\x05\
    \x04\x13\x02\x01\x01\x12\x04\x8c\x02\x10\x19\n\r\n\x05\x04\x13\x02\x01\
    \x03\x12\x04\x8c\x02\x1c\x1d\n\x0c\n\x04\x04\x13\x02\x02\x12\x04\x8d\x02\
    \x02\x1e\n\r\n\x05\x04\x13\x02\x02\x04\x12\x04\x8d\x02\x02\n\n\r\n\x05\
    \x04\x13\x02\x02\x06\x12\x04\x8d\x02\x0b\x0f\n\r\n\x05\x04\x13\x02\x02\
    \x01\x12\x04\x8d\x02\x10\x19\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\x8d\
    \x02\x1c\x1d\n\x1b\n\x02\x04\x14\x12\x06\x92\x02\0\x95\x02\x012\r\x20Tra\
    nscation\n\n\x0b\n\x03\x04\x14\x01\x12\x04\x92\x02\x08\x10\n\x0c\n\x04\
    \x04\x14\x02\0\x12\x04\x93\x02\x02\x12\n\r\n\x05\x04\x14\x02\0\x05\x12\
    \x04\x93\x02\x02\x07\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\x93\x02\x08\r\n\
    \r\n\x05\x04\x14\x02\0\x03\x12\x04\x93\x02\x10\x11\n\x0c\n\x04\x04\x14\
    \x02\x01\x12\x04\x94\x02\x02\x17\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\
    \x94\x02\x02\x07\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\x94\x02\x08\x12\n\
    \r\n\x05\x04\x14\x02\x01\x03\x12\x04\x94\x02\x15\x16\n\x0c\n\x02\x04\x15\
    \x12\x06\x97\x02\0\x9f\x02\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\x97\x02\
    \x08\x0f\n\x0e\n\x04\x04\x15\x03\0\x12\x06\x98\x02\x02\x9c\x02\x03\n\r\n\
    \x05\x04\x15\x03\0\x01\x12\x04\x98\x02\n\r\n\x0e\n\x06\x04\x15\x03\0\x02\
    \0\x12\x04\x99\x02\x04\x13\n\x0f\n\x07\x04\x15\x03\0\x02\0\x05\x12\x04\
    \x99\x02\x04\t\n\x0f\n\x07\x04\x15\x03\0\x02\0\x01\x12\x04\x99\x02\n\x0e\
    \n\x0f\n\x07\x04\x15\x03\0\x02\0\x03\x12\x04\x99\x02\x11\x12\n\x0e\n\x06\
    \x04\x15\x03\0\x02\x01\x12\x04\x9a\x02\x04\x13\n\x0f\n\x07\x04\x15\x03\0\
    \x02\x01\x05\x12\x04\x9a\x02\x04\t\n\x0f\n\x07\x04\x15\x03\0\x02\x01\x01\
    \x12\x04\x9a\x02\n\x0e\n\x0f\n\x07\x04\x15\x03\0\x02\x01\x03\x12\x04\x9a\
    \x02\x11\x12\n\x0e\n\x06\x04\x15\x03\0\x02\x02\x12\x04\x9b\x02\x04\x15\n\
    \x0f\n\x07\x04\x15\x03\0\x02\x02\x05\x12\x04\x9b\x02\x04\t\n\x0f\n\x07\
    \x04\x15\x03\0\x02\x02\x01\x12\x04\x9b\x02\n\x10\n\x0f\n\x07\x04\x15\x03\
    \0\x02\x02\x03\x12\x04\x9b\x02\x13\x14\n\x0c\n\x04\x04\x15\x02\0\x12\x04\
    \x9d\x02\x02\x13\n\r\n\x05\x04\x15\x02\0\x06\x12\x04\x9d\x02\x02\x05\n\r\
    \n\x05\x04\x15\x02\0\x01\x12\x04\x9d\x02\x06\x0e\n\r\n\x05\x04\x15\x02\0\
    \x03\x12\x04\x9d\x02\x11\x12\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\x9e\x02\
    \x02\x16\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\x9e\x02\x02\x07\n\r\n\x05\
    \x04\x15\x02\x01\x01\x12\x04\x9e\x02\x08\x11\n\r\n\x05\x04\x15\x02\x01\
    \x03\x12\x04\x9e\x02\x14\x15\n\x0c\n\x02\x04\x16\x12\x06\xa1\x02\0\xa3\
    \x02\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\xa1\x02\x08\x11\n\x0c\n\x04\x04\
    \x16\x02\0\x12\x04\xa2\x02\x02\x20\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\
    \xa2\x02\x02\n\n\r\n\x05\x04\x16\x02\0\x06\x12\x04\xa2\x02\x0b\x13\n\r\n\
    \x05\x04\x16\x02\0\x01\x12\x04\xa2\x02\x14\x1b\n\r\n\x05\x04\x16\x02\0\
    \x03\x12\x04\xa2\x02\x1e\x1f\n\x0c\n\x02\x04\x17\x12\x06\xa5\x02\0\xad\
    \x02\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xa5\x02\x08\x17\n\x0c\n\x04\x04\
    \x17\x02\0\x12\x04\xa6\x02\x02\x19\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\
    \xa6\x02\x02\x07\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xa6\x02\x08\x14\n\r\
    \n\x05\x04\x17\x02\0\x03\x12\x04\xa6\x02\x17\x18\n\x0c\n\x04\x04\x17\x02\
    \x01\x12\x04\xa7\x02\x02\x17\n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\xa7\
    \x02\x02\x07\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\xa7\x02\x08\x12\n\r\n\
    \x05\x04\x17\x02\x01\x03\x12\x04\xa7\x02\x15\x16\n\x0c\n\x04\x04\x17\x02\
    \x02\x12\x04\xa8\x02\x02\x20\n\r\n\x05\x04\x17\x02\x02\x05\x12\x04\xa8\
    \x02\x02\x07\n\r\n\x05\x04\x17\x02\x02\x01\x12\x04\xa8\x02\x08\x1b\n\r\n\
    \x05\x04\x17\x02\x02\x03\x12\x04\xa8\x02\x1e\x1f\n\x0c\n\x04\x04\x17\x02\
    \x03\x12\x04\xa9\x02\x02\x1f\n\r\n\x05\x04\x17\x02\x03\x05\x12\x04\xa9\
    \x02\x02\x07\n\r\n\x05\x04\x17\x02\x03\x01\x12\x04\xa9\x02\x08\x1a\n\r\n\
    \x05\x04\x17\x02\x03\x03\x12\x04\xa9\x02\x1d\x1e\n\x0c\n\x04\x04\x17\x02\
    \x04\x12\x04\xaa\x02\x02\x16\n\r\n\x05\x04\x17\x02\x04\x05\x12\x04\xaa\
    \x02\x02\x07\n\r\n\x05\x04\x17\x02\x04\x01\x12\x04\xaa\x02\x08\x11\n\r\n\
    \x05\x04\x17\x02\x04\x03\x12\x04\xaa\x02\x14\x15\n\x0c\n\x04\x04\x17\x02\
    \x05\x12\x04\xab\x02\x02\x14\n\r\n\x05\x04\x17\x02\x05\x05\x12\x04\xab\
    \x02\x02\x07\n\r\n\x05\x04\x17\x02\x05\x01\x12\x04\xab\x02\x08\x0f\n\r\n\
    \x05\x04\x17\x02\x05\x03\x12\x04\xab\x02\x12\x13\n\x0c\n\x04\x04\x17\x02\
    \x06\x12\x04\xac\x02\x02/\n\r\n\x05\x04\x17\x02\x06\x06\x12\x04\xac\x02\
    \x02#\n\r\n\x05\x04\x17\x02\x06\x01\x12\x04\xac\x02$*\n\r\n\x05\x04\x17\
    \x02\x06\x03\x12\x04\xac\x02-.\n\x0c\n\x02\x04\x18\x12\x06\xaf\x02\0\xb4\
    \x02\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\xaf\x02\x08\x19\n\x0c\n\x04\x04\
    \x18\x02\0\x12\x04\xb0\x02\x02\x19\n\r\n\x05\x04\x18\x02\0\x05\x12\x04\
    \xb0\x02\x02\x07\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xb0\x02\x08\x14\n\r\
    \n\x05\x04\x18\x02\0\x03\x12\x04\xb0\x02\x17\x18\n\x0c\n\x04\x04\x18\x02\
    \x01\x12\x04\xb1\x02\x02\x19\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\xb1\
    \x02\x02\x07\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xb1\x02\x08\x14\n\r\n\
    \x05\x04\x18\x02\x01\x03\x12\x04\xb1\x02\x17\x18\n\x0c\n\x04\x04\x18\x02\
    \x02\x12\x04\xb2\x02\x02\x1d\n\r\n\x05\x04\x18\x02\x02\x05\x12\x04\xb2\
    \x02\x02\x07\n\r\n\x05\x04\x18\x02\x02\x01\x12\x04\xb2\x02\x08\x18\n\r\n\
    \x05\x04\x18\x02\x02\x03\x12\x04\xb2\x02\x1b\x1c\n\x0c\n\x04\x04\x18\x02\
    \x03\x12\x04\xb3\x02\x02\x1c\n\r\n\x05\x04\x18\x02\x03\x05\x12\x04\xb3\
    \x02\x02\x07\n\r\n\x05\x04\x18\x02\x03\x01\x12\x04\xb3\x02\x08\x17\n\r\n\
    \x05\x04\x18\x02\x03\x03\x12\x04\xb3\x02\x1a\x1b\n\x0c\n\x02\x04\x19\x12\
    \x06\xb6\x02\0\xa1\x03\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\xb6\x02\x08\
    \x13\n\x0e\n\x04\x04\x19\x03\0\x12\x06\xb7\x02\x02\xe2\x02\x03\n\r\n\x05\
    \x04\x19\x03\0\x01\x12\x04\xb7\x02\n\x12\n\x10\n\x06\x04\x19\x03\0\x04\0\
    \x12\x06\xb8\x02\x04\xdc\x02\x05\n\x0f\n\x07\x04\x19\x03\0\x04\0\x01\x12\
    \x04\xb8\x02\t\x15\n\x10\n\x08\x04\x19\x03\0\x04\0\x02\0\x12\x04\xb9\x02\
    \x06\x20\n\x11\n\t\x04\x19\x03\0\x04\0\x02\0\x01\x12\x04\xb9\x02\x06\x1b\
    \n\x11\n\t\x04\x19\x03\0\x04\0\x02\0\x02\x12\x04\xb9\x02\x1e\x1f\n\x10\n\
    \x08\x04\x19\x03\0\x04\0\x02\x01\x12\x04\xba\x02\x06\x1b\n\x11\n\t\x04\
    \x19\x03\0\x04\0\x02\x01\x01\x12\x04\xba\x02\x06\x16\n\x11\n\t\x04\x19\
    \x03\0\x04\0\x02\x01\x02\x12\x04\xba\x02\x19\x1a\n\x10\n\x08\x04\x19\x03\
    \0\x04\0\x02\x02\x12\x04\xbb\x02\x06\x20\n\x11\n\t\x04\x19\x03\0\x04\0\
    \x02\x02\x01\x12\x04\xbb\x02\x06\x1b\n\x11\n\t\x04\x19\x03\0\x04\0\x02\
    \x02\x02\x12\x04\xbb\x02\x1e\x1f\n\x10\n\x08\x04\x19\x03\0\x04\0\x02\x03\
    \x12\x04\xbc\x02\x06\x1c\n\x11\n\t\x04\x19\x03\0\x04\0\x02\x03\x01\x12\
    \x04\xbc\x02\x06\x17\n\x11\n\t\x04\x19\x03\0\x04\0\x02\x03\x02\x12\x04\
    \xbc\x02\x1a\x1b\n\x10\n\x08\x04\x19\x03\0\x04\0\x02\x04\x12\x04\xbd\x02\
    \x06\x1e\n\x11\n\t\x04\x19\x03\0\x04\0\x02\x04\x01\x12\x04\xbd\x02\x06\
    \x19\n\x11\n\t\x04\x19\x03\0\x04\0\x02\x04\x02\x12\x04\xbd\x02\x1c\x1d\n\
    \x10\n\x08\x04\x19\x03\0\x04\0\x02\x05\x12\x04\xbe\x02\x06\x20\n\x11\n\t\
    \x04\x19\x03\0\x04\0\x02\x05\x01\x12\x04\xbe\x02\x06\x1b\n\x11\n\t\x04\
    \x19\x03\0\x04\0\x02\x05\x02\x12\x04\xbe\x02\x1e\x1f\n\x10\n\x08\x04\x19\
    \x03\0\x04\0\x02\x06\x12\x04\xbf\x02\x06\x1d\n\x11\n\t\x04\x19\x03\0\x04\
    \0\x02\x06\x01\x12\x04\xbf\x02\x06\x18\n\x11\n\t\x04\x19\x03\0\x04\0\x02\
    \x06\x02\x12\x04\xbf\x02\x1b\x1c\n\x10\n\x08\x04\x19\x03\0\x04\0\x02\x07\
    \x12\x04\xc0\x02\x06\x20\n\x11\n\t\x04\x19\x03\0\x04\0\x02\x07\x01\x12\
    \x04\xc0\x02\x06\x1b\n\x11\n\t\x04\x19\x03\0\x04\0\x02\x07\x02\x12\x04\
    \xc0\x02\x1e\x1f\n\x10\n\x08\x04\x19\x03\0\x04\0\x02\x08\x12\x04\xc1\x02\
    \x06(\n\x11\n\t\x04\x19\x03\0\x04\0\x02\x08\x01\x12\x04\xc1\x02\x06#\n\
    \x11\n\t\x04\x19\x03\0\x04\0\x02\x08\x02\x12\x04\xc1\x02&'\n\x10\n\x08\
    \x04\x19\x03\0\x04\0\x02\t\x12\x04\xc2\x02\x06!\n\x11\n\t\x04\x19\x03\0\
    \x04\0\x02\t\x01\x12\x04\xc2\x02\x06\x1b\n\x11\n\t\x04\x19\x03\0\x04\0\
    \x02\t\x02\x12\x04\xc2\x02\x1e\x20\n\x10\n\x08\x04\x19\x03\0\x04\0\x02\n\
    \x12\x04\xc3\x02\x06!\n\x11\n\t\x04\x19\x03\0\x04\0\x02\n\x01\x12\x04\
    \xc3\x02\x06\x1b\n\x11\n\t\x04\x19\x03\0\x04\0\x02\n\x02\x12\x04\xc3\x02\
    \x1e\x20\n\x10\n\x08\x04\x19\x03\0\x04\0\x02\x0b\x12\x04\xc4\x02\x06#\n\
    \x11\n\t\x04\x19\x03\0\x04\0\x02\x0b\x01\x12\x04\xc4\x02\x06\x1d\n\x11\n\
    \t\x04\x19\x03\0\x04\0\x02\x0b\x02\x12\x04\xc4\x02\x20\"\n\x10\n\x08\x04\
    \x19\x03\0\x04\0\x02\x0c\x12\x04\xc5\x02\x06#\n\x11\n\t\x04\x19\x03\0\
    \x04\0\x02\x0c\x01\x12\x04\xc5\x02\x06\x1d\n\x11\n\t\x04\x19\x03\0\x04\0\
    \x02\x0c\x02\x12\x04\xc5\x02\x20\"\n\x10\n\x08\x04\x19\x03\0\x04\0\x02\r\
    \x12\x04\xc6\x02\x06!\n\x11\n\t\x04\x19\x03\0\x04\0\x02\r\x01\x12\x04\
    \xc6\x02\x06\x1b\n\x11\n\t\x04\x19\x03\0\x04\0\x02\r\x02\x12\x04\xc6\x02\
    \x1e\x20\n\x10\n\x08\x04\x19\x03\0\x04\0\x02\x0e\x12\x04\xc7\x02\x06\x1f\
    \n\x11\n\t\x04\x19\x03\0\x04\0\x02\x0e\x01\x12\x04\xc7\x02\x06\x19\n\x11\
    \n\t\x04\x19\x03\0\x04\0\x02\x0e\x02\x12\x04\xc7\x02\x1c\x1e\n\x10\n\x08\
    \x04\x19\x03\0\x04\0\x02\x0f\x12\x04\xc8\x02\x06\"\n\x11\n\t\x04\x19\x03\
    \0\x04\0\x02\x0f\x01\x12\x04\xc8\x02\x06\x1c\n\x11\n\t\x04\x19\x03\0\x04\
    \0\x02\x0f\x02\x12\x04\xc8\x02\x1f!\n\x10\n\x08\x04\x19\x03\0\x04\0\x02\
    \x10\x12\x04\xc9\x02\x06#\n\x11\n\t\x04\x19\x03\0\x04\0\x02\x10\x01\x12\
    \x04\xc9\x02\x06\x1d\n\x11\n\t\x04\x19\x03\0\x04\0\x02\x10\x02\x12\x04\
    \xc9\x02\x20\"\n\x10\n\x08\x04\x19\x03\0\x04\0\x02\x11\x12\x04\xca\x02\
    \x06\"\n\x11\n\t\x04\x19\x03\0\x04\0\x02\x11\x01\x12\x04\xca\x02\x06\x1c\
    \n\x11\n\t\x04\x19\x03\0\x04\0\x02\x11\x02\x12\x04\xca\x02\x1f!\n\x10\n\
    \x08\x04\x19\x03\0\x04\0\x02\x12\x12\x04\xcb\x02\x06\x20\n\x11\n\t\x04\
    \x19\x03\0\x04\0\x02\x12\x01\x12\x04\xcb\x02\x06\x1a\n\x11\n\t\x04\x19\
    \x03\0\x04\0\x02\x12\x02\x12\x04\xcb\x02\x1d\x1f\n\x10\n\x08\x04\x19\x03\
    \0\x04\0\x02\x13\x12\x04\xcc\x02\x06\x1a\n\x11\n\t\x04\x19\x03\0\x04\0\
    \x02\x13\x01\x12\x04\xcc\x02\x06\x14\n\x11\n\t\x04\x19\x03\0\x04\0\x02\
    \x13\x02\x12\x04\xcc\x02\x17\x19\n\x10\n\x08\x04\x19\x03\0\x04\0\x02\x14\
    \x12\x04\xcd\x02\x06\x1f\n\x11\n\t\x04\x19\x03\0\x04\0\x02\x14\x01\x12\
    \x04\xcd\x02\x06\x19\n\x11\n\t\x04\x19\x03\0\x04\0\x02\x14\x02\x12\x04\
    \xcd\x02\x1c\x1e\n\x10\n\x08\x04\x19\x03\0\x04\0\x02\x15\x12\x04\xce\x02\
    \x06\x20\n\x11\n\t\x04\x19\x03\0\x04\0\x02\x15\x01\x12\x04\xce\x02\x06\
    \x1a\n\x11\n\t\x04\x19\x03\0\x04\0\x02\x15\x02\x12\x04\xce\x02\x1d\x1f\n\
    \x10\n\x08\x04\x19\x03\0\x04\0\x02\x16\x12\x04\xcf\x02\x06\x17\n\x11\n\t\
    \x04\x19\x03\0\x04\0\x02\x16\x01\x12\x04\xcf\x02\x06\x11\n\x11\n\t\x04\
    \x19\x03\0\x04\0\x02\x16\x02\x12\x04\xcf\x02\x14\x16\n\x10\n\x08\x04\x19\
    \x03\0\x04\0\x02\x17\x12\x04\xd0\x02\x06!\n\x11\n\t\x04\x19\x03\0\x04\0\
    \x02\x17\x01\x12\x04\xd0\x02\x06\x1b\n\x11\n\t\x04\x19\x03\0\x04\0\x02\
    \x17\x02\x12\x04\xd0\x02\x1e\x20\n\x10\n\x08\x04\x19\x03\0\x04\0\x02\x18\
    \x12\x04\xd1\x02\x06\"\n\x11\n\t\x04\x19\x03\0\x04\0\x02\x18\x01\x12\x04\
    \xd1\x02\x06\x1c\n\x11\n\t\x04\x19\x03\0\x04\0\x02\x18\x02\x12\x04\xd1\
    \x02\x1f!\n\x10\n\x08\x04\x19\x03\0\x04\0\x02\x19\x12\x04\xd2\x02\x06\"\
    \n\x11\n\t\x04\x19\x03\0\x04\0\x02\x19\x01\x12\x04\xd2\x02\x06\x1c\n\x11\
    \n\t\x04\x19\x03\0\x04\0\x02\x19\x02\x12\x04\xd2\x02\x1f!\n\x10\n\x08\
    \x04\x19\x03\0\x04\0\x02\x1a\x12\x04\xd3\x02\x06$\n\x11\n\t\x04\x19\x03\
    \0\x04\0\x02\x1a\x01\x12\x04\xd3\x02\x06\x1e\n\x11\n\t\x04\x19\x03\0\x04\
    \0\x02\x1a\x02\x12\x04\xd3\x02!#\n\x10\n\x08\x04\x19\x03\0\x04\0\x02\x1b\
    \x12\x04\xd4\x02\x06'\n\x11\n\t\x04\x19\x03\0\x04\0\x02\x1b\x01\x12\x04\
    \xd4\x02\x06!\n\x11\n\t\x04\x19\x03\0\x04\0\x02\x1b\x02\x12\x04\xd4\x02$\
    &\n\x10\n\x08\x04\x19\x03\0\x04\0\x02\x1c\x12\x04\xd5\x02\x06%\n\x11\n\t\
    \x04\x19\x03\0\x04\0\x02\x1c\x01\x12\x04\xd5\x02\x06\x1f\n\x11\n\t\x04\
    \x19\x03\0\x04\0\x02\x1c\x02\x12\x04\xd5\x02\"$\n\x10\n\x08\x04\x19\x03\
    \0\x04\0\x02\x1d\x12\x04\xd6\x02\x06+\n\x11\n\t\x04\x19\x03\0\x04\0\x02\
    \x1d\x01\x12\x04\xd6\x02\x06%\n\x11\n\t\x04\x19\x03\0\x04\0\x02\x1d\x02\
    \x12\x04\xd6\x02(*\n\x10\n\x08\x04\x19\x03\0\x04\0\x02\x1e\x12\x04\xd7\
    \x02\x06\x1c\n\x11\n\t\x04\x19\x03\0\x04\0\x02\x1e\x01\x12\x04\xd7\x02\
    \x06\x16\n\x11\n\t\x04\x19\x03\0\x04\0\x02\x1e\x02\x12\x04\xd7\x02\x19\
    \x1b\n\x10\n\x08\x04\x19\x03\0\x04\0\x02\x1f\x12\x04\xd8\x02\x06#\n\x11\
    \n\t\x04\x19\x03\0\x04\0\x02\x1f\x01\x12\x04\xd8\x02\x06\x1d\n\x11\n\t\
    \x04\x19\x03\0\x04\0\x02\x1f\x02\x12\x04\xd8\x02\x20\"\n\x10\n\x08\x04\
    \x19\x03\0\x04\0\x02\x20\x12\x04\xd9\x02\x06$\n\x11\n\t\x04\x19\x03\0\
    \x04\0\x02\x20\x01\x12\x04\xd9\x02\x06\x1e\n\x11\n\t\x04\x19\x03\0\x04\0\
    \x02\x20\x02\x12\x04\xd9\x02!#\n\x10\n\x08\x04\x19\x03\0\x04\0\x02!\x12\
    \x04\xda\x02\x06#\n\x11\n\t\x04\x19\x03\0\x04\0\x02!\x01\x12\x04\xda\x02\
    \x06\x1d\n\x11\n\t\x04\x19\x03\0\x04\0\x02!\x02\x12\x04\xda\x02\x20\"\n\
    \x10\n\x08\x04\x19\x03\0\x04\0\x02\"\x12\x04\xdb\x02\x06%\n\x11\n\t\x04\
    \x19\x03\0\x04\0\x02\"\x01\x12\x04\xdb\x02\x06\x1f\n\x11\n\t\x04\x19\x03\
    \0\x04\0\x02\"\x02\x12\x04\xdb\x02\"$\n\x0e\n\x06\x04\x19\x03\0\x02\0\
    \x12\x04\xdd\x02\x04\x1a\n\x0f\n\x07\x04\x19\x03\0\x02\0\x06\x12\x04\xdd\
    \x02\x04\x10\n\x0f\n\x07\x04\x19\x03\0\x02\0\x01\x12\x04\xdd\x02\x11\x15\
    \n\x0f\n\x07\x04\x19\x03\0\x02\0\x03\x12\x04\xdd\x02\x18\x19\n\x0e\n\x06\
    \x04\x19\x03\0\x02\x01\x12\x04\xde\x02\x04&\n\x0f\n\x07\x04\x19\x03\0\
    \x02\x01\x06\x12\x04\xde\x02\x04\x17\n\x0f\n\x07\x04\x19\x03\0\x02\x01\
    \x01\x12\x04\xde\x02\x18!\n\x0f\n\x07\x04\x19\x03\0\x02\x01\x03\x12\x04\
    \xde\x02$%\n\x0e\n\x06\x04\x19\x03\0\x02\x02\x12\x04\xdf\x02\x04\x17\n\
    \x0f\n\x07\x04\x19\x03\0\x02\x02\x05\x12\x04\xdf\x02\x04\t\n\x0f\n\x07\
    \x04\x19\x03\0\x02\x02\x01\x12\x04\xdf\x02\n\x12\n\x0f\n\x07\x04\x19\x03\
    \0\x02\x02\x03\x12\x04\xdf\x02\x15\x16\n\x0e\n\x06\x04\x19\x03\0\x02\x03\
    \x12\x04\xe0\x02\x04\x1b\n\x0f\n\x07\x04\x19\x03\0\x02\x03\x05\x12\x04\
    \xe0\x02\x04\t\n\x0f\n\x07\x04\x19\x03\0\x02\x03\x01\x12\x04\xe0\x02\n\
    \x16\n\x0f\n\x07\x04\x19\x03\0\x02\x03\x03\x12\x04\xe0\x02\x19\x1a\n\x0e\
    \n\x06\x04\x19\x03\0\x02\x04\x12\x04\xe1\x02\x04\x1c\n\x0f\n\x07\x04\x19\
    \x03\0\x02\x04\x05\x12\x04\xe1\x02\x04\t\n\x0f\n\x07\x04\x19\x03\0\x02\
    \x04\x01\x12\x04\xe1\x02\n\x17\n\x0f\n\x07\x04\x19\x03\0\x02\x04\x03\x12\
    \x04\xe1\x02\x1a\x1b\n\x0e\n\x04\x04\x19\x03\x01\x12\x06\xe4\x02\x02\x8b\
    \x03\x03\n\r\n\x05\x04\x19\x03\x01\x01\x12\x04\xe4\x02\n\x10\n\x10\n\x06\
    \x04\x19\x03\x01\x04\0\x12\x06\xe5\x02\x04\xe8\x02\x05\n\x0f\n\x07\x04\
    \x19\x03\x01\x04\0\x01\x12\x04\xe5\x02\t\r\n\x10\n\x08\x04\x19\x03\x01\
    \x04\0\x02\0\x12\x04\xe6\x02\x06\x11\n\x11\n\t\x04\x19\x03\x01\x04\0\x02\
    \0\x01\x12\x04\xe6\x02\x06\x0c\n\x11\n\t\x04\x19\x03\x01\x04\0\x02\0\x02\
    \x12\x04\xe6\x02\x0f\x10\n\x10\n\x08\x04\x19\x03\x01\x04\0\x02\x01\x12\
    \x04\xe7\x02\x06\x11\n\x11\n\t\x04\x19\x03\x01\x04\0\x02\x01\x01\x12\x04\
    \xe7\x02\x06\x0c\n\x11\n\t\x04\x19\x03\x01\x04\0\x02\x01\x02\x12\x04\xe7\
    \x02\x0f\x10\n\x10\n\x06\x04\x19\x03\x01\x04\x01\x12\x06\xe9\x02\x04\xfa\
    \x02\x05\n\x0f\n\x07\x04\x19\x03\x01\x04\x01\x01\x12\x04\xe9\x02\t\x17\n\
    \x10\n\x08\x04\x19\x03\x01\x04\x01\x02\0\x12\x04\xea\x02\x06\x12\n\x11\n\
    \t\x04\x19\x03\x01\x04\x01\x02\0\x01\x12\x04\xea\x02\x06\r\n\x11\n\t\x04\
    \x19\x03\x01\x04\x01\x02\0\x02\x12\x04\xea\x02\x10\x11\n\x10\n\x08\x04\
    \x19\x03\x01\x04\x01\x02\x01\x12\x04\xeb\x02\x06\x12\n\x11\n\t\x04\x19\
    \x03\x01\x04\x01\x02\x01\x01\x12\x04\xeb\x02\x06\r\n\x11\n\t\x04\x19\x03\
    \x01\x04\x01\x02\x01\x02\x12\x04\xeb\x02\x10\x11\n\x10\n\x08\x04\x19\x03\
    \x01\x04\x01\x02\x02\x12\x04\xec\x02\x06\x11\n\x11\n\t\x04\x19\x03\x01\
    \x04\x01\x02\x02\x01\x12\x04\xec\x02\x06\x0c\n\x11\n\t\x04\x19\x03\x01\
    \x04\x01\x02\x02\x02\x12\x04\xec\x02\x0f\x10\n\x10\n\x08\x04\x19\x03\x01\
    \x04\x01\x02\x03\x12\x04\xed\x02\x06\x1f\n\x11\n\t\x04\x19\x03\x01\x04\
    \x01\x02\x03\x01\x12\x04\xed\x02\x06\x1a\n\x11\n\t\x04\x19\x03\x01\x04\
    \x01\x02\x03\x02\x12\x04\xed\x02\x1d\x1e\n\x10\n\x08\x04\x19\x03\x01\x04\
    \x01\x02\x04\x12\x04\xee\x02\x06\x18\n\x11\n\t\x04\x19\x03\x01\x04\x01\
    \x02\x04\x01\x12\x04\xee\x02\x06\x13\n\x11\n\t\x04\x19\x03\x01\x04\x01\
    \x02\x04\x02\x12\x04\xee\x02\x16\x17\n\x10\n\x08\x04\x19\x03\x01\x04\x01\
    \x02\x05\x12\x04\xef\x02\x06\x1f\n\x11\n\t\x04\x19\x03\x01\x04\x01\x02\
    \x05\x01\x12\x04\xef\x02\x06\x1a\n\x11\n\t\x04\x19\x03\x01\x04\x01\x02\
    \x05\x02\x12\x04\xef\x02\x1d\x1e\n\x10\n\x08\x04\x19\x03\x01\x04\x01\x02\
    \x06\x12\x04\xf0\x02\x06\x1a\n\x11\n\t\x04\x19\x03\x01\x04\x01\x02\x06\
    \x01\x12\x04\xf0\x02\x06\x15\n\x11\n\t\x04\x19\x03\x01\x04\x01\x02\x06\
    \x02\x12\x04\xf0\x02\x18\x19\n\x10\n\x08\x04\x19\x03\x01\x04\x01\x02\x07\
    \x12\x04\xf1\x02\x06\x1a\n\x11\n\t\x04\x19\x03\x01\x04\x01\x02\x07\x01\
    \x12\x04\xf1\x02\x06\x15\n\x11\n\t\x04\x19\x03\x01\x04\x01\x02\x07\x02\
    \x12\x04\xf1\x02\x18\x19\n\x10\n\x08\x04\x19\x03\x01\x04\x01\x02\x08\x12\
    \x04\xf2\x02\x06\x1c\n\x11\n\t\x04\x19\x03\x01\x04\x01\x02\x08\x01\x12\
    \x04\xf2\x02\x06\x17\n\x11\n\t\x04\x19\x03\x01\x04\x01\x02\x08\x02\x12\
    \x04\xf2\x02\x1a\x1b\n\x10\n\x08\x04\x19\x03\x01\x04\x01\x02\t\x12\x04\
    \xf3\x02\x06\x19\n\x11\n\t\x04\x19\x03\x01\x04\x01\x02\t\x01\x12\x04\xf3\
    \x02\x06\x14\n\x11\n\t\x04\x19\x03\x01\x04\x01\x02\t\x02\x12\x04\xf3\x02\
    \x17\x18\n\x10\n\x08\x04\x19\x03\x01\x04\x01\x02\n\x12\x04\xf4\x02\x06\
    \x19\n\x11\n\t\x04\x19\x03\x01\x04\x01\x02\n\x01\x12\x04\xf4\x02\x06\x13\
    \n\x11\n\t\x04\x19\x03\x01\x04\x01\x02\n\x02\x12\x04\xf4\x02\x16\x18\n\
    \x10\n\x08\x04\x19\x03\x01\x04\x01\x02\x0b\x12\x04\xf5\x02\x06\x17\n\x11\
    \n\t\x04\x19\x03\x01\x04\x01\x02\x0b\x01\x12\x04\xf5\x02\x06\x11\n\x11\n\
    \t\x04\x19\x03\x01\x04\x01\x02\x0b\x02\x12\x04\xf5\x02\x14\x16\n\x10\n\
    \x08\x04\x19\x03\x01\x04\x01\x02\x0c\x12\x04\xf6\x02\x06\x1f\n\x11\n\t\
    \x04\x19\x03\x01\x04\x01\x02\x0c\x01\x12\x04\xf6\x02\x06\x19\n\x11\n\t\
    \x04\x19\x03\x01\x04\x01\x02\x0c\x02\x12\x04\xf6\x02\x1c\x1e\n\x10\n\x08\
    \x04\x19\x03\x01\x04\x01\x02\r\x12\x04\xf7\x02\x06\x13\n\x11\n\t\x04\x19\
    \x03\x01\x04\x01\x02\r\x01\x12\x04\xf7\x02\x06\r\n\x11\n\t\x04\x19\x03\
    \x01\x04\x01\x02\r\x02\x12\x04\xf7\x02\x10\x12\n\x10\n\x08\x04\x19\x03\
    \x01\x04\x01\x02\x0e\x12\x04\xf8\x02\x06\x1b\n\x11\n\t\x04\x19\x03\x01\
    \x04\x01\x02\x0e\x01\x12\x04\xf8\x02\x06\x15\n\x11\n\t\x04\x19\x03\x01\
    \x04\x01\x02\x0e\x02\x12\x04\xf8\x02\x18\x1a\n\x10\n\x08\x04\x19\x03\x01\
    \x04\x01\x02\x0f\x12\x04\xf9\x02\x06\x18\n\x11\n\t\x04\x19\x03\x01\x04\
    \x01\x02\x0f\x01\x12\x04\xf9\x02\x06\x12\n\x11\n\t\x04\x19\x03\x01\x04\
    \x01\x02\x0f\x02\x12\x04\xf9\x02\x15\x17\n\x0e\n\x06\x04\x19\x03\x01\x02\
    \0\x12\x04\xfb\x02\x04\x12\n\x0f\n\x07\x04\x19\x03\x01\x02\0\x05\x12\x04\
    \xfb\x02\x04\t\n\x0f\n\x07\x04\x19\x03\x01\x02\0\x01\x12\x04\xfb\x02\n\r\
    \n\x0f\n\x07\x04\x19\x03\x01\x02\0\x03\x12\x04\xfb\x02\x10\x11\n\x0e\n\
    \x06\x04\x19\x03\x01\x02\x01\x12\x04\xfc\x02\x04\x11\n\x0f\n\x07\x04\x19\
    \x03\x01\x02\x01\x06\x12\x04\xfc\x02\x04\x08\n\x0f\n\x07\x04\x19\x03\x01\
    \x02\x01\x01\x12\x04\xfc\x02\t\x0c\n\x0f\n\x07\x04\x19\x03\x01\x02\x01\
    \x03\x12\x04\xfc\x02\x0f\x10\n\x0e\n\x06\x04\x19\x03\x01\x02\x02\x12\x04\
    \xfd\x02\x04#\n\x0f\n\x07\x04\x19\x03\x01\x02\x02\x06\x12\x04\xfd\x02\
    \x04\x12\n\x0f\n\x07\x04\x19\x03\x01\x02\x02\x01\x12\x04\xfd\x02\x13\x1e\
    \n\x0f\n\x07\x04\x19\x03\x01\x02\x02\x03\x12\x04\xfd\x02!\"\n\x0e\n\x06\
    \x04\x19\x03\x01\x02\x03\x12\x04\xff\x02\x04\x1d\n\x0f\n\x07\x04\x19\x03\
    \x01\x02\x03\x05\x12\x04\xff\x02\x04\n\n\x0f\n\x07\x04\x19\x03\x01\x02\
    \x03\x01\x12\x04\xff\x02\x0b\x17\n\x0f\n\x07\x04\x19\x03\x01\x02\x03\x03\
    \x12\x04\xff\x02\x1a\x1c\n\x0e\n\x06\x04\x19\x03\x01\x02\x04\x12\x04\x80\
    \x03\x04\x1f\n\x0f\n\x07\x04\x19\x03\x01\x02\x04\x05\x12\x04\x80\x03\x04\
    \t\n\x0f\n\x07\x04\x19\x03\x01\x02\x04\x01\x12\x04\x80\x03\n\x19\n\x0f\n\
    \x07\x04\x19\x03\x01\x02\x04\x03\x12\x04\x80\x03\x1c\x1e\n\x0e\n\x06\x04\
    \x19\x03\x01\x02\x05\x12\x04\x81\x03\x04\x1f\n\x0f\n\x07\x04\x19\x03\x01\
    \x02\x05\x05\x12\x04\x81\x03\x04\t\n\x0f\n\x07\x04\x19\x03\x01\x02\x05\
    \x01\x12\x04\x81\x03\n\x19\n\x0f\n\x07\x04\x19\x03\x01\x02\x05\x03\x12\
    \x04\x81\x03\x1c\x1e\n\x0e\n\x06\x04\x19\x03\x01\x02\x06\x12\x04\x82\x03\
    \x04(\n\x0f\n\x07\x04\x19\x03\x01\x02\x06\x05\x12\x04\x82\x03\x04\t\n\
    \x0f\n\x07\x04\x19\x03\x01\x02\x06\x01\x12\x04\x82\x03\n\"\n\x0f\n\x07\
    \x04\x19\x03\x01\x02\x06\x03\x12\x04\x82\x03%'\n\x0e\n\x06\x04\x19\x03\
    \x01\x02\x07\x12\x04\x83\x03\x04.\n\x0f\n\x07\x04\x19\x03\x01\x02\x07\
    \x05\x12\x04\x83\x03\x04\t\n\x0f\n\x07\x04\x19\x03\x01\x02\x07\x01\x12\
    \x04\x83\x03\n(\n\x0f\n\x07\x04\x19\x03\x01\x02\x07\x03\x12\x04\x83\x03+\
    -\n\x0e\n\x06\x04\x19\x03\x01\x02\x08\x12\x04\x84\x03\x040\n\x0f\n\x07\
    \x04\x19\x03\x01\x02\x08\x05\x12\x04\x84\x03\x04\t\n\x0f\n\x07\x04\x19\
    \x03\x01\x02\x08\x01\x12\x04\x84\x03\n*\n\x0f\n\x07\x04\x19\x03\x01\x02\
    \x08\x03\x12\x04\x84\x03-/\n\x0e\n\x06\x04\x19\x03\x01\x02\t\x12\x04\x85\
    \x03\x04\x1b\n\x0f\n\x07\x04\x19\x03\x01\x02\t\x05\x12\x04\x85\x03\x04\t\
    \n\x0f\n\x07\x04\x19\x03\x01\x02\t\x01\x12\x04\x85\x03\n\x15\n\x0f\n\x07\
    \x04\x19\x03\x01\x02\t\x03\x12\x04\x85\x03\x18\x1a\n\x0e\n\x06\x04\x19\
    \x03\x01\x02\n\x12\x04\x86\x03\x04(\n\x0f\n\x07\x04\x19\x03\x01\x02\n\
    \x05\x12\x04\x86\x03\x04\t\n\x0f\n\x07\x04\x19\x03\x01\x02\n\x01\x12\x04\
    \x86\x03\n\"\n\x0f\n\x07\x04\x19\x03\x01\x02\n\x03\x12\x04\x86\x03%'\n\
    \x0e\n\x06\x04\x19\x03\x01\x02\x0b\x12\x04\x89\x03\x04\x17\n\x0f\n\x07\
    \x04\x19\x03\x01\x02\x0b\x05\x12\x04\x89\x03\x04\t\n\x0f\n\x07\x04\x19\
    \x03\x01\x02\x0b\x01\x12\x04\x89\x03\n\x11\n\x0f\n\x07\x04\x19\x03\x01\
    \x02\x0b\x03\x12\x04\x89\x03\x14\x16\n\x0e\n\x06\x04\x19\x03\x01\x02\x0c\
    \x12\x04\x8a\x03\x041\n\x0f\n\x07\x04\x19\x03\x01\x02\x0c\x04\x12\x04\
    \x8a\x03\x04\x0c\n\x0f\n\x07\x04\x19\x03\x01\x02\x0c\x06\x12\x04\x8a\x03\
    \r\x1e\n\x0f\n\x07\x04\x19\x03\x01\x02\x0c\x01\x12\x04\x8a\x03\x1f+\n\
    \x0f\n\x07\x04\x19\x03\x01\x02\x0c\x03\x12\x04\x8a\x03.0\n\x0e\n\x04\x04\
    \x19\x03\x02\x12\x06\x8d\x03\x02\x9b\x03\x03\n\r\n\x05\x04\x19\x03\x02\
    \x01\x12\x04\x8d\x03\n\r\n\x0e\n\x06\x04\x19\x03\x02\x02\0\x12\x04\x8e\
    \x03\x04\x1e\n\x0f\n\x07\x04\x19\x03\x02\x02\0\x05\x12\x04\x8e\x03\x04\t\
    \n\x0f\n\x07\x04\x19\x03\x02\x02\0\x01\x12\x04\x8e\x03\n\x19\n\x0f\n\x07\
    \x04\x19\x03\x02\x02\0\x03\x12\x04\x8e\x03\x1c\x1d\n\x0e\n\x06\x04\x19\
    \x03\x02\x02\x01\x12\x04\x8f\x03\x04\x1c\n\x0f\n\x07\x04\x19\x03\x02\x02\
    \x01\x05\x12\x04\x8f\x03\x04\t\n\x0f\n\x07\x04\x19\x03\x02\x02\x01\x01\
    \x12\x04\x8f\x03\n\x17\n\x0f\n\x07\x04\x19\x03\x02\x02\x01\x03\x12\x04\
    \x8f\x03\x1a\x1b\n\x0e\n\x06\x04\x19\x03\x02\x02\x02\x12\x04\x90\x03\x04\
    \x1d\n\x0f\n\x07\x04\x19\x03\x02\x02\x02\x05\x12\x04\x90\x03\x04\t\n\x0f\
    \n\x07\x04\x19\x03\x02\x02\x02\x01\x12\x04\x90\x03\n\x18\n\x0f\n\x07\x04\
    \x19\x03\x02\x02\x02\x03\x12\x04\x90\x03\x1b\x1c\n\x0e\n\x06\x04\x19\x03\
    \x02\x02\x03\x12\x04\x91\x03\x04\x19\n\x0f\n\x07\x04\x19\x03\x02\x02\x03\
    \x05\x12\x04\x91\x03\x04\t\n\x0f\n\x07\x04\x19\x03\x02\x02\x03\x01\x12\
    \x04\x91\x03\n\x14\n\x0f\n\x07\x04\x19\x03\x02\x02\x03\x03\x12\x04\x91\
    \x03\x17\x18\n\x0e\n\x06\x04\x19\x03\x02\x02\x04\x12\x04\x92\x03\x04!\n\
    \x0f\n\x07\x04\x19\x03\x02\x02\x04\x04\x12\x04\x92\x03\x04\x0c\n\x0f\n\
    \x07\x04\x19\x03\x02\x02\x04\x06\x12\x04\x92\x03\r\x16\n\x0f\n\x07\x04\
    \x19\x03\x02\x02\x04\x01\x12\x04\x92\x03\x17\x1c\n\x0f\n\x07\x04\x19\x03\
    \x02\x02\x04\x03\x12\x04\x92\x03\x1f\x20\n\x1f\n\x06\x04\x19\x03\x02\x02\
    \x05\x12\x04\x94\x03\x04\x14\x1a\x0f\x20data\x20not\x20used\n\n\x0f\n\
    \x07\x04\x19\x03\x02\x02\x05\x05\x12\x04\x94\x03\x04\t\n\x0f\n\x07\x04\
    \x19\x03\x02\x02\x05\x01\x12\x04\x94\x03\n\x0e\n\x0f\n\x07\x04\x19\x03\
    \x02\x02\x05\x03\x12\x04\x94\x03\x11\x13\nI\n\x06\x04\x19\x03\x02\x02\
    \x06\x12\x04\x96\x03\x04$\x1a9only\x20support\x20size\x20=\x201,\x20\x20\
    repeated\x20list\x20here\x20for\x20extension\n\n\x0f\n\x07\x04\x19\x03\
    \x02\x02\x06\x04\x12\x04\x96\x03\x04\x0c\n\x0f\n\x07\x04\x19\x03\x02\x02\
    \x06\x06\x12\x04\x96\x03\r\x15\n\x0f\n\x07\x04\x19\x03\x02\x02\x06\x01\
    \x12\x04\x96\x03\x16\x1e\n\x0f\n\x07\x04\x19\x03\x02\x02\x06\x03\x12\x04\
    \x96\x03!#\n\"\n\x06\x04\x19\x03\x02\x02\x07\x12\x04\x98\x03\x04\x17\x1a\
    \x12\x20scripts\x20not\x20used\n\n\x0f\n\x07\x04\x19\x03\x02\x02\x07\x05\
    \x12\x04\x98\x03\x04\t\n\x0f\n\x07\x04\x19\x03\x02\x02\x07\x01\x12\x04\
    \x98\x03\n\x11\n\x0f\n\x07\x04\x19\x03\x02\x02\x07\x03\x12\x04\x98\x03\
    \x14\x16\n\x0e\n\x06\x04\x19\x03\x02\x02\x08\x12\x04\x99\x03\x04\x19\n\
    \x0f\n\x07\x04\x19\x03\x02\x02\x08\x05\x12\x04\x99\x03\x04\t\n\x0f\n\x07\
    \x04\x19\x03\x02\x02\x08\x01\x12\x04\x99\x03\n\x13\n\x0f\n\x07\x04\x19\
    \x03\x02\x02\x08\x03\x12\x04\x99\x03\x16\x18\n\x0e\n\x06\x04\x19\x03\x02\
    \x02\t\x12\x04\x9a\x03\x04\x19\n\x0f\n\x07\x04\x19\x03\x02\x02\t\x05\x12\
    \x04\x9a\x03\x04\t\n\x0f\n\x07\x04\x19\x03\x02\x02\t\x01\x12\x04\x9a\x03\
    \n\x13\n\x0f\n\x07\x04\x19\x03\x02\x02\t\x03\x12\x04\x9a\x03\x16\x18\n\
    \x0c\n\x04\x04\x19\x02\0\x12\x04\x9d\x03\x02\x13\n\r\n\x05\x04\x19\x02\0\
    \x06\x12\x04\x9d\x03\x02\x05\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\x9d\x03\
    \x06\x0e\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\x9d\x03\x11\x12\nQ\n\x04\
    \x04\x19\x02\x01\x12\x04\x9f\x03\x02\x1f\x1aC\x20only\x20support\x20size\
    \x20=\x201,\x20\x20repeated\x20list\x20here\x20for\x20muti-sig\x20extens\
    ion\n\n\r\n\x05\x04\x19\x02\x01\x04\x12\x04\x9f\x03\x02\n\n\r\n\x05\x04\
    \x19\x02\x01\x05\x12\x04\x9f\x03\x0b\x10\n\r\n\x05\x04\x19\x02\x01\x01\
    \x12\x04\x9f\x03\x11\x1a\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\x9f\x03\
    \x1d\x1e\n\x0c\n\x04\x04\x19\x02\x02\x12\x04\xa0\x03\x02\x1a\n\r\n\x05\
    \x04\x19\x02\x02\x04\x12\x04\xa0\x03\x02\n\n\r\n\x05\x04\x19\x02\x02\x06\
    \x12\x04\xa0\x03\x0b\x11\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\xa0\x03\
    \x12\x15\n\r\n\x05\x04\x19\x02\x02\x03\x12\x04\xa0\x03\x18\x19\n\x0c\n\
    \x02\x04\x1a\x12\x06\xa3\x03\0\xc5\x03\x01\n\x0b\n\x03\x04\x1a\x01\x12\
    \x04\xa3\x03\x08\x17\n\x0e\n\x04\x04\x1a\x04\0\x12\x06\xa4\x03\x02\xa7\
    \x03\x03\n\r\n\x05\x04\x1a\x04\0\x01\x12\x04\xa4\x03\x07\x0b\n\x0e\n\x06\
    \x04\x1a\x04\0\x02\0\x12\x04\xa5\x03\x04\x0f\n\x0f\n\x07\x04\x1a\x04\0\
    \x02\0\x01\x12\x04\xa5\x03\x04\n\n\x0f\n\x07\x04\x1a\x04\0\x02\0\x02\x12\
    \x04\xa5\x03\r\x0e\n\x0e\n\x06\x04\x1a\x04\0\x02\x01\x12\x04\xa6\x03\x04\
    \x0f\n\x0f\n\x07\x04\x1a\x04\0\x02\x01\x01\x12\x04\xa6\x03\x04\n\n\x0f\n\
    \x07\x04\x1a\x04\0\x02\x01\x02\x12\x04\xa6\x03\r\x0e\n\x0e\n\x04\x04\x1a\
    \x03\0\x12\x06\xa8\x03\x02\xac\x03\x03\n\r\n\x05\x04\x1a\x03\0\x01\x12\
    \x04\xa8\x03\n\r\n\x0e\n\x06\x04\x1a\x03\0\x02\0\x12\x04\xa9\x03\x04\x16\
    \n\x0f\n\x07\x04\x1a\x03\0\x02\0\x05\x12\x04\xa9\x03\x04\t\n\x0f\n\x07\
    \x04\x1a\x03\0\x02\0\x01\x12\x04\xa9\x03\n\x11\n\x0f\n\x07\x04\x1a\x03\0\
    \x02\0\x03\x12\x04\xa9\x03\x14\x15\n\x0e\n\x06\x04\x1a\x03\0\x02\x01\x12\
    \x04\xaa\x03\x04\x1e\n\x0f\n\x07\x04\x1a\x03\0\x02\x01\x04\x12\x04\xaa\
    \x03\x04\x0c\n\x0f\n\x07\x04\x1a\x03\0\x02\x01\x05\x12\x04\xaa\x03\r\x12\
    \n\x0f\n\x07\x04\x1a\x03\0\x02\x01\x01\x12\x04\xaa\x03\x13\x19\n\x0f\n\
    \x07\x04\x1a\x03\0\x02\x01\x03\x12\x04\xaa\x03\x1c\x1d\n\x0e\n\x06\x04\
    \x1a\x03\0\x02\x02\x12\x04\xab\x03\x04\x13\n\x0f\n\x07\x04\x1a\x03\0\x02\
    \x02\x05\x12\x04\xab\x03\x04\t\n\x0f\n\x07\x04\x1a\x03\0\x02\x02\x01\x12\
    \x04\xab\x03\n\x0e\n\x0f\n\x07\x04\x1a\x03\0\x02\x02\x03\x12\x04\xab\x03\
    \x11\x12\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\xad\x03\x02\x0f\n\r\n\x05\x04\
    \x1a\x02\0\x05\x12\x04\xad\x03\x02\x07\n\r\n\x05\x04\x1a\x02\0\x01\x12\
    \x04\xad\x03\x08\n\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xad\x03\r\x0e\n\
    \x0c\n\x04\x04\x1a\x02\x01\x12\x04\xae\x03\x02\x10\n\r\n\x05\x04\x1a\x02\
    \x01\x05\x12\x04\xae\x03\x02\x07\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\
    \xae\x03\x08\x0b\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xae\x03\x0e\x0f\n\
    \x0c\n\x04\x04\x1a\x02\x02\x12\x04\xaf\x03\x02\x18\n\r\n\x05\x04\x1a\x02\
    \x02\x05\x12\x04\xaf\x03\x02\x07\n\r\n\x05\x04\x1a\x02\x02\x01\x12\x04\
    \xaf\x03\x08\x13\n\r\n\x05\x04\x1a\x02\x02\x03\x12\x04\xaf\x03\x16\x17\n\
    \x0c\n\x04\x04\x1a\x02\x03\x12\x04\xb0\x03\x02\x1b\n\r\n\x05\x04\x1a\x02\
    \x03\x05\x12\x04\xb0\x03\x02\x07\n\r\n\x05\x04\x1a\x02\x03\x01\x12\x04\
    \xb0\x03\x08\x16\n\r\n\x05\x04\x1a\x02\x03\x03\x12\x04\xb0\x03\x19\x1a\n\
    \x0c\n\x04\x04\x1a\x02\x04\x12\x04\xb1\x03\x02$\n\r\n\x05\x04\x1a\x02\
    \x04\x04\x12\x04\xb1\x03\x02\n\n\r\n\x05\x04\x1a\x02\x04\x05\x12\x04\xb1\
    \x03\x0b\x10\n\r\n\x05\x04\x1a\x02\x04\x01\x12\x04\xb1\x03\x11\x1f\n\r\n\
    \x05\x04\x1a\x02\x04\x03\x12\x04\xb1\x03\"#\n\x0c\n\x04\x04\x1a\x02\x05\
    \x12\x04\xb2\x03\x02\x1d\n\r\n\x05\x04\x1a\x02\x05\x05\x12\x04\xb2\x03\
    \x02\x07\n\r\n\x05\x04\x1a\x02\x05\x01\x12\x04\xb2\x03\x08\x18\n\r\n\x05\
    \x04\x1a\x02\x05\x03\x12\x04\xb2\x03\x1b\x1c\n\x0c\n\x04\x04\x1a\x02\x06\
    \x12\x04\xb3\x03\x02\x1e\n\r\n\x05\x04\x1a\x02\x06\x06\x12\x04\xb3\x03\
    \x02\x11\n\r\n\x05\x04\x1a\x02\x06\x01\x12\x04\xb3\x03\x12\x19\n\r\n\x05\
    \x04\x1a\x02\x06\x03\x12\x04\xb3\x03\x1c\x1d\n\x0c\n\x04\x04\x1a\x02\x07\
    \x12\x04\xb4\x03\x02\x17\n\r\n\x05\x04\x1a\x02\x07\x04\x12\x04\xb4\x03\
    \x02\n\n\r\n\x05\x04\x1a\x02\x07\x06\x12\x04\xb4\x03\x0b\x0e\n\r\n\x05\
    \x04\x1a\x02\x07\x01\x12\x04\xb4\x03\x0f\x12\n\r\n\x05\x04\x1a\x02\x07\
    \x03\x12\x04\xb4\x03\x15\x16\n\x0c\n\x04\x04\x1a\x02\x08\x12\x04\xb5\x03\
    \x02\x12\n\r\n\x05\x04\x1a\x02\x08\x06\x12\x04\xb5\x03\x02\x06\n\r\n\x05\
    \x04\x1a\x02\x08\x01\x12\x04\xb5\x03\x07\r\n\r\n\x05\x04\x1a\x02\x08\x03\
    \x12\x04\xb5\x03\x10\x11\n\x0c\n\x04\x04\x1a\x02\t\x12\x04\xb6\x03\x02\
    \x18\n\r\n\x05\x04\x1a\x02\t\x05\x12\x04\xb6\x03\x02\x07\n\r\n\x05\x04\
    \x1a\x02\t\x01\x12\x04\xb6\x03\x08\x12\n\r\n\x05\x04\x1a\x02\t\x03\x12\
    \x04\xb6\x03\x15\x17\n\x0c\n\x04\x04\x1a\x02\n\x12\x04\xb8\x03\x02\x1b\n\
    \r\n\x05\x04\x1a\x02\n\x05\x12\x04\xb8\x03\x02\x08\n\r\n\x05\x04\x1a\x02\
    \n\x01\x12\x04\xb8\x03\t\x15\n\r\n\x05\x04\x1a\x02\n\x03\x12\x04\xb8\x03\
    \x18\x1a\n\x0c\n\x04\x04\x1a\x02\x0b\x12\x04\xb9\x03\x02\x1d\n\r\n\x05\
    \x04\x1a\x02\x0b\x05\x12\x04\xb9\x03\x02\x07\n\r\n\x05\x04\x1a\x02\x0b\
    \x01\x12\x04\xb9\x03\x08\x17\n\r\n\x05\x04\x1a\x02\x0b\x03\x12\x04\xb9\
    \x03\x1a\x1c\n\x0c\n\x04\x04\x1a\x02\x0c\x12\x04\xba\x03\x02\x1d\n\r\n\
    \x05\x04\x1a\x02\x0c\x05\x12\x04\xba\x03\x02\x07\n\r\n\x05\x04\x1a\x02\
    \x0c\x01\x12\x04\xba\x03\x08\x17\n\r\n\x05\x04\x1a\x02\x0c\x03\x12\x04\
    \xba\x03\x1a\x1c\n\x0c\n\x04\x04\x1a\x02\r\x12\x04\xbb\x03\x02:\n\r\n\
    \x05\x04\x1a\x02\r\x04\x12\x04\xbb\x03\x02\n\n\r\n\x05\x04\x1a\x02\r\x06\
    \x12\x04\xbb\x03\x0b\x1e\n\r\n\x05\x04\x1a\x02\r\x01\x12\x04\xbb\x03\x1f\
    4\n\r\n\x05\x04\x1a\x02\r\x03\x12\x04\xbb\x0379\n\x0c\n\x04\x04\x1a\x02\
    \x0e\x12\x04\xbc\x03\x02&\n\r\n\x05\x04\x1a\x02\x0e\x05\x12\x04\xbc\x03\
    \x02\x07\n\r\n\x05\x04\x1a\x02\x0e\x01\x12\x04\xbc\x03\x08\x20\n\r\n\x05\
    \x04\x1a\x02\x0e\x03\x12\x04\xbc\x03#%\n\x0c\n\x04\x04\x1a\x02\x0f\x12\
    \x04\xbd\x03\x02,\n\r\n\x05\x04\x1a\x02\x0f\x05\x12\x04\xbd\x03\x02\x07\
    \n\r\n\x05\x04\x1a\x02\x0f\x01\x12\x04\xbd\x03\x08&\n\r\n\x05\x04\x1a\
    \x02\x0f\x03\x12\x04\xbd\x03)+\n\x0c\n\x04\x04\x1a\x02\x10\x12\x04\xbe\
    \x03\x02.\n\r\n\x05\x04\x1a\x02\x10\x05\x12\x04\xbe\x03\x02\x07\n\r\n\
    \x05\x04\x1a\x02\x10\x01\x12\x04\xbe\x03\x08(\n\r\n\x05\x04\x1a\x02\x10\
    \x03\x12\x04\xbe\x03+-\n\x0c\n\x04\x04\x1a\x02\x11\x12\x04\xbf\x03\x02\
    \x19\n\r\n\x05\x04\x1a\x02\x11\x05\x12\x04\xbf\x03\x02\x07\n\r\n\x05\x04\
    \x1a\x02\x11\x01\x12\x04\xbf\x03\x08\x13\n\r\n\x05\x04\x1a\x02\x11\x03\
    \x12\x04\xbf\x03\x16\x18\n\x0c\n\x04\x04\x1a\x02\x12\x12\x04\xc0\x03\x02\
    &\n\r\n\x05\x04\x1a\x02\x12\x05\x12\x04\xc0\x03\x02\x07\n\r\n\x05\x04\
    \x1a\x02\x12\x01\x12\x04\xc0\x03\x08\x20\n\r\n\x05\x04\x1a\x02\x12\x03\
    \x12\x04\xc0\x03#%\n\x0c\n\x04\x04\x1a\x02\x13\x12\x04\xc2\x03\x02\x15\n\
    \r\n\x05\x04\x1a\x02\x13\x05\x12\x04\xc2\x03\x02\x07\n\r\n\x05\x04\x1a\
    \x02\x13\x01\x12\x04\xc2\x03\x08\x0f\n\r\n\x05\x04\x1a\x02\x13\x03\x12\
    \x04\xc2\x03\x12\x14\n\x0c\n\x04\x04\x1a\x02\x14\x12\x04\xc3\x03\x02/\n\
    \r\n\x05\x04\x1a\x02\x14\x04\x12\x04\xc3\x03\x02\n\n\r\n\x05\x04\x1a\x02\
    \x14\x06\x12\x04\xc3\x03\x0b\x1c\n\r\n\x05\x04\x1a\x02\x14\x01\x12\x04\
    \xc3\x03\x1d)\n\r\n\x05\x04\x1a\x02\x14\x03\x12\x04\xc3\x03,.\n\x0c\n\
    \x04\x04\x1a\x02\x15\x12\x04\xc4\x03\x02\x18\n\r\n\x05\x04\x1a\x02\x15\
    \x05\x12\x04\xc4\x03\x02\x07\n\r\n\x05\x04\x1a\x02\x15\x01\x12\x04\xc4\
    \x03\x08\x12\n\r\n\x05\x04\x1a\x02\x15\x03\x12\x04\xc4\x03\x15\x17\n\x0c\
    \n\x02\x04\x1b\x12\x06\xc7\x03\0\xcb\x03\x01\n\x0b\n\x03\x04\x1b\x01\x12\
    \x04\xc7\x03\x08\x16\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xc8\x03\x02\x18\n\
    \r\n\x05\x04\x1b\x02\0\x05\x12\x04\xc8\x03\x02\x07\n\r\n\x05\x04\x1b\x02\
    \0\x01\x12\x04\xc8\x03\x08\x13\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xc8\
    \x03\x16\x17\n\x0c\n\x04\x04\x1b\x02\x01\x12\x04\xc9\x03\x02\x1b\n\r\n\
    \x05\x04\x1b\x02\x01\x05\x12\x04\xc9\x03\x02\x07\n\r\n\x05\x04\x1b\x02\
    \x01\x01\x12\x04\xc9\x03\x08\x16\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\
    \xc9\x03\x19\x1a\n\x0c\n\x04\x04\x1b\x02\x02\x12\x04\xca\x03\x02/\n\r\n\
    \x05\x04\x1b\x02\x02\x04\x12\x04\xca\x03\x02\n\n\r\n\x05\x04\x1b\x02\x02\
    \x06\x12\x04\xca\x03\x0b\x1a\n\r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xca\
    \x03\x1b*\n\r\n\x05\x04\x1b\x02\x02\x03\x12\x04\xca\x03-.\n\x0c\n\x02\
    \x04\x1c\x12\x06\xcd\x03\0\xcf\x03\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\
    \xcd\x03\x08\x14\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xce\x03\x02(\n\r\n\
    \x05\x04\x1c\x02\0\x04\x12\x04\xce\x03\x02\n\n\r\n\x05\x04\x1c\x02\0\x06\
    \x12\x04\xce\x03\x0b\x16\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xce\x03\x17\
    #\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xce\x03&'\n\x0c\n\x02\x04\x1d\x12\
    \x06\xd1\x03\0\xd4\x03\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xd1\x03\x08\
    \x17\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xd2\x03\x02\x1e\n\r\n\x05\x04\x1d\
    \x02\0\x06\x12\x04\xd2\x03\x02\r\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xd2\
    \x03\x0e\x19\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xd2\x03\x1c\x1d\n\x0c\n\
    \x04\x04\x1d\x02\x01\x12\x04\xd3\x03\x02\x17\n\r\n\x05\x04\x1d\x02\x01\
    \x05\x12\x04\xd3\x03\x02\x07\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\xd3\
    \x03\x08\x12\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xd3\x03\x15\x16\n\x0c\
    \n\x02\x04\x1e\x12\x06\xd6\x03\0\xe5\x03\x01\n\x0b\n\x03\x04\x1e\x01\x12\
    \x04\xd6\x03\x08\x13\n\x0e\n\x04\x04\x1e\x03\0\x12\x06\xd7\x03\x02\xe2\
    \x03\x03\n\r\n\x05\x04\x1e\x03\0\x01\x12\x04\xd7\x03\n\r\n\x0e\n\x06\x04\
    \x1e\x03\0\x02\0\x12\x04\xd8\x03\x04\x18\n\x0f\n\x07\x04\x1e\x03\0\x02\0\
    \x05\x12\x04\xd8\x03\x04\t\n\x0f\n\x07\x04\x1e\x03\0\x02\0\x01\x12\x04\
    \xd8\x03\n\x13\n\x0f\n\x07\x04\x1e\x03\0\x02\0\x03\x12\x04\xd8\x03\x16\
    \x17\n\x0e\n\x06\x04\x1e\x03\0\x02\x01\x12\x04\xd9\x03\x04\x19\n\x0f\n\
    \x07\x04\x1e\x03\0\x02\x01\x05\x12\x04\xd9\x03\x04\t\n\x0f\n\x07\x04\x1e\
    \x03\0\x02\x01\x01\x12\x04\xd9\x03\n\x14\n\x0f\n\x07\x04\x1e\x03\0\x02\
    \x01\x03\x12\x04\xd9\x03\x17\x18\n\x0e\n\x06\x04\x1e\x03\0\x02\x02\x12\
    \x04\xda\x03\x04\x19\n\x0f\n\x07\x04\x1e\x03\0\x02\x02\x05\x12\x04\xda\
    \x03\x04\t\n\x0f\n\x07\x04\x1e\x03\0\x02\x02\x01\x12\x04\xda\x03\n\x14\n\
    \x0f\n\x07\x04\x1e\x03\0\x02\x02\x03\x12\x04\xda\x03\x17\x18\n7\n\x06\
    \x04\x1e\x03\0\x02\x03\x12\x04\xdd\x03\x04\x15\x1a'bytes\x20nonce\x20=\
    \x205;\nbytes\x20difficulty\x20=\x206;\n\n\x0f\n\x07\x04\x1e\x03\0\x02\
    \x03\x05\x12\x04\xdd\x03\x04\t\n\x0f\n\x07\x04\x1e\x03\0\x02\x03\x01\x12\
    \x04\xdd\x03\n\x10\n\x0f\n\x07\x04\x1e\x03\0\x02\x03\x03\x12\x04\xdd\x03\
    \x13\x14\n\x0e\n\x06\x04\x1e\x03\0\x02\x04\x12\x04\xde\x03\x04\x19\n\x0f\
    \n\x07\x04\x1e\x03\0\x02\x04\x05\x12\x04\xde\x03\x04\t\n\x0f\n\x07\x04\
    \x1e\x03\0\x02\x04\x01\x12\x04\xde\x03\n\x14\n\x0f\n\x07\x04\x1e\x03\0\
    \x02\x04\x03\x12\x04\xde\x03\x17\x18\n\x0e\n\x06\x04\x1e\x03\0\x02\x05\
    \x12\x04\xdf\x03\x04\x1e\n\x0f\n\x07\x04\x1e\x03\0\x02\x05\x05\x12\x04\
    \xdf\x03\x04\t\n\x0f\n\x07\x04\x1e\x03\0\x02\x05\x01\x12\x04\xdf\x03\n\
    \x19\n\x0f\n\x07\x04\x1e\x03\0\x02\x05\x03\x12\x04\xdf\x03\x1c\x1d\n\x0e\
    \n\x06\x04\x1e\x03\0\x02\x06\x12\x04\xe0\x03\x04\x17\n\x0f\n\x07\x04\x1e\
    \x03\0\x02\x06\x05\x12\x04\xe0\x03\x04\t\n\x0f\n\x07\x04\x1e\x03\0\x02\
    \x06\x01\x12\x04\xe0\x03\n\x11\n\x0f\n\x07\x04\x1e\x03\0\x02\x06\x03\x12\
    \x04\xe0\x03\x14\x16\n\x0e\n\x06\x04\x1e\x03\0\x02\x07\x12\x04\xe1\x03\
    \x04\x20\n\x0f\n\x07\x04\x1e\x03\0\x02\x07\x05\x12\x04\xe1\x03\x04\t\n\
    \x0f\n\x07\x04\x1e\x03\0\x02\x07\x01\x12\x04\xe1\x03\n\x1a\n\x0f\n\x07\
    \x04\x1e\x03\0\x02\x07\x03\x12\x04\xe1\x03\x1d\x1f\n\x0c\n\x04\x04\x1e\
    \x02\0\x12\x04\xe3\x03\x02\x13\n\r\n\x05\x04\x1e\x02\0\x06\x12\x04\xe3\
    \x03\x02\x05\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xe3\x03\x06\x0e\n\r\n\
    \x05\x04\x1e\x02\0\x03\x12\x04\xe3\x03\x11\x12\n\x0c\n\x04\x04\x1e\x02\
    \x01\x12\x04\xe4\x03\x02\x1e\n\r\n\x05\x04\x1e\x02\x01\x05\x12\x04\xe4\
    \x03\x02\x07\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xe4\x03\x08\x19\n\r\n\
    \x05\x04\x1e\x02\x01\x03\x12\x04\xe4\x03\x1c\x1d\n\x15\n\x02\x04\x1f\x12\
    \x06\xe8\x03\0\xeb\x03\x01\x1a\x07\x20block\n\n\x0b\n\x03\x04\x1f\x01\
    \x12\x04\xe8\x03\x08\r\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\xe9\x03\x02(\n\
    \r\n\x05\x04\x1f\x02\0\x04\x12\x04\xe9\x03\x02\n\n\r\n\x05\x04\x1f\x02\0\
    \x06\x12\x04\xe9\x03\x0b\x16\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\xe9\x03\
    \x17#\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\xe9\x03&'\n\x0c\n\x04\x04\x1f\
    \x02\x01\x12\x04\xea\x03\x02\x1f\n\r\n\x05\x04\x1f\x02\x01\x06\x12\x04\
    \xea\x03\x02\r\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\xea\x03\x0e\x1a\n\r\
    \n\x05\x04\x1f\x02\x01\x03\x12\x04\xea\x03\x1d\x1e\n\x0c\n\x02\x04\x20\
    \x12\x06\xed\x03\0\xf4\x03\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\xed\x03\
    \x08\x16\n\x0e\n\x04\x04\x20\x03\0\x12\x06\xee\x03\x02\xf1\x03\x03\n\r\n\
    \x05\x04\x20\x03\0\x01\x12\x04\xee\x03\n\x11\n\x0e\n\x06\x04\x20\x03\0\
    \x02\0\x12\x04\xef\x03\x04\x13\n\x0f\n\x07\x04\x20\x03\0\x02\0\x05\x12\
    \x04\xef\x03\x04\t\n\x0f\n\x07\x04\x20\x03\0\x02\0\x01\x12\x04\xef\x03\n\
    \x0e\n\x0f\n\x07\x04\x20\x03\0\x02\0\x03\x12\x04\xef\x03\x11\x12\n\x0e\n\
    \x06\x04\x20\x03\0\x02\x01\x12\x04\xf0\x03\x04\x15\n\x0f\n\x07\x04\x20\
    \x03\0\x02\x01\x05\x12\x04\xf0\x03\x04\t\n\x0f\n\x07\x04\x20\x03\0\x02\
    \x01\x01\x12\x04\xf0\x03\n\x10\n\x0f\n\x07\x04\x20\x03\0\x02\x01\x03\x12\
    \x04\xf0\x03\x13\x14\n\x0c\n\x04\x04\x20\x02\0\x12\x04\xf2\x03\x02\x1b\n\
    \r\n\x05\x04\x20\x02\0\x04\x12\x04\xf2\x03\x02\n\n\r\n\x05\x04\x20\x02\0\
    \x06\x12\x04\xf2\x03\x0b\x12\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xf2\x03\
    \x13\x16\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\xf2\x03\x19\x1a\n\x0c\n\x04\
    \x04\x20\x02\x01\x12\x04\xf3\x03\x02\x17\n\r\n\x05\x04\x20\x02\x01\x05\
    \x12\x04\xf3\x03\x02\x07\n\r\n\x05\x04\x20\x02\x01\x01\x12\x04\xf3\x03\
    \x08\x12\n\r\n\x05\x04\x20\x02\x01\x03\x12\x04\xf3\x03\x15\x16\n\x19\n\
    \x02\x04!\x12\x06\xf7\x03\0\x84\x04\x01\x1a\x0b\x20Inventory\n\n\x0b\n\
    \x03\x04!\x01\x12\x04\xf7\x03\x08\x16\n\x0e\n\x04\x04!\x04\0\x12\x06\xf8\
    \x03\x02\xfc\x03\x03\n\r\n\x05\x04!\x04\0\x01\x12\x04\xf8\x03\x07\x0b\n\
    \x0e\n\x06\x04!\x04\0\x02\0\x12\x04\xf9\x03\x04\r\n\x0f\n\x07\x04!\x04\0\
    \x02\0\x01\x12\x04\xf9\x03\x04\x08\n\x0f\n\x07\x04!\x04\0\x02\0\x02\x12\
    \x04\xf9\x03\x0b\x0c\n\x0e\n\x06\x04!\x04\0\x02\x01\x12\x04\xfa\x03\x04\
    \x10\n\x0f\n\x07\x04!\x04\0\x02\x01\x01\x12\x04\xfa\x03\x04\x0b\n\x0f\n\
    \x07\x04!\x04\0\x02\x01\x02\x12\x04\xfa\x03\x0e\x0f\n\x0e\n\x06\x04!\x04\
    \0\x02\x02\x12\x04\xfb\x03\x04\x0e\n\x0f\n\x07\x04!\x04\0\x02\x02\x01\
    \x12\x04\xfb\x03\x04\t\n\x0f\n\x07\x04!\x04\0\x02\x02\x02\x12\x04\xfb\
    \x03\x0c\r\n\x0e\n\x04\x04!\x03\0\x12\x06\xfe\x03\x02\x81\x04\x03\n\r\n\
    \x05\x04!\x03\0\x01\x12\x04\xfe\x03\n\x11\n\x0e\n\x06\x04!\x03\0\x02\0\
    \x12\x04\xff\x03\x04\x13\n\x0f\n\x07\x04!\x03\0\x02\0\x05\x12\x04\xff\
    \x03\x04\t\n\x0f\n\x07\x04!\x03\0\x02\0\x01\x12\x04\xff\x03\n\x0e\n\x0f\
    \n\x07\x04!\x03\0\x02\0\x03\x12\x04\xff\x03\x11\x12\n\x0e\n\x06\x04!\x03\
    \0\x02\x01\x12\x04\x80\x04\x04\x15\n\x0f\n\x07\x04!\x03\0\x02\x01\x05\
    \x12\x04\x80\x04\x04\t\n\x0f\n\x07\x04!\x03\0\x02\x01\x01\x12\x04\x80\
    \x04\n\x10\n\x0f\n\x07\x04!\x03\0\x02\x01\x03\x12\x04\x80\x04\x13\x14\n\
    \x0c\n\x04\x04!\x02\0\x12\x04\x82\x04\x02\x1b\n\r\n\x05\x04!\x02\0\x04\
    \x12\x04\x82\x04\x02\n\n\r\n\x05\x04!\x02\0\x06\x12\x04\x82\x04\x0b\x12\
    \n\r\n\x05\x04!\x02\0\x01\x12\x04\x82\x04\x13\x16\n\r\n\x05\x04!\x02\0\
    \x03\x12\x04\x82\x04\x19\x1a\n\x0c\n\x04\x04!\x02\x01\x12\x04\x83\x04\
    \x02\x10\n\r\n\x05\x04!\x02\x01\x06\x12\x04\x83\x04\x02\x06\n\r\n\x05\
    \x04!\x02\x01\x01\x12\x04\x83\x04\x07\x0b\n\r\n\x05\x04!\x02\x01\x03\x12\
    \x04\x83\x04\x0e\x0f\n\x0c\n\x02\x04\"\x12\x06\x86\x04\0\x8d\x04\x01\n\
    \x0b\n\x03\x04\"\x01\x12\x04\x86\x04\x08\x11\n\x0e\n\x04\x04\"\x04\0\x12\
    \x06\x87\x04\x02\x8a\x04\x03\n\r\n\x05\x04\"\x04\0\x01\x12\x04\x87\x04\
    \x07\x14\n\x0e\n\x06\x04\"\x04\0\x02\0\x12\x04\x88\x04\x04\x0c\n\x0f\n\
    \x07\x04\"\x04\0\x02\0\x01\x12\x04\x88\x04\x04\x07\n\x0f\n\x07\x04\"\x04\
    \0\x02\0\x02\x12\x04\x88\x04\n\x0b\n\x0e\n\x06\x04\"\x04\0\x02\x01\x12\
    \x04\x89\x04\x04\x0e\n\x0f\n\x07\x04\"\x04\0\x02\x01\x01\x12\x04\x89\x04\
    \x04\t\n\x0f\n\x07\x04\"\x04\0\x02\x01\x02\x12\x04\x89\x04\x0c\r\n\x0c\n\
    \x04\x04\"\x02\0\x12\x04\x8b\x04\x02\x19\n\r\n\x05\x04\"\x02\0\x06\x12\
    \x04\x8b\x04\x02\x0f\n\r\n\x05\x04\"\x02\0\x01\x12\x04\x8b\x04\x10\x14\n\
    \r\n\x05\x04\"\x02\0\x03\x12\x04\x8b\x04\x17\x18\n\x0c\n\x04\x04\"\x02\
    \x01\x12\x04\x8c\x04\x02\x19\n\r\n\x05\x04\"\x02\x01\x04\x12\x04\x8c\x04\
    \x02\n\n\r\n\x05\x04\"\x02\x01\x05\x12\x04\x8c\x04\x0b\x10\n\r\n\x05\x04\
    \"\x02\x01\x01\x12\x04\x8c\x04\x11\x14\n\r\n\x05\x04\"\x02\x01\x03\x12\
    \x04\x8c\x04\x17\x18\n\x0c\n\x02\x04#\x12\x06\x8f\x04\0\x9b\x04\x01\n\
    \x0b\n\x03\x04#\x01\x12\x04\x8f\x04\x08\r\n\x0e\n\x04\x04#\x04\0\x12\x06\
    \x90\x04\x02\x95\x04\x03\n\r\n\x05\x04#\x04\0\x01\x12\x04\x90\x04\x07\
    \x0f\n\x0e\n\x06\x04#\x04\0\x02\0\x12\x04\x91\x04\x04\x0c\n\x0f\n\x07\
    \x04#\x04\0\x02\0\x01\x12\x04\x91\x04\x04\x07\n\x0f\n\x07\x04#\x04\0\x02\
    \0\x02\x12\x04\x91\x04\n\x0b\n\x0e\n\x06\x04#\x04\0\x02\x01\x12\x04\x92\
    \x04\x04\x0c\n\x0f\n\x07\x04#\x04\0\x02\x01\x01\x12\x04\x92\x04\x04\x07\
    \n\x0f\n\x07\x04#\x04\0\x02\x01\x02\x12\x04\x92\x04\n\x0b\n\x0e\n\x06\
    \x04#\x04\0\x02\x02\x12\x04\x93\x04\x04\x0e\n\x0f\n\x07\x04#\x04\0\x02\
    \x02\x01\x12\x04\x93\x04\x04\t\n\x0f\n\x07\x04#\x04\0\x02\x02\x02\x12\
    \x04\x93\x04\x0c\r\n\x0e\n\x06\x04#\x04\0\x02\x03\x12\x04\x94\x04\x04\
    \x14\n\x0f\n\x07\x04#\x04\0\x02\x03\x01\x12\x04\x94\x04\x04\x0f\n\x0f\n\
    \x07\x04#\x04\0\x02\x03\x02\x12\x04\x94\x04\x12\x13\n\x0c\n\x04\x04#\x02\
    \0\x12\x04\x97\x04\x02\x14\n\r\n\x05\x04#\x02\0\x06\x12\x04\x97\x04\x02\
    \n\n\r\n\x05\x04#\x02\0\x01\x12\x04\x97\x04\x0b\x0f\n\r\n\x05\x04#\x02\0\
    \x03\x12\x04\x97\x04\x12\x13\n\x0c\n\x04\x04#\x02\x01\x12\x04\x98\x04\
    \x02\x1c\n\r\n\x05\x04#\x02\x01\x04\x12\x04\x98\x04\x02\n\n\r\n\x05\x04#\
    \x02\x01\x06\x12\x04\x98\x04\x0b\x10\n\r\n\x05\x04#\x02\x01\x01\x12\x04\
    \x98\x04\x11\x17\n\r\n\x05\x04#\x02\x01\x03\x12\x04\x98\x04\x1a\x1b\n\
    \x0c\n\x04\x04#\x02\x02\x12\x04\x99\x04\x02)\n\r\n\x05\x04#\x02\x02\x04\
    \x12\x04\x99\x04\x02\n\n\r\n\x05\x04#\x02\x02\x06\x12\x04\x99\x04\x0b\
    \x16\n\r\n\x05\x04#\x02\x02\x01\x12\x04\x99\x04\x17$\n\r\n\x05\x04#\x02\
    \x02\x03\x12\x04\x99\x04'(\n\x0c\n\x04\x04#\x02\x03\x12\x04\x9a\x04\x02(\
    \n\r\n\x05\x04#\x02\x03\x04\x12\x04\x9a\x04\x02\n\n\r\n\x05\x04#\x02\x03\
    \x06\x12\x04\x9a\x04\x0b\x16\n\r\n\x05\x04#\x02\x03\x01\x12\x04\x9a\x04\
    \x17#\n\r\n\x05\x04#\x02\x03\x03\x12\x04\x9a\x04&'\n!\n\x02\x04$\x12\x06\
    \x9e\x04\0\xa0\x04\x01\x1a\x13\x20DynamicProperties\n\n\x0b\n\x03\x04$\
    \x01\x12\x04\x9e\x04\x08\x19\n\x0c\n\x04\x04$\x02\0\x12\x04\x9f\x04\x02$\
    \n\r\n\x05\x04$\x02\0\x05\x12\x04\x9f\x04\x02\x07\n\r\n\x05\x04$\x02\0\
    \x01\x12\x04\x9f\x04\x08\x1f\n\r\n\x05\x04$\x02\0\x03\x12\x04\x9f\x04\"#\
    \n\x0c\n\x02\x05\x01\x12\x06\xa2\x04\0\xbc\x04\x01\n\x0b\n\x03\x05\x01\
    \x01\x12\x04\xa2\x04\x05\x0f\n\x0c\n\x04\x05\x01\x02\0\x12\x04\xa3\x04\
    \x02\x13\n\r\n\x05\x05\x01\x02\0\x01\x12\x04\xa3\x04\x02\x0b\n\r\n\x05\
    \x05\x01\x02\0\x02\x12\x04\xa3\x04\x0e\x12\n\x0c\n\x04\x05\x01\x02\x01\
    \x12\x04\xa4\x04\x02\x16\n\r\n\x05\x05\x01\x02\x01\x01\x12\x04\xa4\x04\
    \x02\x0e\n\r\n\x05\x05\x01\x02\x01\x02\x12\x04\xa4\x04\x11\x15\n\x0c\n\
    \x04\x05\x01\x02\x02\x12\x04\xa5\x04\x02\x18\n\r\n\x05\x05\x01\x02\x02\
    \x01\x12\x04\xa5\x04\x02\x10\n\r\n\x05\x05\x01\x02\x02\x02\x12\x04\xa5\
    \x04\x13\x17\n\x0c\n\x04\x05\x01\x02\x03\x12\x04\xa6\x04\x02\x18\n\r\n\
    \x05\x05\x01\x02\x03\x01\x12\x04\xa6\x04\x02\x10\n\r\n\x05\x05\x01\x02\
    \x03\x02\x12\x04\xa6\x04\x13\x17\n\x0c\n\x04\x05\x01\x02\x04\x12\x04\xa7\
    \x04\x02\x1f\n\r\n\x05\x05\x01\x02\x04\x01\x12\x04\xa7\x04\x02\x17\n\r\n\
    \x05\x05\x01\x02\x04\x02\x12\x04\xa7\x04\x1a\x1e\n\x0c\n\x04\x05\x01\x02\
    \x05\x12\x04\xa8\x04\x02\x17\n\r\n\x05\x05\x01\x02\x05\x01\x12\x04\xa8\
    \x04\x02\x0f\n\r\n\x05\x05\x01\x02\x05\x02\x12\x04\xa8\x04\x12\x16\n\x0c\
    \n\x04\x05\x01\x02\x06\x12\x04\xa9\x04\x02\x16\n\r\n\x05\x05\x01\x02\x06\
    \x01\x12\x04\xa9\x04\x02\x0e\n\r\n\x05\x05\x01\x02\x06\x02\x12\x04\xa9\
    \x04\x11\x15\n\x0c\n\x04\x05\x01\x02\x07\x12\x04\xaa\x04\x02\x1d\n\r\n\
    \x05\x05\x01\x02\x07\x01\x12\x04\xaa\x04\x02\x15\n\r\n\x05\x05\x01\x02\
    \x07\x02\x12\x04\xaa\x04\x18\x1c\n\x0c\n\x04\x05\x01\x02\x08\x12\x04\xab\
    \x04\x02\x18\n\r\n\x05\x05\x01\x02\x08\x01\x12\x04\xab\x04\x02\x10\n\r\n\
    \x05\x05\x01\x02\x08\x02\x12\x04\xab\x04\x13\x17\n\x0c\n\x04\x05\x01\x02\
    \t\x12\x04\xac\x04\x02\x16\n\r\n\x05\x05\x01\x02\t\x01\x12\x04\xac\x04\
    \x02\x0e\n\r\n\x05\x05\x01\x02\t\x02\x12\x04\xac\x04\x11\x15\n\x0c\n\x04\
    \x05\x01\x02\n\x12\x04\xad\x04\x02\x15\n\r\n\x05\x05\x01\x02\n\x01\x12\
    \x04\xad\x04\x02\r\n\r\n\x05\x05\x01\x02\n\x02\x12\x04\xad\x04\x10\x14\n\
    \x0c\n\x04\x05\x01\x02\x0b\x12\x04\xae\x04\x02\x0f\n\r\n\x05\x05\x01\x02\
    \x0b\x01\x12\x04\xae\x04\x02\x07\n\r\n\x05\x05\x01\x02\x0b\x02\x12\x04\
    \xae\x04\n\x0e\n\x0c\n\x04\x05\x01\x02\x0c\x12\x04\xaf\x04\x02\x13\n\r\n\
    \x05\x05\x01\x02\x0c\x01\x12\x04\xaf\x04\x02\x0b\n\r\n\x05\x05\x01\x02\
    \x0c\x02\x12\x04\xaf\x04\x0e\x12\n\x0c\n\x04\x05\x01\x02\r\x12\x04\xb0\
    \x04\x02\x14\n\r\n\x05\x05\x01\x02\r\x01\x12\x04\xb0\x04\x02\x0c\n\r\n\
    \x05\x05\x01\x02\r\x02\x12\x04\xb0\x04\x0f\x13\n\x0c\n\x04\x05\x01\x02\
    \x0e\x12\x04\xb1\x04\x02\x10\n\r\n\x05\x05\x01\x02\x0e\x01\x12\x04\xb1\
    \x04\x02\x08\n\r\n\x05\x05\x01\x02\x0e\x02\x12\x04\xb1\x04\x0b\x0f\n\x0c\
    \n\x04\x05\x01\x02\x0f\x12\x04\xb2\x04\x02\x13\n\r\n\x05\x05\x01\x02\x0f\
    \x01\x12\x04\xb2\x04\x02\x0b\n\r\n\x05\x05\x01\x02\x0f\x02\x12\x04\xb2\
    \x04\x0e\x12\n\x0c\n\x04\x05\x01\x02\x10\x12\x04\xb3\x04\x02\x10\n\r\n\
    \x05\x05\x01\x02\x10\x01\x12\x04\xb3\x04\x02\x08\n\r\n\x05\x05\x01\x02\
    \x10\x02\x12\x04\xb3\x04\x0b\x0f\n\x0c\n\x04\x05\x01\x02\x11\x12\x04\xb4\
    \x04\x02\x14\n\r\n\x05\x05\x01\x02\x11\x01\x12\x04\xb4\x04\x02\x0c\n\r\n\
    \x05\x05\x01\x02\x11\x02\x12\x04\xb4\x04\x0f\x13\n\x0c\n\x04\x05\x01\x02\
    \x12\x12\x04\xb5\x04\x02\x1e\n\r\n\x05\x05\x01\x02\x12\x01\x12\x04\xb5\
    \x04\x02\x16\n\r\n\x05\x05\x01\x02\x12\x02\x12\x04\xb5\x04\x19\x1d\n\x0c\
    \n\x04\x05\x01\x02\x13\x12\x04\xb6\x04\x02\x1c\n\r\n\x05\x05\x01\x02\x13\
    \x01\x12\x04\xb6\x04\x02\x14\n\r\n\x05\x05\x01\x02\x13\x02\x12\x04\xb6\
    \x04\x17\x1b\n\x0c\n\x04\x05\x01\x02\x14\x12\x04\xb7\x04\x02\x12\n\r\n\
    \x05\x05\x01\x02\x14\x01\x12\x04\xb7\x04\x02\n\n\r\n\x05\x05\x01\x02\x14\
    \x02\x12\x04\xb7\x04\r\x11\n\x0c\n\x04\x05\x01\x02\x15\x12\x04\xb8\x04\
    \x02\x16\n\r\n\x05\x05\x01\x02\x15\x01\x12\x04\xb8\x04\x02\x0e\n\r\n\x05\
    \x05\x01\x02\x15\x02\x12\x04\xb8\x04\x11\x15\n\x0c\n\x04\x05\x01\x02\x16\
    \x12\x04\xb9\x04\x02%\n\r\n\x05\x05\x01\x02\x16\x01\x12\x04\xb9\x04\x02\
    \x1d\n\r\n\x05\x05\x01\x02\x16\x02\x12\x04\xb9\x04\x20$\n\x0c\n\x04\x05\
    \x01\x02\x17\x12\x04\xba\x04\x02\x1e\n\r\n\x05\x05\x01\x02\x17\x01\x12\
    \x04\xba\x04\x02\x16\n\r\n\x05\x05\x01\x02\x17\x02\x12\x04\xba\x04\x19\
    \x1d\n\x0c\n\x04\x05\x01\x02\x18\x12\x04\xbb\x04\x02\x11\n\r\n\x05\x05\
    \x01\x02\x18\x01\x12\x04\xbb\x04\x02\t\n\r\n\x05\x05\x01\x02\x18\x02\x12\
    \x04\xbb\x04\x0c\x10\n\x0c\n\x02\x04%\x12\x06\xbe\x04\0\xc0\x04\x01\n\
    \x0b\n\x03\x04%\x01\x12\x04\xbe\x04\x08\x19\n\x0c\n\x04\x04%\x02\0\x12\
    \x04\xbf\x04\x02\x18\n\r\n\x05\x04%\x02\0\x06\x12\x04\xbf\x04\x02\x0c\n\
    \r\n\x05\x04%\x02\0\x01\x12\x04\xbf\x04\r\x13\n\r\n\x05\x04%\x02\0\x03\
    \x12\x04\xbf\x04\x16\x17\n\x0c\n\x02\x04&\x12\x06\xc2\x04\0\xd2\x04\x01\
    \n\x0b\n\x03\x04&\x01\x12\x04\xc2\x04\x08\x14\n\x0e\n\x04\x04&\x03\0\x12\
    \x06\xc3\x04\x02\xc6\x04\x03\n\r\n\x05\x04&\x03\0\x01\x12\x04\xc3\x04\n\
    \x11\n\x0e\n\x06\x04&\x03\0\x02\0\x12\x04\xc4\x04\x04\x13\n\x0f\n\x07\
    \x04&\x03\0\x02\0\x05\x12\x04\xc4\x04\x04\t\n\x0f\n\x07\x04&\x03\0\x02\0\
    \x01\x12\x04\xc4\x04\n\x0e\n\x0f\n\x07\x04&\x03\0\x02\0\x03\x12\x04\xc4\
    \x04\x11\x12\n\x0e\n\x06\x04&\x03\0\x02\x01\x12\x04\xc5\x04\x04\x15\n\
    \x0f\n\x07\x04&\x03\0\x02\x01\x05\x12\x04\xc5\x04\x04\t\n\x0f\n\x07\x04&\
    \x03\0\x02\x01\x01\x12\x04\xc5\x04\n\x10\n\x0f\n\x07\x04&\x03\0\x02\x01\
    \x03\x12\x04\xc5\x04\x13\x14\n\x0c\n\x04\x04&\x02\0\x12\x04\xc8\x04\x02\
    \x14\n\r\n\x05\x04&\x02\0\x06\x12\x04\xc8\x04\x02\n\n\r\n\x05\x04&\x02\0\
    \x01\x12\x04\xc8\x04\x0b\x0f\n\r\n\x05\x04&\x02\0\x03\x12\x04\xc8\x04\
    \x12\x13\n\x0c\n\x04\x04&\x02\x01\x12\x04\xc9\x04\x02\x14\n\r\n\x05\x04&\
    \x02\x01\x05\x12\x04\xc9\x04\x02\x07\n\r\n\x05\x04&\x02\x01\x01\x12\x04\
    \xc9\x04\x08\x0f\n\r\n\x05\x04&\x02\x01\x03\x12\x04\xc9\x04\x12\x13\n\
    \x0c\n\x04\x04&\x02\x02\x12\x04\xca\x04\x02\x16\n\r\n\x05\x04&\x02\x02\
    \x05\x12\x04\xca\x04\x02\x07\n\r\n\x05\x04&\x02\x02\x01\x12\x04\xca\x04\
    \x08\x11\n\r\n\x05\x04&\x02\x02\x03\x12\x04\xca\x04\x14\x15\n\x0c\n\x04\
    \x04&\x02\x03\x12\x04\xcb\x04\x02\x1d\n\r\n\x05\x04&\x02\x03\x06\x12\x04\
    \xcb\x04\x02\t\n\r\n\x05\x04&\x02\x03\x01\x12\x04\xcb\x04\n\x18\n\r\n\
    \x05\x04&\x02\x03\x03\x12\x04\xcb\x04\x1b\x1c\n\x0c\n\x04\x04&\x02\x04\
    \x12\x04\xcc\x04\x02\x1b\n\r\n\x05\x04&\x02\x04\x06\x12\x04\xcc\x04\x02\
    \t\n\r\n\x05\x04&\x02\x04\x01\x12\x04\xcc\x04\n\x16\n\r\n\x05\x04&\x02\
    \x04\x03\x12\x04\xcc\x04\x19\x1a\n\x0c\n\x04\x04&\x02\x05\x12\x04\xcd\
    \x04\x02\x1a\n\r\n\x05\x04&\x02\x05\x06\x12\x04\xcd\x04\x02\t\n\r\n\x05\
    \x04&\x02\x05\x01\x12\x04\xcd\x04\n\x15\n\r\n\x05\x04&\x02\x05\x03\x12\
    \x04\xcd\x04\x18\x19\n\x0c\n\x04\x04&\x02\x06\x12\x04\xce\x04\x02\x14\n\
    \r\n\x05\x04&\x02\x06\x05\x12\x04\xce\x04\x02\x07\n\r\n\x05\x04&\x02\x06\
    \x01\x12\x04\xce\x04\x08\x0f\n\r\n\x05\x04&\x02\x06\x03\x12\x04\xce\x04\
    \x12\x13\n\x0c\n\x04\x04&\x02\x07\x12\x04\xcf\x04\x02\x16\n\r\n\x05\x04&\
    \x02\x07\x05\x12\x04\xcf\x04\x02\x07\n\r\n\x05\x04&\x02\x07\x01\x12\x04\
    \xcf\x04\x08\x11\n\r\n\x05\x04&\x02\x07\x03\x12\x04\xcf\x04\x14\x15\n\
    \x0c\n\x04\x04&\x02\x08\x12\x04\xd0\x04\x02\x15\n\r\n\x05\x04&\x02\x08\
    \x05\x12\x04\xd0\x04\x02\x07\n\r\n\x05\x04&\x02\x08\x01\x12\x04\xd0\x04\
    \x08\x10\n\r\n\x05\x04&\x02\x08\x03\x12\x04\xd0\x04\x13\x14\n\x0c\n\x04\
    \x04&\x02\t\x12\x04\xd1\x04\x02\x1c\n\r\n\x05\x04&\x02\t\x05\x12\x04\xd1\
    \x04\x02\x07\n\r\n\x05\x04&\x02\t\x01\x12\x04\xd1\x04\x08\x16\n\r\n\x05\
    \x04&\x02\t\x03\x12\x04\xd1\x04\x19\x1b\n\x0c\n\x02\x04'\x12\x06\xd4\x04\
    \0\xe6\x04\x01\n\x0b\n\x03\x04'\x01\x12\x04\xd4\x04\x08\x1b\nv\n\x04\x04\
    '\x02\0\x12\x04\xd7\x04\x02\x11\x1ah\x20internalTransaction\x20identity,\
    \x20the\x20root\x20InternalTransaction\x20hash\n\x20should\x20equals\x20\
    to\x20root\x20transaction\x20id.\n\n\r\n\x05\x04'\x02\0\x05\x12\x04\xd7\
    \x04\x02\x07\n\r\n\x05\x04'\x02\0\x01\x12\x04\xd7\x04\x08\x0c\n\r\n\x05\
    \x04'\x02\0\x03\x12\x04\xd7\x04\x0f\x10\n=\n\x04\x04'\x02\x01\x12\x04\
    \xd9\x04\x02\x1b\x1a/\x20the\x20one\x20send\x20trx\x20(TBD:\x20or\x20tok\
    en)\x20via\x20function\n\n\r\n\x05\x04'\x02\x01\x05\x12\x04\xd9\x04\x02\
    \x07\n\r\n\x05\x04'\x02\x01\x01\x12\x04\xd9\x04\x08\x16\n\r\n\x05\x04'\
    \x02\x01\x03\x12\x04\xd9\x04\x19\x1a\n@\n\x04\x04'\x02\x02\x12\x04\xdb\
    \x04\x02\x1f\x1a2\x20the\x20one\x20recieve\x20trx\x20(TBD:\x20or\x20toke\
    n)\x20via\x20function\n\n\r\n\x05\x04'\x02\x02\x05\x12\x04\xdb\x04\x02\
    \x07\n\r\n\x05\x04'\x02\x02\x01\x12\x04\xdb\x04\x08\x1a\n\r\n\x05\x04'\
    \x02\x02\x03\x12\x04\xdb\x04\x1d\x1e\n\x0e\n\x04\x04'\x03\0\x12\x06\xdc\
    \x04\x02\xe1\x04\x03\n\r\n\x05\x04'\x03\0\x01\x12\x04\xdc\x04\n\x17\n+\n\
    \x06\x04'\x03\0\x02\0\x12\x04\xde\x04\x04\x18\x1a\x1b\x20trx\x20(TBD:\
    \x20or\x20token)\x20value\n\n\x0f\n\x07\x04'\x03\0\x02\0\x05\x12\x04\xde\
    \x04\x04\t\n\x0f\n\x07\x04'\x03\0\x02\0\x01\x12\x04\xde\x04\n\x13\n\x0f\
    \n\x07\x04'\x03\0\x02\0\x03\x12\x04\xde\x04\x16\x17\n5\n\x06\x04'\x03\0\
    \x02\x01\x12\x04\xe0\x04\x04\x17\x1a%\x20TBD:\x20tokenName,\x20trx\x20sh\
    ould\x20be\x20empty\n\n\x0f\n\x07\x04'\x03\0\x02\x01\x05\x12\x04\xe0\x04\
    \x04\n\n\x0f\n\x07\x04'\x03\0\x02\x01\x01\x12\x04\xe0\x04\x0b\x12\n\x0f\
    \n\x07\x04'\x03\0\x02\x01\x03\x12\x04\xe0\x04\x15\x16\n\x0c\n\x04\x04'\
    \x02\x03\x12\x04\xe2\x04\x02+\n\r\n\x05\x04'\x02\x03\x04\x12\x04\xe2\x04\
    \x02\n\n\r\n\x05\x04'\x02\x03\x06\x12\x04\xe2\x04\x0b\x18\n\r\n\x05\x04'\
    \x02\x03\x01\x12\x04\xe2\x04\x19&\n\r\n\x05\x04'\x02\x03\x03\x12\x04\xe2\
    \x04)*\n\x0c\n\x04\x04'\x02\x04\x12\x04\xe3\x04\x02\x11\n\r\n\x05\x04'\
    \x02\x04\x05\x12\x04\xe3\x04\x02\x07\n\r\n\x05\x04'\x02\x04\x01\x12\x04\
    \xe3\x04\x08\x0c\n\r\n\x05\x04'\x02\x04\x03\x12\x04\xe3\x04\x0f\x10\n\
    \x0c\n\x04\x04'\x02\x05\x12\x04\xe4\x04\x02\x14\n\r\n\x05\x04'\x02\x05\
    \x05\x12\x04\xe4\x04\x02\x06\n\r\n\x05\x04'\x02\x05\x01\x12\x04\xe4\x04\
    \x07\x0f\n\r\n\x05\x04'\x02\x05\x03\x12\x04\xe4\x04\x12\x13\n\x0c\n\x04\
    \x04'\x02\x06\x12\x04\xe5\x04\x02\x13\n\r\n\x05\x04'\x02\x06\x05\x12\x04\
    \xe5\x04\x02\x08\n\r\n\x05\x04'\x02\x06\x01\x12\x04\xe5\x04\t\x0e\n\r\n\
    \x05\x04'\x02\x06\x03\x12\x04\xe5\x04\x11\x12\n\x0c\n\x02\x04(\x12\x06\
    \xe8\x04\0\xec\x04\x01\n\x0b\n\x03\x04(\x01\x12\x04\xe8\x04\x08%\n\x0c\n\
    \x04\x04(\x02\0\x12\x04\xe9\x04\x02\x14\n\r\n\x05\x04(\x02\0\x05\x12\x04\
    \xe9\x04\x02\x07\n\r\n\x05\x04(\x02\0\x01\x12\x04\xe9\x04\x08\x0f\n\r\n\
    \x05\x04(\x02\0\x03\x12\x04\xe9\x04\x12\x13\n\x0c\n\x04\x04(\x02\x01\x12\
    \x04\xea\x04\x02\"\n\r\n\x05\x04(\x02\x01\x04\x12\x04\xea\x04\x02\n\n\r\
    \n\x05\x04(\x02\x01\x05\x12\x04\xea\x04\x0b\x10\n\r\n\x05\x04(\x02\x01\
    \x01\x12\x04\xea\x04\x11\x1d\n\r\n\x05\x04(\x02\x01\x03\x12\x04\xea\x04\
    \x20!\n\x0c\n\x04\x04(\x02\x02\x12\x04\xeb\x04\x02\x20\n\r\n\x05\x04(\
    \x02\x02\x04\x12\x04\xeb\x04\x02\n\n\r\n\x05\x04(\x02\x02\x05\x12\x04\
    \xeb\x04\x0b\x10\n\r\n\x05\x04(\x02\x02\x01\x12\x04\xeb\x04\x11\x1b\n\r\
    \n\x05\x04(\x02\x02\x03\x12\x04\xeb\x04\x1e\x1f\n\x0c\n\x02\x04)\x12\x06\
    \xee\x04\0\xcf\x05\x01\n\x0b\n\x03\x04)\x01\x12\x04\xee\x04\x08\x10\n\
    \x0c\n\x04\x04)\x02\0\x12\x04\xef\x04\x02\x19\n\r\n\x05\x04)\x02\0\x05\
    \x12\x04\xef\x04\x02\x07\n\r\n\x05\x04)\x02\0\x01\x12\x04\xef\x04\x08\
    \x14\n\r\n\x05\x04)\x02\0\x03\x12\x04\xef\x04\x17\x18\n\x0c\n\x04\x04)\
    \x02\x01\x12\x04\xf0\x04\x02\x13\n\r\n\x05\x04)\x02\x01\x05\x12\x04\xf0\
    \x04\x02\x08\n\r\n\x05\x04)\x02\x01\x01\x12\x04\xf0\x04\t\x0e\n\r\n\x05\
    \x04)\x02\x01\x03\x12\x04\xf0\x04\x11\x12\n\x0c\n\x04\x04)\x02\x02\x12\
    \x04\xf1\x04\x02\x1b\n\r\n\x05\x04)\x02\x02\x05\x12\x04\xf1\x04\x02\x08\
    \n\r\n\x05\x04)\x02\x02\x01\x12\x04\xf1\x04\t\x16\n\r\n\x05\x04)\x02\x02\
    \x03\x12\x04\xf1\x04\x19\x1a\n\"\n\x04\x04)\x02\x03\x12\x04\xf3\x04\x02\
    \x20\x1a\x14connect\x20information\n\n\r\n\x05\x04)\x02\x03\x05\x12\x04\
    \xf3\x04\x02\x07\n\r\n\x05\x04)\x02\x03\x01\x12\x04\xf3\x04\x08\x1b\n\r\
    \n\x05\x04)\x02\x03\x03\x12\x04\xf3\x04\x1e\x1f\n\x0c\n\x04\x04)\x02\x04\
    \x12\x04\xf4\x04\x02\x1f\n\r\n\x05\x04)\x02\x04\x05\x12\x04\xf4\x04\x02\
    \x07\n\r\n\x05\x04)\x02\x04\x01\x12\x04\xf4\x04\x08\x1a\n\r\n\x05\x04)\
    \x02\x04\x03\x12\x04\xf4\x04\x1d\x1e\n\x0c\n\x04\x04)\x02\x05\x12\x04\
    \xf5\x04\x02\x20\n\r\n\x05\x04)\x02\x05\x05\x12\x04\xf5\x04\x02\x07\n\r\
    \n\x05\x04)\x02\x05\x01\x12\x04\xf5\x04\x08\x1b\n\r\n\x05\x04)\x02\x05\
    \x03\x12\x04\xf5\x04\x1e\x1f\n\x0c\n\x04\x04)\x02\x06\x12\x04\xf6\x04\
    \x02\x16\n\r\n\x05\x04)\x02\x06\x05\x12\x04\xf6\x04\x02\x07\n\r\n\x05\
    \x04)\x02\x06\x01\x12\x04\xf6\x04\x08\x11\n\r\n\x05\x04)\x02\x06\x03\x12\
    \x04\xf6\x04\x14\x15\n\x0c\n\x04\x04)\x02\x07\x12\x04\xf7\x04\x02%\n\r\n\
    \x05\x04)\x02\x07\x04\x12\x04\xf7\x04\x02\n\n\r\n\x05\x04)\x02\x07\x06\
    \x12\x04\xf7\x04\x0b\x13\n\r\n\x05\x04)\x02\x07\x01\x12\x04\xf7\x04\x14\
    \x20\n\r\n\x05\x04)\x02\x07\x03\x12\x04\xf7\x04#$\n\x0c\n\x04\x04)\x02\
    \x08\x12\x04\xf8\x04\x02$\n\r\n\x05\x04)\x02\x08\x06\x12\x04\xf8\x04\x02\
    \x10\n\r\n\x05\x04)\x02\x08\x01\x12\x04\xf8\x04\x11\x1f\n\r\n\x05\x04)\
    \x02\x08\x03\x12\x04\xf8\x04\"#\n\x0c\n\x04\x04)\x02\t\x12\x04\xf9\x04\
    \x02\x1f\n\r\n\x05\x04)\x02\t\x06\x12\x04\xf9\x04\x02\r\n\r\n\x05\x04)\
    \x02\t\x01\x12\x04\xf9\x04\x0e\x19\n\r\n\x05\x04)\x02\t\x03\x12\x04\xf9\
    \x04\x1c\x1e\n\x0c\n\x04\x04)\x02\n\x12\x04\xfa\x04\x02/\n\r\n\x05\x04)\
    \x02\n\x06\x12\x04\xfa\x04\x02\x15\n\r\n\x05\x04)\x02\n\x01\x12\x04\xfa\
    \x04\x16)\n\r\n\x05\x04)\x02\n\x03\x12\x04\xfa\x04,.\n\x0e\n\x04\x04)\
    \x03\x01\x12\x06\xfc\x04\x02\x96\x05\x03\n\r\n\x05\x04)\x03\x01\x01\x12\
    \x04\xfc\x04\n\x12\n\x0e\n\x06\x04)\x03\x01\x02\0\x12\x04\xfd\x04\x04\
    \x1d\n\x0f\n\x07\x04)\x03\x01\x02\0\x05\x12\x04\xfd\x04\x04\n\n\x0f\n\
    \x07\x04)\x03\x01\x02\0\x01\x12\x04\xfd\x04\x0b\x18\n\x0f\n\x07\x04)\x03\
    \x01\x02\0\x03\x12\x04\xfd\x04\x1b\x1c\n\x0e\n\x06\x04)\x03\x01\x02\x01\
    \x12\x04\xfe\x04\x04\x18\n\x0f\n\x07\x04)\x03\x01\x02\x01\x05\x12\x04\
    \xfe\x04\x04\t\n\x0f\n\x07\x04)\x03\x01\x02\x01\x01\x12\x04\xfe\x04\n\
    \x13\n\x0f\n\x07\x04)\x03\x01\x02\x01\x03\x12\x04\xfe\x04\x16\x17\n\x0e\
    \n\x06\x04)\x03\x01\x02\x02\x12\x04\xff\x04\x04\"\n\x0f\n\x07\x04)\x03\
    \x01\x02\x02\x05\x12\x04\xff\x04\x04\t\n\x0f\n\x07\x04)\x03\x01\x02\x02\
    \x01\x12\x04\xff\x04\n\x1d\n\x0f\n\x07\x04)\x03\x01\x02\x02\x03\x12\x04\
    \xff\x04\x20!\n\x0e\n\x06\x04)\x03\x01\x02\x03\x12\x04\x80\x05\x04\x16\n\
    \x0f\n\x07\x04)\x03\x01\x02\x03\x05\x12\x04\x80\x05\x04\x08\n\x0f\n\x07\
    \x04)\x03\x01\x02\x03\x01\x12\x04\x80\x05\t\x11\n\x0f\n\x07\x04)\x03\x01\
    \x02\x03\x03\x12\x04\x80\x05\x14\x15\n\x0e\n\x06\x04)\x03\x01\x02\x04\
    \x12\x04\x81\x05\x04&\n\x0f\n\x07\x04)\x03\x01\x02\x04\x05\x12\x04\x81\
    \x05\x04\t\n\x0f\n\x07\x04)\x03\x01\x02\x04\x01\x12\x04\x81\x05\n!\n\x0f\
    \n\x07\x04)\x03\x01\x02\x04\x03\x12\x04\x81\x05$%\n\x0e\n\x06\x04)\x03\
    \x01\x02\x05\x12\x04\x82\x05\x04\x1e\n\x0f\n\x07\x04)\x03\x01\x02\x05\
    \x05\x12\x04\x82\x05\x04\x08\n\x0f\n\x07\x04)\x03\x01\x02\x05\x01\x12\
    \x04\x82\x05\t\x19\n\x0f\n\x07\x04)\x03\x01\x02\x05\x03\x12\x04\x82\x05\
    \x1c\x1d\n\x0e\n\x06\x04)\x03\x01\x02\x06\x12\x04\x83\x05\x04\x1c\n\x0f\
    \n\x07\x04)\x03\x01\x02\x06\x05\x12\x04\x83\x05\x04\x08\n\x0f\n\x07\x04)\
    \x03\x01\x02\x06\x01\x12\x04\x83\x05\t\x17\n\x0f\n\x07\x04)\x03\x01\x02\
    \x06\x03\x12\x04\x83\x05\x1a\x1b\n\x0e\n\x06\x04)\x03\x01\x02\x07\x12\
    \x04\x84\x05\x04\x14\n\x0f\n\x07\x04)\x03\x01\x02\x07\x05\x12\x04\x84\
    \x05\x04\n\n\x0f\n\x07\x04)\x03\x01\x02\x07\x01\x12\x04\x84\x05\x0b\x0f\
    \n\x0f\n\x07\x04)\x03\x01\x02\x07\x03\x12\x04\x84\x05\x12\x13\n\x0e\n\
    \x06\x04)\x03\x01\x02\x08\x12\x04\x85\x05\x04\x13\n\x0f\n\x07\x04)\x03\
    \x01\x02\x08\x05\x12\x04\x85\x05\x04\t\n\x0f\n\x07\x04)\x03\x01\x02\x08\
    \x01\x12\x04\x85\x05\n\x0e\n\x0f\n\x07\x04)\x03\x01\x02\x08\x03\x12\x04\
    \x85\x05\x11\x12\n\x0e\n\x06\x04)\x03\x01\x02\t\x12\x04\x86\x05\x04\x17\
    \n\x0f\n\x07\x04)\x03\x01\x02\t\x05\x12\x04\x86\x05\x04\n\n\x0f\n\x07\
    \x04)\x03\x01\x02\t\x01\x12\x04\x86\x05\x0b\x11\n\x0f\n\x07\x04)\x03\x01\
    \x02\t\x03\x12\x04\x86\x05\x14\x16\n\x0e\n\x06\x04)\x03\x01\x02\n\x12\
    \x04\x87\x05\x04\x1b\n\x0f\n\x07\x04)\x03\x01\x02\n\x05\x12\x04\x87\x05\
    \x04\t\n\x0f\n\x07\x04)\x03\x01\x02\n\x01\x12\x04\x87\x05\n\x15\n\x0f\n\
    \x07\x04)\x03\x01\x02\n\x03\x12\x04\x87\x05\x18\x1a\n\x0e\n\x06\x04)\x03\
    \x01\x02\x0b\x12\x04\x88\x05\x04\x1b\n\x0f\n\x07\x04)\x03\x01\x02\x0b\
    \x05\x12\x04\x88\x05\x04\n\n\x0f\n\x07\x04)\x03\x01\x02\x0b\x01\x12\x04\
    \x88\x05\x0b\x15\n\x0f\n\x07\x04)\x03\x01\x02\x0b\x03\x12\x04\x88\x05\
    \x18\x1a\n\x0e\n\x06\x04)\x03\x01\x02\x0c\x12\x04\x89\x05\x04\x1f\n\x0f\
    \n\x07\x04)\x03\x01\x02\x0c\x05\x12\x04\x89\x05\x04\t\n\x0f\n\x07\x04)\
    \x03\x01\x02\x0c\x01\x12\x04\x89\x05\n\x19\n\x0f\n\x07\x04)\x03\x01\x02\
    \x0c\x03\x12\x04\x89\x05\x1c\x1e\n\x0e\n\x06\x04)\x03\x01\x02\r\x12\x04\
    \x8a\x05\x04&\n\x0f\n\x07\x04)\x03\x01\x02\r\x05\x12\x04\x8a\x05\x04\t\n\
    \x0f\n\x07\x04)\x03\x01\x02\r\x01\x12\x04\x8a\x05\n\x20\n\x0f\n\x07\x04)\
    \x03\x01\x02\r\x03\x12\x04\x8a\x05#%\n\x0e\n\x06\x04)\x03\x01\x02\x0e\
    \x12\x04\x8b\x05\x04&\n\x0f\n\x07\x04)\x03\x01\x02\x0e\x05\x12\x04\x8b\
    \x05\x04\t\n\x0f\n\x07\x04)\x03\x01\x02\x0e\x01\x12\x04\x8b\x05\n\x20\n\
    \x0f\n\x07\x04)\x03\x01\x02\x0e\x03\x12\x04\x8b\x05#%\n\x0e\n\x06\x04)\
    \x03\x01\x02\x0f\x12\x04\x8c\x05\x04\x1d\n\x0f\n\x07\x04)\x03\x01\x02\
    \x0f\x05\x12\x04\x8c\x05\x04\t\n\x0f\n\x07\x04)\x03\x01\x02\x0f\x01\x12\
    \x04\x8c\x05\n\x17\n\x0f\n\x07\x04)\x03\x01\x02\x0f\x03\x12\x04\x8c\x05\
    \x1a\x1c\n\x0e\n\x06\x04)\x03\x01\x02\x10\x12\x04\x8d\x05\x04\x1f\n\x0f\
    \n\x07\x04)\x03\x01\x02\x10\x05\x12\x04\x8d\x05\x04\t\n\x0f\n\x07\x04)\
    \x03\x01\x02\x10\x01\x12\x04\x8d\x05\n\x19\n\x0f\n\x07\x04)\x03\x01\x02\
    \x10\x03\x12\x04\x8d\x05\x1c\x1e\n\x0e\n\x06\x04)\x03\x01\x02\x11\x12\
    \x04\x8e\x05\x04$\n\x0f\n\x07\x04)\x03\x01\x02\x11\x05\x12\x04\x8e\x05\
    \x04\n\n\x0f\n\x07\x04)\x03\x01\x02\x11\x01\x12\x04\x8e\x05\x0b\x1e\n\
    \x0f\n\x07\x04)\x03\x01\x02\x11\x03\x12\x04\x8e\x05!#\n\x0e\n\x06\x04)\
    \x03\x01\x02\x12\x12\x04\x8f\x05\x04\x17\n\x0f\n\x07\x04)\x03\x01\x02\
    \x12\x05\x12\x04\x8f\x05\x04\x08\n\x0f\n\x07\x04)\x03\x01\x02\x12\x01\
    \x12\x04\x8f\x05\t\x11\n\x0f\n\x07\x04)\x03\x01\x02\x12\x03\x12\x04\x8f\
    \x05\x14\x16\n\x0e\n\x06\x04)\x03\x01\x02\x13\x12\x04\x90\x05\x04\x15\n\
    \x0f\n\x07\x04)\x03\x01\x02\x13\x05\x12\x04\x90\x05\x04\t\n\x0f\n\x07\
    \x04)\x03\x01\x02\x13\x01\x12\x04\x90\x05\n\x0f\n\x0f\n\x07\x04)\x03\x01\
    \x02\x13\x03\x12\x04\x90\x05\x12\x14\n\x0e\n\x06\x04)\x03\x01\x02\x14\
    \x12\x04\x91\x05\x04\x19\n\x0f\n\x07\x04)\x03\x01\x02\x14\x05\x12\x04\
    \x91\x05\x04\t\n\x0f\n\x07\x04)\x03\x01\x02\x14\x01\x12\x04\x91\x05\n\
    \x13\n\x0f\n\x07\x04)\x03\x01\x02\x14\x03\x12\x04\x91\x05\x16\x18\n\x0e\
    \n\x06\x04)\x03\x01\x02\x15\x12\x04\x92\x05\x04\x16\n\x0f\n\x07\x04)\x03\
    \x01\x02\x15\x05\x12\x04\x92\x05\x04\t\n\x0f\n\x07\x04)\x03\x01\x02\x15\
    \x01\x12\x04\x92\x05\n\x10\n\x0f\n\x07\x04)\x03\x01\x02\x15\x03\x12\x04\
    \x92\x05\x13\x15\n\x0e\n\x06\x04)\x03\x01\x02\x16\x12\x04\x93\x05\x04\
    \x1f\n\x0f\n\x07\x04)\x03\x01\x02\x16\x05\x12\x04\x93\x05\x04\t\n\x0f\n\
    \x07\x04)\x03\x01\x02\x16\x01\x12\x04\x93\x05\n\x19\n\x0f\n\x07\x04)\x03\
    \x01\x02\x16\x03\x12\x04\x93\x05\x1c\x1e\n\x0e\n\x06\x04)\x03\x01\x02\
    \x17\x12\x04\x94\x05\x04&\n\x0f\n\x07\x04)\x03\x01\x02\x17\x05\x12\x04\
    \x94\x05\x04\n\n\x0f\n\x07\x04)\x03\x01\x02\x17\x01\x12\x04\x94\x05\x0b\
    \x20\n\x0f\n\x07\x04)\x03\x01\x02\x17\x03\x12\x04\x94\x05#%\n\x0e\n\x06\
    \x04)\x03\x01\x02\x18\x12\x04\x95\x05\x04'\n\x0f\n\x07\x04)\x03\x01\x02\
    \x18\x05\x12\x04\x95\x05\x04\n\n\x0f\n\x07\x04)\x03\x01\x02\x18\x01\x12\
    \x04\x95\x05\x0b!\n\x0f\n\x07\x04)\x03\x01\x02\x18\x03\x12\x04\x95\x05$&\
    \n\x0e\n\x04\x04)\x03\x02\x12\x06\x98\x05\x02\xac\x05\x03\n\r\n\x05\x04)\
    \x03\x02\x01\x12\x04\x98\x05\n\x18\n\x0e\n\x06\x04)\x03\x02\x02\0\x12\
    \x04\x99\x05\x04\x1b\n\x0f\n\x07\x04)\x03\x02\x02\0\x05\x12\x04\x99\x05\
    \x04\n\n\x0f\n\x07\x04)\x03\x02\x02\0\x01\x12\x04\x99\x05\x0b\x16\n\x0f\
    \n\x07\x04)\x03\x02\x02\0\x03\x12\x04\x99\x05\x19\x1a\n\x0e\n\x06\x04)\
    \x03\x02\x02\x01\x12\x04\x9a\x05\x04\x1a\n\x0f\n\x07\x04)\x03\x02\x02\
    \x01\x05\x12\x04\x9a\x05\x04\n\n\x0f\n\x07\x04)\x03\x02\x02\x01\x01\x12\
    \x04\x9a\x05\x0b\x15\n\x0f\n\x07\x04)\x03\x02\x02\x01\x03\x12\x04\x9a\
    \x05\x18\x19\n\x0e\n\x06\x04)\x03\x02\x02\x02\x12\x04\x9b\x05\x04\x19\n\
    \x0f\n\x07\x04)\x03\x02\x02\x02\x05\x12\x04\x9b\x05\x04\t\n\x0f\n\x07\
    \x04)\x03\x02\x02\x02\x01\x12\x04\x9b\x05\n\x14\n\x0f\n\x07\x04)\x03\x02\
    \x02\x02\x03\x12\x04\x9b\x05\x17\x18\n\x0e\n\x06\x04)\x03\x02\x02\x03\
    \x12\x04\x9c\x05\x04\x1c\n\x0f\n\x07\x04)\x03\x02\x02\x03\x05\x12\x04\
    \x9c\x05\x04\x08\n\x0f\n\x07\x04)\x03\x02\x02\x03\x01\x12\x04\x9c\x05\t\
    \x17\n\x0f\n\x07\x04)\x03\x02\x02\x03\x03\x12\x04\x9c\x05\x1a\x1b\n\x0e\
    \n\x06\x04)\x03\x02\x02\x04\x12\x04\x9d\x05\x04\x1d\n\x0f\n\x07\x04)\x03\
    \x02\x02\x04\x05\x12\x04\x9d\x05\x04\t\n\x0f\n\x07\x04)\x03\x02\x02\x04\
    \x01\x12\x04\x9d\x05\n\x18\n\x0f\n\x07\x04)\x03\x02\x02\x04\x03\x12\x04\
    \x9d\x05\x1b\x1c\n\x0e\n\x06\x04)\x03\x02\x02\x05\x12\x04\x9e\x05\x04\
    \x1e\n\x0f\n\x07\x04)\x03\x02\x02\x05\x05\x12\x04\x9e\x05\x04\t\n\x0f\n\
    \x07\x04)\x03\x02\x02\x05\x01\x12\x04\x9e\x05\n\x19\n\x0f\n\x07\x04)\x03\
    \x02\x02\x05\x03\x12\x04\x9e\x05\x1c\x1d\n\x0e\n\x06\x04)\x03\x02\x02\
    \x06\x12\x04\x9f\x05\x04\x1b\n\x0f\n\x07\x04)\x03\x02\x02\x06\x05\x12\
    \x04\x9f\x05\x04\t\n\x0f\n\x07\x04)\x03\x02\x02\x06\x01\x12\x04\x9f\x05\
    \n\x16\n\x0f\n\x07\x04)\x03\x02\x02\x06\x03\x12\x04\x9f\x05\x19\x1a\n\
    \x0e\n\x06\x04)\x03\x02\x02\x07\x12\x04\xa0\x05\x04\x1e\n\x0f\n\x07\x04)\
    \x03\x02\x02\x07\x05\x12\x04\xa0\x05\x04\t\n\x0f\n\x07\x04)\x03\x02\x02\
    \x07\x01\x12\x04\xa0\x05\n\x19\n\x0f\n\x07\x04)\x03\x02\x02\x07\x03\x12\
    \x04\xa0\x05\x1c\x1d\n\x0e\n\x06\x04)\x03\x02\x02\x08\x12\x04\xa1\x05\
    \x04$\n\x0f\n\x07\x04)\x03\x02\x02\x08\x05\x12\x04\xa1\x05\x04\t\n\x0f\n\
    \x07\x04)\x03\x02\x02\x08\x01\x12\x04\xa1\x05\n\x1f\n\x0f\n\x07\x04)\x03\
    \x02\x02\x08\x03\x12\x04\xa1\x05\"#\n\x0e\n\x06\x04)\x03\x02\x02\t\x12\
    \x04\xa2\x05\x04\x20\n\x0f\n\x07\x04)\x03\x02\x02\t\x05\x12\x04\xa2\x05\
    \x04\t\n\x0f\n\x07\x04)\x03\x02\x02\t\x01\x12\x04\xa2\x05\n\x1a\n\x0f\n\
    \x07\x04)\x03\x02\x02\t\x03\x12\x04\xa2\x05\x1d\x1f\n\x0e\n\x06\x04)\x03\
    \x02\x02\n\x12\x04\xa3\x05\x04\x20\n\x0f\n\x07\x04)\x03\x02\x02\n\x05\
    \x12\x04\xa3\x05\x04\t\n\x0f\n\x07\x04)\x03\x02\x02\n\x01\x12\x04\xa3\
    \x05\n\x1a\n\x0f\n\x07\x04)\x03\x02\x02\n\x03\x12\x04\xa3\x05\x1d\x1f\n\
    \x0e\n\x06\x04)\x03\x02\x02\x0b\x12\x04\xa4\x05\x04\x1e\n\x0f\n\x07\x04)\
    \x03\x02\x02\x0b\x05\x12\x04\xa4\x05\x04\t\n\x0f\n\x07\x04)\x03\x02\x02\
    \x0b\x01\x12\x04\xa4\x05\n\x18\n\x0f\n\x07\x04)\x03\x02\x02\x0b\x03\x12\
    \x04\xa4\x05\x1b\x1d\n\x0e\n\x06\x04)\x03\x02\x02\x0c\x12\x04\xa5\x05\
    \x04\x19\n\x0f\n\x07\x04)\x03\x02\x02\x0c\x05\x12\x04\xa5\x05\x04\t\n\
    \x0f\n\x07\x04)\x03\x02\x02\x0c\x01\x12\x04\xa5\x05\n\x13\n\x0f\n\x07\
    \x04)\x03\x02\x02\x0c\x03\x12\x04\xa5\x05\x16\x18\n\x0e\n\x06\x04)\x03\
    \x02\x02\r\x12\x04\xa6\x05\x04$\n\x0f\n\x07\x04)\x03\x02\x02\r\x05\x12\
    \x04\xa6\x05\x04\t\n\x0f\n\x07\x04)\x03\x02\x02\r\x01\x12\x04\xa6\x05\n\
    \x1e\n\x0f\n\x07\x04)\x03\x02\x02\r\x03\x12\x04\xa6\x05!#\n\x0e\n\x06\
    \x04)\x03\x02\x02\x0e\x12\x04\xa7\x05\x04\x1e\n\x0f\n\x07\x04)\x03\x02\
    \x02\x0e\x05\x12\x04\xa7\x05\x04\x08\n\x0f\n\x07\x04)\x03\x02\x02\x0e\
    \x01\x12\x04\xa7\x05\t\x18\n\x0f\n\x07\x04)\x03\x02\x02\x0e\x03\x12\x04\
    \xa7\x05\x1b\x1d\n\x0e\n\x06\x04)\x03\x02\x02\x0f\x12\x04\xa8\x05\x04\
    \x1d\n\x0f\n\x07\x04)\x03\x02\x02\x0f\x05\x12\x04\xa8\x05\x04\n\n\x0f\n\
    \x07\x04)\x03\x02\x02\x0f\x01\x12\x04\xa8\x05\x0b\x17\n\x0f\n\x07\x04)\
    \x03\x02\x02\x0f\x03\x12\x04\xa8\x05\x1a\x1c\n\x0e\n\x06\x04)\x03\x02\
    \x02\x10\x12\x04\xa9\x05\x04\x1d\n\x0f\n\x07\x04)\x03\x02\x02\x10\x05\
    \x12\x04\xa9\x05\x04\n\n\x0f\n\x07\x04)\x03\x02\x02\x10\x01\x12\x04\xa9\
    \x05\x0b\x17\n\x0f\n\x07\x04)\x03\x02\x02\x10\x03\x12\x04\xa9\x05\x1a\
    \x1c\n\x0e\n\x06\x04)\x03\x02\x02\x11\x12\x04\xaa\x05\x04(\n\x0f\n\x07\
    \x04)\x03\x02\x02\x11\x05\x12\x04\xaa\x05\x04\t\n\x0f\n\x07\x04)\x03\x02\
    \x02\x11\x01\x12\x04\xaa\x05\n\"\n\x0f\n\x07\x04)\x03\x02\x02\x11\x03\
    \x12\x04\xaa\x05%'\n\x0e\n\x06\x04)\x03\x02\x02\x12\x12\x04\xab\x05\x04#\
    \n\x0f\n\x07\x04)\x03\x02\x02\x12\x05\x12\x04\xab\x05\x04\t\n\x0f\n\x07\
    \x04)\x03\x02\x02\x12\x01\x12\x04\xab\x05\n\x1d\n\x0f\n\x07\x04)\x03\x02\
    \x02\x12\x03\x12\x04\xab\x05\x20\"\n\x0e\n\x04\x04)\x03\x03\x12\x06\xae\
    \x05\x02\xce\x05\x03\n\r\n\x05\x04)\x03\x03\x01\x12\x04\xae\x05\n\x15\n\
    \x0e\n\x06\x04)\x03\x03\x02\0\x12\x04\xaf\x05\x04\x1a\n\x0f\n\x07\x04)\
    \x03\x03\x02\0\x05\x12\x04\xaf\x05\x04\t\n\x0f\n\x07\x04)\x03\x03\x02\0\
    \x01\x12\x04\xaf\x05\n\x15\n\x0f\n\x07\x04)\x03\x03\x02\0\x03\x12\x04\
    \xaf\x05\x18\x19\n\x0e\n\x06\x04)\x03\x03\x02\x01\x12\x04\xb0\x05\x04\"\
    \n\x0f\n\x07\x04)\x03\x03\x02\x01\x05\x12\x04\xb0\x05\x04\t\n\x0f\n\x07\
    \x04)\x03\x03\x02\x01\x01\x12\x04\xb0\x05\n\x1d\n\x0f\n\x07\x04)\x03\x03\
    \x02\x01\x03\x12\x04\xb0\x05\x20!\n\x0e\n\x06\x04)\x03\x03\x02\x02\x12\
    \x04\xb1\x05\x04\x17\n\x0f\n\x07\x04)\x03\x03\x02\x02\x05\x12\x04\xb1\
    \x05\x04\t\n\x0f\n\x07\x04)\x03\x03\x02\x02\x01\x12\x04\xb1\x05\n\x12\n\
    \x0f\n\x07\x04)\x03\x03\x02\x02\x03\x12\x04\xb1\x05\x15\x16\n\x0e\n\x06\
    \x04)\x03\x03\x02\x03\x12\x04\xb2\x05\x04\x1a\n\x0f\n\x07\x04)\x03\x03\
    \x02\x03\x05\x12\x04\xb2\x05\x04\t\n\x0f\n\x07\x04)\x03\x03\x02\x03\x01\
    \x12\x04\xb2\x05\n\x15\n\x0f\n\x07\x04)\x03\x03\x02\x03\x03\x12\x04\xb2\
    \x05\x18\x19\n\x0e\n\x06\x04)\x03\x03\x02\x04\x12\x04\xb3\x05\x04\x19\n\
    \x0f\n\x07\x04)\x03\x03\x02\x04\x05\x12\x04\xb3\x05\x04\t\n\x0f\n\x07\
    \x04)\x03\x03\x02\x04\x01\x12\x04\xb3\x05\n\x14\n\x0f\n\x07\x04)\x03\x03\
    \x02\x04\x03\x12\x04\xb3\x05\x17\x18\n\x0e\n\x06\x04)\x03\x03\x02\x05\
    \x12\x04\xb4\x05\x04\x17\n\x0f\n\x07\x04)\x03\x03\x02\x05\x05\x12\x04\
    \xb4\x05\x04\n\n\x0f\n\x07\x04)\x03\x03\x02\x05\x01\x12\x04\xb4\x05\x0b\
    \x12\n\x0f\n\x07\x04)\x03\x03\x02\x05\x03\x12\x04\xb4\x05\x15\x16\n\x0e\
    \n\x06\x04)\x03\x03\x02\x06\x12\x04\xb5\x05\x04\x1b\n\x0f\n\x07\x04)\x03\
    \x03\x02\x06\x05\x12\x04\xb5\x05\x04\n\n\x0f\n\x07\x04)\x03\x03\x02\x06\
    \x01\x12\x04\xb5\x05\x0b\x16\n\x0f\n\x07\x04)\x03\x03\x02\x06\x03\x12\
    \x04\xb5\x05\x19\x1a\n\x0e\n\x06\x04)\x03\x03\x02\x07\x12\x04\xb6\x05\
    \x04\x16\n\x0f\n\x07\x04)\x03\x03\x02\x07\x05\x12\x04\xb6\x05\x04\n\n\
    \x0f\n\x07\x04)\x03\x03\x02\x07\x01\x12\x04\xb6\x05\x0b\x11\n\x0f\n\x07\
    \x04)\x03\x03\x02\x07\x03\x12\x04\xb6\x05\x14\x15\n\x0e\n\x06\x04)\x03\
    \x03\x02\x08\x12\x04\xb7\x05\x04\x1d\n\x0f\n\x07\x04)\x03\x03\x02\x08\
    \x05\x12\x04\xb7\x05\x04\t\n\x0f\n\x07\x04)\x03\x03\x02\x08\x01\x12\x04\
    \xb7\x05\n\x18\n\x0f\n\x07\x04)\x03\x03\x02\x08\x03\x12\x04\xb7\x05\x1b\
    \x1c\n\x0e\n\x06\x04)\x03\x03\x02\t\x12\x04\xb8\x05\x04\x1d\n\x0f\n\x07\
    \x04)\x03\x03\x02\t\x05\x12\x04\xb8\x05\x04\t\n\x0f\n\x07\x04)\x03\x03\
    \x02\t\x01\x12\x04\xb8\x05\n\x17\n\x0f\n\x07\x04)\x03\x03\x02\t\x03\x12\
    \x04\xb8\x05\x1a\x1c\n\x0e\n\x06\x04)\x03\x03\x02\n\x12\x04\xb9\x05\x04\
    \x1f\n\x0f\n\x07\x04)\x03\x03\x02\n\x05\x12\x04\xb9\x05\x04\n\n\x0f\n\
    \x07\x04)\x03\x03\x02\n\x01\x12\x04\xb9\x05\x0b\x19\n\x0f\n\x07\x04)\x03\
    \x03\x02\n\x03\x12\x04\xb9\x05\x1c\x1e\n\x0e\n\x06\x04)\x03\x03\x02\x0b\
    \x12\x04\xba\x05\x044\n\x0f\n\x07\x04)\x03\x03\x02\x0b\x04\x12\x04\xba\
    \x05\x04\x0c\n\x0f\n\x07\x04)\x03\x03\x02\x0b\x06\x12\x04\xba\x05\r\x1b\
    \n\x0f\n\x07\x04)\x03\x03\x02\x0b\x01\x12\x04\xba\x05\x1c.\n\x0f\n\x07\
    \x04)\x03\x03\x02\x0b\x03\x12\x04\xba\x0513\n\x0e\n\x06\x04)\x03\x03\x02\
    \x0c\x12\x04\xbb\x05\x04<\n\x0f\n\x07\x04)\x03\x03\x02\x0c\x04\x12\x04\
    \xbb\x05\x04\x0c\n\x0f\n\x07\x04)\x03\x03\x02\x0c\x06\x12\x04\xbb\x05\r\
    \x1f\n\x0f\n\x07\x04)\x03\x03\x02\x0c\x01\x12\x04\xbb\x05\x206\n\x0f\n\
    \x07\x04)\x03\x03\x02\x0c\x03\x12\x04\xbb\x059;\n\x10\n\x06\x04)\x03\x03\
    \x03\0\x12\x06\xbd\x05\x04\xc3\x05\x05\n\x0f\n\x07\x04)\x03\x03\x03\0\
    \x01\x12\x04\xbd\x05\x0c\x1a\n\x10\n\x08\x04)\x03\x03\x03\0\x02\0\x12\
    \x04\xbe\x05\x06\x16\n\x11\n\t\x04)\x03\x03\x03\0\x02\0\x05\x12\x04\xbe\
    \x05\x06\x0c\n\x11\n\t\x04)\x03\x03\x03\0\x02\0\x01\x12\x04\xbe\x05\r\
    \x11\n\x11\n\t\x04)\x03\x03\x03\0\x02\0\x03\x12\x04\xbe\x05\x14\x15\n\
    \x10\n\x08\x04)\x03\x03\x03\0\x02\x01\x12\x04\xbf\x05\x06\x19\n\x11\n\t\
    \x04)\x03\x03\x03\0\x02\x01\x05\x12\x04\xbf\x05\x06\x0b\n\x11\n\t\x04)\
    \x03\x03\x03\0\x02\x01\x01\x12\x04\xbf\x05\x0c\x14\n\x11\n\t\x04)\x03\
    \x03\x03\0\x02\x01\x03\x12\x04\xbf\x05\x17\x18\n\x10\n\x08\x04)\x03\x03\
    \x03\0\x02\x02\x12\x04\xc0\x05\x06\x18\n\x11\n\t\x04)\x03\x03\x03\0\x02\
    \x02\x05\x12\x04\xc0\x05\x06\x0b\n\x11\n\t\x04)\x03\x03\x03\0\x02\x02\
    \x01\x12\x04\xc0\x05\x0c\x13\n\x11\n\t\x04)\x03\x03\x03\0\x02\x02\x03\
    \x12\x04\xc0\x05\x16\x17\n\x10\n\x08\x04)\x03\x03\x03\0\x02\x03\x12\x04\
    \xc1\x05\x06\x18\n\x11\n\t\x04)\x03\x03\x03\0\x02\x03\x05\x12\x04\xc1\
    \x05\x06\x0b\n\x11\n\t\x04)\x03\x03\x03\0\x02\x03\x01\x12\x04\xc1\x05\
    \x0c\x13\n\x11\n\t\x04)\x03\x03\x03\0\x02\x03\x03\x12\x04\xc1\x05\x16\
    \x17\n\x10\n\x08\x04)\x03\x03\x03\0\x02\x04\x12\x04\xc2\x05\x06\x19\n\
    \x11\n\t\x04)\x03\x03\x03\0\x02\x04\x05\x12\x04\xc2\x05\x06\x0c\n\x11\n\
    \t\x04)\x03\x03\x03\0\x02\x04\x01\x12\x04\xc2\x05\r\x14\n\x11\n\t\x04)\
    \x03\x03\x03\0\x02\x04\x03\x12\x04\xc2\x05\x17\x18\n\x10\n\x06\x04)\x03\
    \x03\x03\x01\x12\x06\xc5\x05\x04\xcd\x05\x05\n\x0f\n\x07\x04)\x03\x03\
    \x03\x01\x01\x12\x04\xc5\x05\x0c\x1e\n\x10\n\x08\x04)\x03\x03\x03\x01\
    \x02\0\x12\x04\xc6\x05\x06\x16\n\x11\n\t\x04)\x03\x03\x03\x01\x02\0\x05\
    \x12\x04\xc6\x05\x06\x0c\n\x11\n\t\x04)\x03\x03\x03\x01\x02\0\x01\x12\
    \x04\xc6\x05\r\x11\n\x11\n\t\x04)\x03\x03\x03\x01\x02\0\x03\x12\x04\xc6\
    \x05\x14\x15\n\x10\n\x08\x04)\x03\x03\x03\x01\x02\x01\x12\x04\xc7\x05\
    \x06\x1a\n\x11\n\t\x04)\x03\x03\x03\x01\x02\x01\x05\x12\x04\xc7\x05\x06\
    \x0c\n\x11\n\t\x04)\x03\x03\x03\x01\x02\x01\x01\x12\x04\xc7\x05\r\x15\n\
    \x11\n\t\x04)\x03\x03\x03\x01\x02\x01\x03\x12\x04\xc7\x05\x18\x19\n\x10\
    \n\x08\x04)\x03\x03\x03\x01\x02\x02\x12\x04\xc8\x05\x06\x1b\n\x11\n\t\
    \x04)\x03\x03\x03\x01\x02\x02\x05\x12\x04\xc8\x05\x06\x0c\n\x11\n\t\x04)\
    \x03\x03\x03\x01\x02\x02\x01\x12\x04\xc8\x05\r\x16\n\x11\n\t\x04)\x03\
    \x03\x03\x01\x02\x02\x03\x12\x04\xc8\x05\x19\x1a\n\x10\n\x08\x04)\x03\
    \x03\x03\x01\x02\x03\x12\x04\xc9\x05\x06\x17\n\x11\n\t\x04)\x03\x03\x03\
    \x01\x02\x03\x05\x12\x04\xc9\x05\x06\x0c\n\x11\n\t\x04)\x03\x03\x03\x01\
    \x02\x03\x01\x12\x04\xc9\x05\r\x12\n\x11\n\t\x04)\x03\x03\x03\x01\x02\
    \x03\x03\x12\x04\xc9\x05\x15\x16\n\x10\n\x08\x04)\x03\x03\x03\x01\x02\
    \x04\x12\x04\xca\x05\x06\x1a\n\x11\n\t\x04)\x03\x03\x03\x01\x02\x04\x05\
    \x12\x04\xca\x05\x06\x0b\n\x11\n\t\x04)\x03\x03\x03\x01\x02\x04\x01\x12\
    \x04\xca\x05\x0c\x15\n\x11\n\t\x04)\x03\x03\x03\x01\x02\x04\x03\x12\x04\
    \xca\x05\x18\x19\n\x10\n\x08\x04)\x03\x03\x03\x01\x02\x05\x12\x04\xcb\
    \x05\x06\x19\n\x11\n\t\x04)\x03\x03\x03\x01\x02\x05\x05\x12\x04\xcb\x05\
    \x06\x0b\n\x11\n\t\x04)\x03\x03\x03\x01\x02\x05\x01\x12\x04\xcb\x05\x0c\
    \x14\n\x11\n\t\x04)\x03\x03\x03\x01\x02\x05\x03\x12\x04\xcb\x05\x17\x18\
    \n\x10\n\x08\x04)\x03\x03\x03\x01\x02\x06\x12\x04\xcc\x05\x06\x1c\n\x11\
    \n\t\x04)\x03\x03\x03\x01\x02\x06\x05\x12\x04\xcc\x05\x06\x0c\n\x11\n\t\
    \x04)\x03\x03\x03\x01\x02\x06\x01\x12\x04\xcc\x05\r\x17\n\x11\n\t\x04)\
    \x03\x03\x03\x01\x02\x06\x03\x12\x04\xcc\x05\x1a\x1b\n\x0c\n\x02\x04*\
    \x12\x06\xd1\x05\0\xb7\x06\x01\n\x0b\n\x03\x04*\x01\x12\x04\xd1\x05\x08\
    \x13\n\x0c\n\x04\x04*\x02\0\x12\x04\xd2\x05\x02\x15\n\r\n\x05\x04*\x02\0\
    \x05\x12\x04\xd2\x05\x02\x07\n\r\n\x05\x04*\x02\0\x01\x12\x04\xd2\x05\
    \x08\x10\n\r\n\x05\x04*\x02\0\x03\x12\x04\xd2\x05\x13\x14\n\x0c\n\x04\
    \x04*\x02\x01\x12\x04\xd3\x05\x02\x14\n\r\n\x05\x04*\x02\x01\x06\x12\x04\
    \xd3\x05\x02\n\n\r\n\x05\x04*\x02\x01\x01\x12\x04\xd3\x05\x0b\x0f\n\r\n\
    \x05\x04*\x02\x01\x03\x12\x04\xd3\x05\x12\x13\n\x0c\n\x04\x04*\x02\x02\
    \x12\x04\xd4\x05\x02\x20\n\r\n\x05\x04*\x02\x02\x06\x12\x04\xd4\x05\x02\
    \x10\n\r\n\x05\x04*\x02\x02\x01\x12\x04\xd4\x05\x11\x1b\n\r\n\x05\x04*\
    \x02\x02\x03\x12\x04\xd4\x05\x1e\x1f\n\x0c\n\x04\x04*\x02\x03\x12\x04\
    \xd5\x05\x02\x12\n\r\n\x05\x04*\x02\x03\x06\x12\x04\xd5\x05\x02\t\n\r\n\
    \x05\x04*\x02\x03\x01\x12\x04\xd5\x05\n\r\n\r\n\x05\x04*\x02\x03\x03\x12\
    \x04\xd5\x05\x10\x11\n\x0e\n\x04\x04*\x03\0\x12\x06\xd7\x05\x02\xdc\x05\
    \x03\n\r\n\x05\x04*\x03\0\x01\x12\x04\xd7\x05\n\x12\n\x0e\n\x06\x04*\x03\
    \0\x02\0\x12\x04\xd8\x05\x04\x12\n\x0f\n\x07\x04*\x03\0\x02\0\x05\x12\
    \x04\xd8\x05\x04\n\n\x0f\n\x07\x04*\x03\0\x02\0\x01\x12\x04\xd8\x05\x0b\
    \r\n\x0f\n\x07\x04*\x03\0\x02\0\x03\x12\x04\xd8\x05\x10\x11\n\x0e\n\x06\
    \x04*\x03\0\x02\x01\x12\x04\xd9\x05\x04\x17\n\x0f\n\x07\x04*\x03\0\x02\
    \x01\x05\x12\x04\xd9\x05\x04\t\n\x0f\n\x07\x04*\x03\0\x02\x01\x01\x12\
    \x04\xd9\x05\n\x12\n\x0f\n\x07\x04*\x03\0\x02\x01\x03\x12\x04\xd9\x05\
    \x15\x16\n\x0e\n\x06\x04*\x03\0\x02\x02\x12\x04\xda\x05\x04\x17\n\x0f\n\
    \x07\x04*\x03\0\x02\x02\x05\x12\x04\xda\x05\x04\n\n\x0f\n\x07\x04*\x03\0\
    \x02\x02\x01\x12\x04\xda\x05\x0b\x12\n\x0f\n\x07\x04*\x03\0\x02\x02\x03\
    \x12\x04\xda\x05\x15\x16\n\x0e\n\x06\x04*\x03\0\x02\x03\x12\x04\xdb\x05\
    \x04\x1b\n\x0f\n\x07\x04*\x03\0\x02\x03\x05\x12\x04\xdb\x05\x04\t\n\x0f\
    \n\x07\x04*\x03\0\x02\x03\x01\x12\x04\xdb\x05\n\x16\n\x0f\n\x07\x04*\x03\
    \0\x02\x03\x03\x12\x04\xdb\x05\x19\x1a\n\x0e\n\x04\x04*\x03\x01\x12\x06\
    \xde\x05\x02\xf7\x05\x03\n\r\n\x05\x04*\x03\x01\x01\x12\x04\xde\x05\n\
    \x18\n\x0e\n\x06\x04*\x03\x01\x02\0\x12\x04\xdf\x05\x04\x1b\n\x0f\n\x07\
    \x04*\x03\x01\x02\0\x05\x12\x04\xdf\x05\x04\t\n\x0f\n\x07\x04*\x03\x01\
    \x02\0\x01\x12\x04\xdf\x05\n\x16\n\x0f\n\x07\x04*\x03\x01\x02\0\x03\x12\
    \x04\xdf\x05\x19\x1a\n\x0e\n\x06\x04*\x03\x01\x02\x01\x12\x04\xe0\x05\
    \x04!\n\x0f\n\x07\x04*\x03\x01\x02\x01\x05\x12\x04\xe0\x05\x04\t\n\x0f\n\
    \x07\x04*\x03\x01\x02\x01\x01\x12\x04\xe0\x05\n\x1c\n\x0f\n\x07\x04*\x03\
    \x01\x02\x01\x03\x12\x04\xe0\x05\x1f\x20\n\x0e\n\x06\x04*\x03\x01\x02\
    \x02\x12\x04\xe1\x05\x04\x1d\n\x0f\n\x07\x04*\x03\x01\x02\x02\x05\x12\
    \x04\xe1\x05\x04\n\n\x0f\n\x07\x04*\x03\x01\x02\x02\x01\x12\x04\xe1\x05\
    \x0b\x18\n\x0f\n\x07\x04*\x03\x01\x02\x02\x03\x12\x04\xe1\x05\x1b\x1c\n\
    \x0e\n\x06\x04*\x03\x01\x02\x03\x12\x04\xe2\x05\x04\x18\n\x0f\n\x07\x04*\
    \x03\x01\x02\x03\x05\x12\x04\xe2\x05\x04\t\n\x0f\n\x07\x04*\x03\x01\x02\
    \x03\x01\x12\x04\xe2\x05\n\x13\n\x0f\n\x07\x04*\x03\x01\x02\x03\x03\x12\
    \x04\xe2\x05\x16\x17\n\x0e\n\x06\x04*\x03\x01\x02\x04\x12\x04\xe3\x05\
    \x04\x1c\n\x0f\n\x07\x04*\x03\x01\x02\x04\x05\x12\x04\xe3\x05\x04\t\n\
    \x0f\n\x07\x04*\x03\x01\x02\x04\x01\x12\x04\xe3\x05\n\x17\n\x0f\n\x07\
    \x04*\x03\x01\x02\x04\x03\x12\x04\xe3\x05\x1a\x1b\n\x0e\n\x06\x04*\x03\
    \x01\x02\x05\x12\x04\xe4\x05\x04\"\n\x0f\n\x07\x04*\x03\x01\x02\x05\x06\
    \x12\x04\xe4\x05\x04\x0c\n\x0f\n\x07\x04*\x03\x01\x02\x05\x01\x12\x04\
    \xe4\x05\r\x1d\n\x0f\n\x07\x04*\x03\x01\x02\x05\x03\x12\x04\xe4\x05\x20!\
    \n\x0e\n\x06\x04*\x03\x01\x02\x06\x12\x04\xe5\x05\x04\x15\n\x0f\n\x07\
    \x04*\x03\x01\x02\x06\x06\x12\x04\xe5\x05\x04\x0c\n\x0f\n\x07\x04*\x03\
    \x01\x02\x06\x01\x12\x04\xe5\x05\r\x10\n\x0f\n\x07\x04*\x03\x01\x02\x06\
    \x03\x12\x04\xe5\x05\x13\x14\n\x0e\n\x06\x04*\x03\x01\x02\x07\x12\x04\
    \xe6\x05\x04#\n\x0f\n\x07\x04*\x03\x01\x02\x07\x05\x12\x04\xe6\x05\x04\t\
    \n\x0f\n\x07\x04*\x03\x01\x02\x07\x01\x12\x04\xe6\x05\n\x1e\n\x0f\n\x07\
    \x04*\x03\x01\x02\x07\x03\x12\x04\xe6\x05!\"\n\x0e\n\x06\x04*\x03\x01\
    \x02\x08\x12\x04\xe7\x05\x04#\n\x0f\n\x07\x04*\x03\x01\x02\x08\x06\x12\
    \x04\xe7\x05\x04\x0c\n\x0f\n\x07\x04*\x03\x01\x02\x08\x01\x12\x04\xe7\
    \x05\r\x1e\n\x0f\n\x07\x04*\x03\x01\x02\x08\x03\x12\x04\xe7\x05!\"\n\x0e\
    \n\x06\x04*\x03\x01\x02\t\x12\x04\xe8\x05\x04$\n\x0f\n\x07\x04*\x03\x01\
    \x02\t\x04\x12\x04\xe8\x05\x04\x0c\n\x0f\n\x07\x04*\x03\x01\x02\t\x06\
    \x12\x04\xe8\x05\r\x14\n\x0f\n\x07\x04*\x03\x01\x02\t\x01\x12\x04\xe8\
    \x05\x15\x1e\n\x0f\n\x07\x04*\x03\x01\x02\t\x03\x12\x04\xe8\x05!#\n\x0e\
    \n\x06\x04*\x03\x01\x02\n\x12\x04\xe9\x05\x04#\n\x0f\n\x07\x04*\x03\x01\
    \x02\n\x05\x12\x04\xe9\x05\x04\t\n\x0f\n\x07\x04*\x03\x01\x02\n\x01\x12\
    \x04\xe9\x05\n\x1d\n\x0f\n\x07\x04*\x03\x01\x02\n\x03\x12\x04\xe9\x05\
    \x20\"\n\x0e\n\x06\x04*\x03\x01\x02\x0b\x12\x04\xea\x05\x04'\n\x0f\n\x07\
    \x04*\x03\x01\x02\x0b\x05\x12\x04\xea\x05\x04\n\n\x0f\n\x07\x04*\x03\x01\
    \x02\x0b\x01\x12\x04\xea\x05\x0b!\n\x0f\n\x07\x04*\x03\x01\x02\x0b\x03\
    \x12\x04\xea\x05$&\n\x0e\n\x06\x04*\x03\x01\x02\x0c\x12\x04\xeb\x05\x04(\
    \n\x0f\n\x07\x04*\x03\x01\x02\x0c\x04\x12\x04\xeb\x05\x04\x0c\n\x0f\n\
    \x07\x04*\x03\x01\x02\x0c\x06\x12\x04\xeb\x05\r\x17\n\x0f\n\x07\x04*\x03\
    \x01\x02\x0c\x01\x12\x04\xeb\x05\x18\"\n\x0f\n\x07\x04*\x03\x01\x02\x0c\
    \x03\x12\x04\xeb\x05%'\n\x10\n\x06\x04*\x03\x01\x03\0\x12\x06\xed\x05\
    \x04\xf0\x05\x05\n\x0f\n\x07\x04*\x03\x01\x03\0\x01\x12\x04\xed\x05\x0c\
    \x13\n\x10\n\x08\x04*\x03\x01\x03\0\x02\0\x12\x04\xee\x05\x06\x19\n\x11\
    \n\t\x04*\x03\x01\x03\0\x02\0\x05\x12\x04\xee\x05\x06\x0c\n\x11\n\t\x04*\
    \x03\x01\x03\0\x02\0\x01\x12\x04\xee\x05\r\x14\n\x11\n\t\x04*\x03\x01\
    \x03\0\x02\0\x03\x12\x04\xee\x05\x17\x18\n\x10\n\x08\x04*\x03\x01\x03\0\
    \x02\x01\x12\x04\xef\x05\x06\x18\n\x11\n\t\x04*\x03\x01\x03\0\x02\x01\
    \x05\x12\x04\xef\x05\x06\x0b\n\x11\n\t\x04*\x03\x01\x03\0\x02\x01\x01\
    \x12\x04\xef\x05\x0c\x13\n\x11\n\t\x04*\x03\x01\x03\0\x02\x01\x03\x12\
    \x04\xef\x05\x16\x17\n\x10\n\x06\x04*\x03\x01\x03\x01\x12\x06\xf2\x05\
    \x04\xf6\x05\x05\n\x0f\n\x07\x04*\x03\x01\x03\x01\x01\x12\x04\xf2\x05\
    \x0c\x16\n\x10\n\x08\x04*\x03\x01\x03\x01\x02\0\x12\x04\xf3\x05\x06\x19\
    \n\x11\n\t\x04*\x03\x01\x03\x01\x02\0\x05\x12\x04\xf3\x05\x06\x0c\n\x11\
    \n\t\x04*\x03\x01\x03\x01\x02\0\x01\x12\x04\xf3\x05\r\x14\n\x11\n\t\x04*\
    \x03\x01\x03\x01\x02\0\x03\x12\x04\xf3\x05\x17\x18\n\x10\n\x08\x04*\x03\
    \x01\x03\x01\x02\x01\x12\x04\xf4\x05\x06\x19\n\x11\n\t\x04*\x03\x01\x03\
    \x01\x02\x01\x05\x12\x04\xf4\x05\x06\x0b\n\x11\n\t\x04*\x03\x01\x03\x01\
    \x02\x01\x01\x12\x04\xf4\x05\x0c\x14\n\x11\n\t\x04*\x03\x01\x03\x01\x02\
    \x01\x03\x12\x04\xf4\x05\x17\x18\n\x10\n\x08\x04*\x03\x01\x03\x01\x02\
    \x02\x12\x04\xf5\x05\x06\x16\n\x11\n\t\x04*\x03\x01\x03\x01\x02\x02\x05\
    \x12\x04\xf5\x05\x06\x0b\n\x11\n\t\x04*\x03\x01\x03\x01\x02\x02\x01\x12\
    \x04\xf5\x05\x0c\x11\n\x11\n\t\x04*\x03\x01\x03\x01\x02\x02\x03\x12\x04\
    \xf5\x05\x14\x15\n\x0e\n\x04\x04*\x03\x02\x12\x06\xf9\x05\x02\xff\x05\
    \x03\n\r\n\x05\x04*\x03\x02\x01\x12\x04\xf9\x05\n\x12\n\x0e\n\x06\x04*\
    \x03\x02\x02\0\x12\x04\xfa\x05\x04\x14\n\x0f\n\x07\x04*\x03\x02\x02\0\
    \x05\x12\x04\xfa\x05\x04\t\n\x0f\n\x07\x04*\x03\x02\x02\0\x01\x12\x04\
    \xfa\x05\n\x0f\n\x0f\n\x07\x04*\x03\x02\x02\0\x03\x12\x04\xfa\x05\x12\
    \x13\n\x0e\n\x06\x04*\x03\x02\x02\x01\x12\x04\xfb\x05\x04\x18\n\x0f\n\
    \x07\x04*\x03\x02\x02\x01\x05\x12\x04\xfb\x05\x04\n\n\x0f\n\x07\x04*\x03\
    \x02\x02\x01\x01\x12\x04\xfb\x05\x0b\x13\n\x0f\n\x07\x04*\x03\x02\x02\
    \x01\x03\x12\x04\xfb\x05\x16\x17\n\x0e\n\x06\x04*\x03\x02\x02\x02\x12\
    \x04\xfc\x05\x04\x1d\n\x0f\n\x07\x04*\x03\x02\x02\x02\x05\x12\x04\xfc\
    \x05\x04\n\n\x0f\n\x07\x04*\x03\x02\x02\x02\x01\x12\x04\xfc\x05\x0b\x18\
    \n\x0f\n\x07\x04*\x03\x02\x02\x02\x03\x12\x04\xfc\x05\x1b\x1c\n\x0e\n\
    \x06\x04*\x03\x02\x02\x03\x12\x04\xfd\x05\x04\x1e\n\x0f\n\x07\x04*\x03\
    \x02\x02\x03\x05\x12\x04\xfd\x05\x04\n\n\x0f\n\x07\x04*\x03\x02\x02\x03\
    \x01\x12\x04\xfd\x05\x0b\x19\n\x0f\n\x07\x04*\x03\x02\x02\x03\x03\x12\
    \x04\xfd\x05\x1c\x1d\n\x0e\n\x06\x04*\x03\x02\x02\x04\x12\x04\xfe\x05\
    \x04!\n\x0f\n\x07\x04*\x03\x02\x02\x04\x05\x12\x04\xfe\x05\x04\n\n\x0f\n\
    \x07\x04*\x03\x02\x02\x04\x01\x12\x04\xfe\x05\x0b\x1c\n\x0f\n\x07\x04*\
    \x03\x02\x02\x04\x03\x12\x04\xfe\x05\x1f\x20\n\x0e\n\x04\x04*\x03\x03\
    \x12\x06\x81\x06\x02\xb6\x06\x03\n\r\n\x05\x04*\x03\x03\x01\x12\x04\x81\
    \x06\n\x11\n\x0e\n\x06\x04*\x03\x03\x02\0\x12\x04\x82\x06\x04\x1e\n\x0f\
    \n\x07\x04*\x03\x03\x02\0\x05\x12\x04\x82\x06\x04\t\n\x0f\n\x07\x04*\x03\
    \x03\x02\0\x01\x12\x04\x82\x06\n\x19\n\x0f\n\x07\x04*\x03\x03\x02\0\x03\
    \x12\x04\x82\x06\x1c\x1d\n\x0e\n\x06\x04*\x03\x03\x02\x01\x12\x04\x83\
    \x06\x04\x14\n\x0f\n\x07\x04*\x03\x03\x02\x01\x06\x12\x04\x83\x06\x04\
    \x0b\n\x0f\n\x07\x04*\x03\x03\x02\x01\x01\x12\x04\x83\x06\x0c\x0f\n\x0f\
    \n\x07\x04*\x03\x03\x02\x01\x03\x12\x04\x83\x06\x12\x13\n\x0e\n\x06\x04*\
    \x03\x03\x02\x02\x12\x04\x84\x06\x04\x1e\n\x0f\n\x07\x04*\x03\x03\x02\
    \x02\x05\x12\x04\x84\x06\x04\t\n\x0f\n\x07\x04*\x03\x03\x02\x02\x01\x12\
    \x04\x84\x06\n\x19\n\x0f\n\x07\x04*\x03\x03\x02\x02\x03\x12\x04\x84\x06\
    \x1c\x1d\n\x0e\n\x06\x04*\x03\x03\x02\x03\x12\x04\x85\x06\x04#\n\x0f\n\
    \x07\x04*\x03\x03\x02\x03\x05\x12\x04\x85\x06\x04\t\n\x0f\n\x07\x04*\x03\
    \x03\x02\x03\x01\x12\x04\x85\x06\n\x1e\n\x0f\n\x07\x04*\x03\x03\x02\x03\
    \x03\x12\x04\x85\x06!\"\n\x0e\n\x06\x04*\x03\x03\x02\x04\x12\x04\x86\x06\
    \x04\x1e\n\x0f\n\x07\x04*\x03\x03\x02\x04\x06\x12\x04\x86\x06\x04\x0c\n\
    \x0f\n\x07\x04*\x03\x03\x02\x04\x01\x12\x04\x86\x06\r\x19\n\x0f\n\x07\
    \x04*\x03\x03\x02\x04\x03\x12\x04\x86\x06\x1c\x1d\n\x0e\n\x06\x04*\x03\
    \x03\x02\x05\x12\x04\x87\x06\x04\x1f\n\x0f\n\x07\x04*\x03\x03\x02\x05\
    \x06\x12\x04\x87\x06\x04\x0c\n\x0f\n\x07\x04*\x03\x03\x02\x05\x01\x12\
    \x04\x87\x06\r\x1a\n\x0f\n\x07\x04*\x03\x03\x02\x05\x03\x12\x04\x87\x06\
    \x1d\x1e\n\x0e\n\x06\x04*\x03\x03\x02\x06\x12\x04\x88\x06\x04!\n\x0f\n\
    \x07\x04*\x03\x03\x02\x06\x05\x12\x04\x88\x06\x04\t\n\x0f\n\x07\x04*\x03\
    \x03\x02\x06\x01\x12\x04\x88\x06\n\x1c\n\x0f\n\x07\x04*\x03\x03\x02\x06\
    \x03\x12\x04\x88\x06\x1f\x20\n\x0e\n\x06\x04*\x03\x03\x02\x07\x12\x04\
    \x89\x06\x04=\n\x0f\n\x07\x04*\x03\x03\x02\x07\x04\x12\x04\x89\x06\x04\
    \x0c\n\x0f\n\x07\x04*\x03\x03\x02\x07\x06\x12\x04\x89\x06\r$\n\x0f\n\x07\
    \x04*\x03\x03\x02\x07\x01\x12\x04\x89\x06%8\n\x0f\n\x07\x04*\x03\x03\x02\
    \x07\x03\x12\x04\x89\x06;<\n\x0e\n\x06\x04*\x03\x03\x02\x08\x12\x04\x8a\
    \x06\x04\x1e\n\x0f\n\x07\x04*\x03\x03\x02\x08\x06\x12\x04\x8a\x06\x04\
    \x0c\n\x0f\n\x07\x04*\x03\x03\x02\x08\x01\x12\x04\x8a\x06\r\x19\n\x0f\n\
    \x07\x04*\x03\x03\x02\x08\x03\x12\x04\x8a\x06\x1c\x1d\n\x0e\n\x06\x04*\
    \x03\x03\x02\t\x12\x04\x8b\x06\x04\x20\n\x0f\n\x07\x04*\x03\x03\x02\t\
    \x06\x12\x04\x8b\x06\x04\x0c\n\x0f\n\x07\x04*\x03\x03\x02\t\x01\x12\x04\
    \x8b\x06\r\x1a\n\x0f\n\x07\x04*\x03\x03\x02\t\x03\x12\x04\x8b\x06\x1d\
    \x1f\n\x0e\n\x06\x04*\x03\x03\x02\n\x12\x04\x8c\x06\x04\x1d\n\x0f\n\x07\
    \x04*\x03\x03\x02\n\x06\x12\x04\x8c\x06\x04\x0f\n\x0f\n\x07\x04*\x03\x03\
    \x02\n\x01\x12\x04\x8c\x06\x10\x17\n\x0f\n\x07\x04*\x03\x03\x02\n\x03\
    \x12\x04\x8c\x06\x1a\x1c\n\x10\n\x06\x04*\x03\x03\x03\0\x12\x06\x8e\x06\
    \x04\x9a\x06\x05\n\x0f\n\x07\x04*\x03\x03\x03\0\x01\x12\x04\x8e\x06\x0c\
    \x13\n\x10\n\x08\x04*\x03\x03\x03\0\x02\0\x12\x04\x8f\x06\x06\x17\n\x11\
    \n\t\x04*\x03\x03\x03\0\x02\0\x06\x12\x04\x8f\x06\x06\x0e\n\x11\n\t\x04*\
    \x03\x03\x03\0\x02\0\x01\x12\x04\x8f\x06\x0f\x12\n\x11\n\t\x04*\x03\x03\
    \x03\0\x02\0\x03\x12\x04\x8f\x06\x15\x16\n\x10\n\x08\x04*\x03\x03\x03\0\
    \x02\x01\x12\x04\x90\x06\x06\x1b\n\x11\n\t\x04*\x03\x03\x03\0\x02\x01\
    \x06\x12\x04\x90\x06\x06\x0e\n\x11\n\t\x04*\x03\x03\x03\0\x02\x01\x01\
    \x12\x04\x90\x06\x0f\x16\n\x11\n\t\x04*\x03\x03\x03\0\x02\x01\x03\x12\
    \x04\x90\x06\x19\x1a\n\x10\n\x08\x04*\x03\x03\x03\0\x02\x02\x12\x04\x91\
    \x06\x06\x1e\n\x11\n\t\x04*\x03\x03\x03\0\x02\x02\x06\x12\x04\x91\x06\
    \x06\x0e\n\x11\n\t\x04*\x03\x03\x03\0\x02\x02\x01\x12\x04\x91\x06\x0f\
    \x19\n\x11\n\t\x04*\x03\x03\x03\0\x02\x02\x03\x12\x04\x91\x06\x1c\x1d\n\
    \x10\n\x08\x04*\x03\x03\x03\0\x02\x03\x12\x04\x92\x06\x06(\n\x11\n\t\x04\
    *\x03\x03\x03\0\x02\x03\x04\x12\x04\x92\x06\x06\x0e\n\x11\n\t\x04*\x03\
    \x03\x03\0\x02\x03\x06\x12\x04\x92\x06\x0f\x1c\n\x11\n\t\x04*\x03\x03\
    \x03\0\x02\x03\x01\x12\x04\x92\x06\x1d#\n\x11\n\t\x04*\x03\x03\x03\0\x02\
    \x03\x03\x12\x04\x92\x06&'\n\x12\n\x08\x04*\x03\x03\x03\0\x03\0\x12\x06\
    \x94\x06\x06\x99\x06\x07\n\x11\n\t\x04*\x03\x03\x03\0\x03\0\x01\x12\x04\
    \x94\x06\x0e\x1b\n\x12\n\n\x04*\x03\x03\x03\0\x03\0\x02\0\x12\x04\x95\
    \x06\x08\x18\n\x13\n\x0b\x04*\x03\x03\x03\0\x03\0\x02\0\x05\x12\x04\x95\
    \x06\x08\x0e\n\x13\n\x0b\x04*\x03\x03\x03\0\x03\0\x02\0\x01\x12\x04\x95\
    \x06\x0f\x13\n\x13\n\x0b\x04*\x03\x03\x03\0\x03\0\x02\0\x03\x12\x04\x95\
    \x06\x16\x17\n\x12\n\n\x04*\x03\x03\x03\0\x03\0\x02\x01\x12\x04\x96\x06\
    \x08\x19\n\x13\n\x0b\x04*\x03\x03\x03\0\x03\0\x02\x01\x06\x12\x04\x96\
    \x06\x08\x10\n\x13\n\x0b\x04*\x03\x03\x03\0\x03\0\x02\x01\x01\x12\x04\
    \x96\x06\x11\x14\n\x13\n\x0b\x04*\x03\x03\x03\0\x03\0\x02\x01\x03\x12\
    \x04\x96\x06\x17\x18\n\x12\n\n\x04*\x03\x03\x03\0\x03\0\x02\x02\x12\x04\
    \x97\x06\x08\x1d\n\x13\n\x0b\x04*\x03\x03\x03\0\x03\0\x02\x02\x06\x12\
    \x04\x97\x06\x08\x10\n\x13\n\x0b\x04*\x03\x03\x03\0\x03\0\x02\x02\x01\
    \x12\x04\x97\x06\x11\x18\n\x13\n\x0b\x04*\x03\x03\x03\0\x03\0\x02\x02\
    \x03\x12\x04\x97\x06\x1b\x1c\n\x12\n\n\x04*\x03\x03\x03\0\x03\0\x02\x03\
    \x12\x04\x98\x06\x08\x20\n\x13\n\x0b\x04*\x03\x03\x03\0\x03\0\x02\x03\
    \x06\x12\x04\x98\x06\x08\x10\n\x13\n\x0b\x04*\x03\x03\x03\0\x03\0\x02\
    \x03\x01\x12\x04\x98\x06\x11\x1b\n\x13\n\x0b\x04*\x03\x03\x03\0\x03\0\
    \x02\x03\x03\x12\x04\x98\x06\x1e\x1f\n\x10\n\x06\x04*\x03\x03\x03\x01\
    \x12\x06\x9c\x06\x04\x9f\x06\x05\n\x0f\n\x07\x04*\x03\x03\x03\x01\x01\
    \x12\x04\x9c\x06\x0c#\n\x10\n\x08\x04*\x03\x03\x03\x01\x02\0\x12\x04\x9d\
    \x06\x06\x18\n\x11\n\t\x04*\x03\x03\x03\x01\x02\0\x05\x12\x04\x9d\x06\
    \x06\x0c\n\x11\n\t\x04*\x03\x03\x03\x01\x02\0\x01\x12\x04\x9d\x06\r\x13\
    \n\x11\n\t\x04*\x03\x03\x03\x01\x02\0\x03\x12\x04\x9d\x06\x16\x17\n\x10\
    \n\x08\x04*\x03\x03\x03\x01\x02\x01\x12\x04\x9e\x06\x06\x16\n\x11\n\t\
    \x04*\x03\x03\x03\x01\x02\x01\x05\x12\x04\x9e\x06\x06\x0b\n\x11\n\t\x04*\
    \x03\x03\x03\x01\x02\x01\x01\x12\x04\x9e\x06\x0c\x11\n\x11\n\t\x04*\x03\
    \x03\x03\x01\x02\x01\x03\x12\x04\x9e\x06\x14\x15\n\x10\n\x06\x04*\x03\
    \x03\x03\x02\x12\x06\xa1\x06\x04\xb5\x06\x05\n\x0f\n\x07\x04*\x03\x03\
    \x03\x02\x01\x12\x04\xa1\x06\x0c\x17\n\x10\n\x08\x04*\x03\x03\x03\x02\
    \x02\0\x12\x04\xa2\x06\x06\x16\n\x11\n\t\x04*\x03\x03\x03\x02\x02\0\x05\
    \x12\x04\xa2\x06\x06\x0b\n\x11\n\t\x04*\x03\x03\x03\x02\x02\0\x01\x12\
    \x04\xa2\x06\x0c\x11\n\x11\n\t\x04*\x03\x03\x03\x02\x02\0\x03\x12\x04\
    \xa2\x06\x14\x15\n\x10\n\x08\x04*\x03\x03\x03\x02\x02\x01\x12\x04\xa3\
    \x06\x06\x16\n\x11\n\t\x04*\x03\x03\x03\x02\x02\x01\x05\x12\x04\xa3\x06\
    \x06\x0b\n\x11\n\t\x04*\x03\x03\x03\x02\x02\x01\x01\x12\x04\xa3\x06\x0c\
    \x11\n\x11\n\t\x04*\x03\x03\x03\x02\x02\x01\x03\x12\x04\xa3\x06\x14\x15\
    \n\x10\n\x08\x04*\x03\x03\x03\x02\x02\x02\x12\x04\xa4\x06\x06\x16\n\x11\
    \n\t\x04*\x03\x03\x03\x02\x02\x02\x05\x12\x04\xa4\x06\x06\x0b\n\x11\n\t\
    \x04*\x03\x03\x03\x02\x02\x02\x01\x12\x04\xa4\x06\x0c\x11\n\x11\n\t\x04*\
    \x03\x03\x03\x02\x02\x02\x03\x12\x04\xa4\x06\x14\x15\n\x10\n\x08\x04*\
    \x03\x03\x03\x02\x02\x03\x12\x04\xa5\x06\x06\x1b\n\x11\n\t\x04*\x03\x03\
    \x03\x02\x02\x03\x05\x12\x04\xa5\x06\x06\x0b\n\x11\n\t\x04*\x03\x03\x03\
    \x02\x02\x03\x01\x12\x04\xa5\x06\x0c\x16\n\x11\n\t\x04*\x03\x03\x03\x02\
    \x02\x03\x03\x12\x04\xa5\x06\x19\x1a\n\x10\n\x08\x04*\x03\x03\x03\x02\
    \x02\x04\x12\x04\xa6\x06\x06\x18\n\x11\n\t\x04*\x03\x03\x03\x02\x02\x04\
    \x05\x12\x04\xa6\x06\x06\x0b\n\x11\n\t\x04*\x03\x03\x03\x02\x02\x04\x01\
    \x12\x04\xa6\x06\x0c\x13\n\x11\n\t\x04*\x03\x03\x03\x02\x02\x04\x03\x12\
    \x04\xa6\x06\x16\x17\n\x10\n\x08\x04*\x03\x03\x03\x02\x02\x05\x12\x04\
    \xa7\x06\x06\x18\n\x11\n\t\x04*\x03\x03\x03\x02\x02\x05\x05\x12\x04\xa7\
    \x06\x06\x0b\n\x11\n\t\x04*\x03\x03\x03\x02\x02\x05\x01\x12\x04\xa7\x06\
    \x0c\x13\n\x11\n\t\x04*\x03\x03\x03\x02\x02\x05\x03\x12\x04\xa7\x06\x16\
    \x17\n\x10\n\x08\x04*\x03\x03\x03\x02\x02\x06\x12\x04\xa8\x06\x06\x18\n\
    \x11\n\t\x04*\x03\x03\x03\x02\x02\x06\x05\x12\x04\xa8\x06\x06\x0b\n\x11\
    \n\t\x04*\x03\x03\x03\x02\x02\x06\x01\x12\x04\xa8\x06\x0c\x13\n\x11\n\t\
    \x04*\x03\x03\x03\x02\x02\x06\x03\x12\x04\xa8\x06\x16\x17\n\x10\n\x08\
    \x04*\x03\x03\x03\x02\x02\x07\x12\x04\xa9\x06\x06,\n\x11\n\t\x04*\x03\
    \x03\x03\x02\x02\x07\x04\x12\x04\xa9\x06\x06\x0e\n\x11\n\t\x04*\x03\x03\
    \x03\x02\x02\x07\x06\x12\x04\xa9\x06\x0f\x20\n\x11\n\t\x04*\x03\x03\x03\
    \x02\x02\x07\x01\x12\x04\xa9\x06!'\n\x11\n\t\x04*\x03\x03\x03\x02\x02\
    \x07\x03\x12\x04\xa9\x06*+\n\x12\n\x08\x04*\x03\x03\x03\x02\x03\0\x12\
    \x06\xab\x06\x06\xb4\x06\x07\n\x11\n\t\x04*\x03\x03\x03\x02\x03\0\x01\
    \x12\x04\xab\x06\x0e\x1f\n\x12\n\n\x04*\x03\x03\x03\x02\x03\0\x02\0\x12\
    \x04\xac\x06\x08\x1b\n\x13\n\x0b\x04*\x03\x03\x03\x02\x03\0\x02\0\x05\
    \x12\x04\xac\x06\x08\x0e\n\x13\n\x0b\x04*\x03\x03\x03\x02\x03\0\x02\0\
    \x01\x12\x04\xac\x06\x0f\x16\n\x13\n\x0b\x04*\x03\x03\x03\x02\x03\0\x02\
    \0\x03\x12\x04\xac\x06\x19\x1a\n\x12\n\n\x04*\x03\x03\x03\x02\x03\0\x02\
    \x01\x12\x04\xad\x06\x08\x18\n\x13\n\x0b\x04*\x03\x03\x03\x02\x03\0\x02\
    \x01\x05\x12\x04\xad\x06\x08\r\n\x13\n\x0b\x04*\x03\x03\x03\x02\x03\0\
    \x02\x01\x01\x12\x04\xad\x06\x0e\x13\n\x13\n\x0b\x04*\x03\x03\x03\x02\
    \x03\0\x02\x01\x03\x12\x04\xad\x06\x16\x17\n\x12\n\n\x04*\x03\x03\x03\
    \x02\x03\0\x02\x02\x12\x04\xae\x06\x08\x18\n\x13\n\x0b\x04*\x03\x03\x03\
    \x02\x03\0\x02\x02\x05\x12\x04\xae\x06\x08\r\n\x13\n\x0b\x04*\x03\x03\
    \x03\x02\x03\0\x02\x02\x01\x12\x04\xae\x06\x0e\x13\n\x13\n\x0b\x04*\x03\
    \x03\x03\x02\x03\0\x02\x02\x03\x12\x04\xae\x06\x16\x17\n\x12\n\n\x04*\
    \x03\x03\x03\x02\x03\0\x02\x03\x12\x04\xaf\x06\x08\x18\n\x13\n\x0b\x04*\
    \x03\x03\x03\x02\x03\0\x02\x03\x05\x12\x04\xaf\x06\x08\r\n\x13\n\x0b\x04\
    *\x03\x03\x03\x02\x03\0\x02\x03\x01\x12\x04\xaf\x06\x0e\x13\n\x13\n\x0b\
    \x04*\x03\x03\x03\x02\x03\0\x02\x03\x03\x12\x04\xaf\x06\x16\x17\n\x12\n\
    \n\x04*\x03\x03\x03\x02\x03\0\x02\x04\x12\x04\xb0\x06\x08\x18\n\x13\n\
    \x0b\x04*\x03\x03\x03\x02\x03\0\x02\x04\x05\x12\x04\xb0\x06\x08\r\n\x13\
    \n\x0b\x04*\x03\x03\x03\x02\x03\0\x02\x04\x01\x12\x04\xb0\x06\x0e\x13\n\
    \x13\n\x0b\x04*\x03\x03\x03\x02\x03\0\x02\x04\x03\x12\x04\xb0\x06\x16\
    \x17\n\x12\n\n\x04*\x03\x03\x03\x02\x03\0\x02\x05\x12\x04\xb1\x06\x08\
    \x1a\n\x13\n\x0b\x04*\x03\x03\x03\x02\x03\0\x02\x05\x05\x12\x04\xb1\x06\
    \x08\r\n\x13\n\x0b\x04*\x03\x03\x03\x02\x03\0\x02\x05\x01\x12\x04\xb1\
    \x06\x0e\x15\n\x13\n\x0b\x04*\x03\x03\x03\x02\x03\0\x02\x05\x03\x12\x04\
    \xb1\x06\x18\x19\n\x12\n\n\x04*\x03\x03\x03\x02\x03\0\x02\x06\x12\x04\
    \xb2\x06\x08\x1a\n\x13\n\x0b\x04*\x03\x03\x03\x02\x03\0\x02\x06\x05\x12\
    \x04\xb2\x06\x08\r\n\x13\n\x0b\x04*\x03\x03\x03\x02\x03\0\x02\x06\x01\
    \x12\x04\xb2\x06\x0e\x15\n\x13\n\x0b\x04*\x03\x03\x03\x02\x03\0\x02\x06\
    \x03\x12\x04\xb2\x06\x18\x19\n\x12\n\n\x04*\x03\x03\x03\x02\x03\0\x02\
    \x07\x12\x04\xb3\x06\x08\x1a\n\x13\n\x0b\x04*\x03\x03\x03\x02\x03\0\x02\
    \x07\x05\x12\x04\xb3\x06\x08\r\n\x13\n\x0b\x04*\x03\x03\x03\x02\x03\0\
    \x02\x07\x01\x12\x04\xb3\x06\x0e\x15\n\x13\n\x0b\x04*\x03\x03\x03\x02\
    \x03\0\x02\x07\x03\x12\x04\xb3\x06\x18\x19\n\x0c\n\x02\x04+\x12\x06\xb9\
    \x06\0\xce\x06\x01\n\x0b\n\x03\x04+\x01\x12\x04\xb9\x06\x08\x13\n\x0e\n\
    \x04\x04+\x04\0\x12\x06\xba\x06\x02\xc0\x06\x03\n\r\n\x05\x04+\x04\0\x01\
    \x12\x04\xba\x06\x07\x0e\n\x0e\n\x06\x04+\x04\0\x02\0\x12\x04\xbb\x06\
    \x04\x14\n\x0f\n\x07\x04+\x04\0\x02\0\x01\x12\x04\xbb\x06\x04\x0f\n\x0f\
    \n\x07\x04+\x04\0\x02\0\x02\x12\x04\xbb\x06\x12\x13\n\x0e\n\x06\x04+\x04\
    \0\x02\x01\x12\x04\xbc\x06\x04\x10\n\x0f\n\x07\x04+\x04\0\x02\x01\x01\
    \x12\x04\xbc\x06\x04\x0b\n\x0f\n\x07\x04+\x04\0\x02\x01\x02\x12\x04\xbc\
    \x06\x0e\x0f\n\x0e\n\x06\x04+\x04\0\x02\x02\x12\x04\xbd\x06\x04\x13\n\
    \x0f\n\x07\x04+\x04\0\x02\x02\x01\x12\x04\xbd\x06\x04\x0e\n\x0f\n\x07\
    \x04+\x04\0\x02\x02\x02\x12\x04\xbd\x06\x11\x12\n\x0e\n\x06\x04+\x04\0\
    \x02\x03\x12\x04\xbe\x06\x04\x10\n\x0f\n\x07\x04+\x04\0\x02\x03\x01\x12\
    \x04\xbe\x06\x04\x0b\n\x0f\n\x07\x04+\x04\0\x02\x03\x02\x12\x04\xbe\x06\
    \x0e\x0f\n\x0e\n\x06\x04+\x04\0\x02\x04\x12\x04\xbf\x06\x04\x0f\n\x0f\n\
    \x07\x04+\x04\0\x02\x04\x01\x12\x04\xbf\x06\x04\n\n\x0f\n\x07\x04+\x04\0\
    \x02\x04\x02\x12\x04\xbf\x06\r\x0e\n\x0e\n\x04\x04+\x04\x01\x12\x06\xc1\
    \x06\x02\xc4\x06\x03\n\r\n\x05\x04+\x04\x01\x01\x12\x04\xc1\x06\x07\x0f\
    \n\x0e\n\x06\x04+\x04\x01\x02\0\x12\x04\xc2\x06\x04\x0e\n\x0f\n\x07\x04+\
    \x04\x01\x02\0\x01\x12\x04\xc2\x06\x04\t\n\x0f\n\x07\x04+\x04\x01\x02\0\
    \x02\x12\x04\xc2\x06\x0c\r\n\x0e\n\x06\x04+\x04\x01\x02\x01\x12\x04\xc3\
    \x06\x04\x0c\n\x0f\n\x07\x04+\x04\x01\x02\x01\x01\x12\x04\xc3\x06\x04\
    \x07\n\x0f\n\x07\x04+\x04\x01\x02\x01\x02\x12\x04\xc3\x06\n\x0b\n\x0e\n\
    \x04\x04+\x03\0\x12\x06\xc5\x06\x02\xcb\x06\x03\n\r\n\x05\x04+\x03\0\x01\
    \x12\x04\xc5\x06\n\r\n\x0e\n\x06\x04+\x03\0\x02\0\x12\x04\xc6\x06\x04\
    \x19\n\x0f\n\x07\x04+\x03\0\x02\0\x06\x12\x04\xc6\x06\x04\x0b\n\x0f\n\
    \x07\x04+\x03\0\x02\0\x01\x12\x04\xc6\x06\x0c\x14\n\x0f\n\x07\x04+\x03\0\
    \x02\0\x03\x12\x04\xc6\x06\x17\x18\n\x0e\n\x06\x04+\x03\0\x02\x01\x12\
    \x04\xc7\x06\x04\x1b\n\x0f\n\x07\x04+\x03\0\x02\x01\x06\x12\x04\xc7\x06\
    \x04\x0c\n\x0f\n\x07\x04+\x03\0\x02\x01\x01\x12\x04\xc7\x06\r\x16\n\x0f\
    \n\x07\x04+\x03\0\x02\x01\x03\x12\x04\xc7\x06\x19\x1a\n\x0e\n\x06\x04+\
    \x03\0\x02\x02\x12\x04\xc8\x06\x04\x15\n\x0f\n\x07\x04+\x03\0\x02\x02\
    \x05\x12\x04\xc8\x06\x04\t\n\x0f\n\x07\x04+\x03\0\x02\x02\x01\x12\x04\
    \xc8\x06\n\x10\n\x0f\n\x07\x04+\x03\0\x02\x02\x03\x12\x04\xc8\x06\x13\
    \x14\n\x0e\n\x06\x04+\x03\0\x02\x03\x12\x04\xc9\x06\x04\x14\n\x0f\n\x07\
    \x04+\x03\0\x02\x03\x05\x12\x04\xc9\x06\x04\t\n\x0f\n\x07\x04+\x03\0\x02\
    \x03\x01\x12\x04\xc9\x06\n\x0f\n\x0f\n\x07\x04+\x03\0\x02\x03\x03\x12\
    \x04\xc9\x06\x12\x13\n\x0e\n\x06\x04+\x03\0\x02\x04\x12\x04\xca\x06\x04\
    \x13\n\x0f\n\x07\x04+\x03\0\x02\x04\x05\x12\x04\xca\x06\x04\t\n\x0f\n\
    \x07\x04+\x03\0\x02\x04\x01\x12\x04\xca\x06\n\x0e\n\x0f\n\x07\x04+\x03\0\
    \x02\x04\x03\x12\x04\xca\x06\x11\x12\n\x0c\n\x04\x04+\x02\0\x12\x04\xcc\
    \x06\x02\x13\n\r\n\x05\x04+\x02\0\x06\x12\x04\xcc\x06\x02\x05\n\r\n\x05\
    \x04+\x02\0\x01\x12\x04\xcc\x06\x06\x0e\n\r\n\x05\x04+\x02\0\x03\x12\x04\
    \xcc\x06\x11\x12\n\x0c\n\x04\x04+\x02\x01\x12\x04\xcd\x06\x02\x16\n\r\n\
    \x05\x04+\x02\x01\x05\x12\x04\xcd\x06\x02\x07\n\r\n\x05\x04+\x02\x01\x01\
    \x12\x04\xcd\x06\x08\x11\n\r\n\x05\x04+\x02\x01\x03\x12\x04\xcd\x06\x14\
    \x15\n\x0c\n\x02\x04,\x12\x06\xd0\x06\0\xd3\x06\x01\n\x0b\n\x03\x04,\x01\
    \x12\x04\xd0\x06\x08\x18\n\x0c\n\x04\x04,\x02\0\x12\x04\xd1\x06\x02\x11\
    \n\r\n\x05\x04,\x02\0\x05\x12\x04\xd1\x06\x02\x07\n\r\n\x05\x04,\x02\0\
    \x01\x12\x04\xd1\x06\x08\x0c\n\r\n\x05\x04,\x02\0\x03\x12\x04\xd1\x06\
    \x0f\x10\n\x0c\n\x04\x04,\x02\x01\x12\x04\xd2\x06\x02\x1f\n\r\n\x05\x04,\
    \x02\x01\x04\x12\x04\xd2\x06\x02\n\n\r\n\x05\x04,\x02\x01\x05\x12\x04\
    \xd2\x06\x0b\x10\n\r\n\x05\x04,\x02\x01\x01\x12\x04\xd2\x06\x11\x1a\n\r\
    \n\x05\x04,\x02\x01\x03\x12\x04\xd2\x06\x1d\x1e\n\x0c\n\x02\x04-\x12\x06\
    \xd5\x06\0\xd7\x06\x01\n\x0b\n\x03\x04-\x01\x12\x04\xd5\x06\x08\x0b\n\
    \x0c\n\x04\x04-\x02\0\x12\x04\xd6\x06\x02\x1f\n\r\n\x05\x04-\x02\0\x04\
    \x12\x04\xd6\x06\x02\n\n\r\n\x05\x04-\x02\0\x05\x12\x04\xd6\x06\x0b\x10\
    \n\r\n\x05\x04-\x02\0\x01\x12\x04\xd6\x06\x11\x1a\n\r\n\x05\x04-\x02\0\
    \x03\x12\x04\xd6\x06\x1d\x1eb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(::protobuf::well_known_types::any::file_descriptor().clone());
            deps.push(super::Discover::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(76);
            messages.push(AccountId::generated_message_descriptor_data());
            messages.push(Vote::generated_message_descriptor_data());
            messages.push(Proposal::generated_message_descriptor_data());
            messages.push(Exchange::generated_message_descriptor_data());
            messages.push(MarketOrder::generated_message_descriptor_data());
            messages.push(MarketOrderList::generated_message_descriptor_data());
            messages.push(MarketOrderPairList::generated_message_descriptor_data());
            messages.push(MarketOrderPair::generated_message_descriptor_data());
            messages.push(MarketAccountOrder::generated_message_descriptor_data());
            messages.push(MarketPrice::generated_message_descriptor_data());
            messages.push(MarketPriceList::generated_message_descriptor_data());
            messages.push(MarketOrderIdList::generated_message_descriptor_data());
            messages.push(ChainParameters::generated_message_descriptor_data());
            messages.push(Account::generated_message_descriptor_data());
            messages.push(Key::generated_message_descriptor_data());
            messages.push(DelegatedResource::generated_message_descriptor_data());
            messages.push(Authority::generated_message_descriptor_data());
            messages.push(Permission::generated_message_descriptor_data());
            messages.push(Witness::generated_message_descriptor_data());
            messages.push(Votes::generated_message_descriptor_data());
            messages.push(TXOutput::generated_message_descriptor_data());
            messages.push(TXInput::generated_message_descriptor_data());
            messages.push(TXOutputs::generated_message_descriptor_data());
            messages.push(ResourceReceipt::generated_message_descriptor_data());
            messages.push(MarketOrderDetail::generated_message_descriptor_data());
            messages.push(Transaction::generated_message_descriptor_data());
            messages.push(TransactionInfo::generated_message_descriptor_data());
            messages.push(TransactionRet::generated_message_descriptor_data());
            messages.push(Transactions::generated_message_descriptor_data());
            messages.push(TransactionSign::generated_message_descriptor_data());
            messages.push(BlockHeader::generated_message_descriptor_data());
            messages.push(Block::generated_message_descriptor_data());
            messages.push(ChainInventory::generated_message_descriptor_data());
            messages.push(BlockInventory::generated_message_descriptor_data());
            messages.push(Inventory::generated_message_descriptor_data());
            messages.push(Items::generated_message_descriptor_data());
            messages.push(DynamicProperties::generated_message_descriptor_data());
            messages.push(DisconnectMessage::generated_message_descriptor_data());
            messages.push(HelloMessage::generated_message_descriptor_data());
            messages.push(InternalTransaction::generated_message_descriptor_data());
            messages.push(DelegatedResourceAccountIndex::generated_message_descriptor_data());
            messages.push(NodeInfo::generated_message_descriptor_data());
            messages.push(MetricsInfo::generated_message_descriptor_data());
            messages.push(PBFTMessage::generated_message_descriptor_data());
            messages.push(PBFTCommitResult::generated_message_descriptor_data());
            messages.push(SRL::generated_message_descriptor_data());
            messages.push(chain_parameters::ChainParameter::generated_message_descriptor_data());
            messages.push(account::Frozen::generated_message_descriptor_data());
            messages.push(account::AccountResource::generated_message_descriptor_data());
            messages.push(txinput::Raw::generated_message_descriptor_data());
            messages.push(transaction::Contract::generated_message_descriptor_data());
            messages.push(transaction::Result::generated_message_descriptor_data());
            messages.push(transaction::Raw::generated_message_descriptor_data());
            messages.push(transaction_info::Log::generated_message_descriptor_data());
            messages.push(block_header::Raw::generated_message_descriptor_data());
            messages.push(chain_inventory::BlockId::generated_message_descriptor_data());
            messages.push(block_inventory::BlockId::generated_message_descriptor_data());
            messages.push(hello_message::BlockId::generated_message_descriptor_data());
            messages.push(internal_transaction::CallValueInfo::generated_message_descriptor_data());
            messages.push(node_info::PeerInfo::generated_message_descriptor_data());
            messages.push(node_info::ConfigNodeInfo::generated_message_descriptor_data());
            messages.push(node_info::MachineInfo::generated_message_descriptor_data());
            messages.push(node_info::machine_info::MemoryDescInfo::generated_message_descriptor_data());
            messages.push(node_info::machine_info::DeadLockThreadInfo::generated_message_descriptor_data());
            messages.push(metrics_info::NodeInfo::generated_message_descriptor_data());
            messages.push(metrics_info::BlockChainInfo::generated_message_descriptor_data());
            messages.push(metrics_info::RateInfo::generated_message_descriptor_data());
            messages.push(metrics_info::NetInfo::generated_message_descriptor_data());
            messages.push(metrics_info::block_chain_info::Witness::generated_message_descriptor_data());
            messages.push(metrics_info::block_chain_info::DupWitness::generated_message_descriptor_data());
            messages.push(metrics_info::net_info::ApiInfo::generated_message_descriptor_data());
            messages.push(metrics_info::net_info::DisconnectionDetailInfo::generated_message_descriptor_data());
            messages.push(metrics_info::net_info::LatencyInfo::generated_message_descriptor_data());
            messages.push(metrics_info::net_info::api_info::ApiDetailInfo::generated_message_descriptor_data());
            messages.push(metrics_info::net_info::latency_info::LatencyDetailInfo::generated_message_descriptor_data());
            messages.push(pbftmessage::Raw::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(14);
            enums.push(AccountType::generated_enum_descriptor_data());
            enums.push(ReasonCode::generated_enum_descriptor_data());
            enums.push(proposal::State::generated_enum_descriptor_data());
            enums.push(market_order::State::generated_enum_descriptor_data());
            enums.push(permission::PermissionType::generated_enum_descriptor_data());
            enums.push(transaction::contract::ContractType::generated_enum_descriptor_data());
            enums.push(transaction::result::Code::generated_enum_descriptor_data());
            enums.push(transaction::result::ContractResult::generated_enum_descriptor_data());
            enums.push(transaction_info::Code::generated_enum_descriptor_data());
            enums.push(block_inventory::Type::generated_enum_descriptor_data());
            enums.push(inventory::InventoryType::generated_enum_descriptor_data());
            enums.push(items::ItemType::generated_enum_descriptor_data());
            enums.push(pbftmessage::MsgType::generated_enum_descriptor_data());
            enums.push(pbftmessage::DataType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}

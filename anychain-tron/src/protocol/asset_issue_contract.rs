// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `core/contract/asset_issue_contract.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.AssetIssueContract)
pub struct AssetIssueContract {
    // message fields
    // @@protoc_insertion_point(field:protocol.AssetIssueContract.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:protocol.AssetIssueContract.owner_address)
    pub owner_address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.AssetIssueContract.name)
    pub name: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.AssetIssueContract.abbr)
    pub abbr: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.AssetIssueContract.total_supply)
    pub total_supply: i64,
    // @@protoc_insertion_point(field:protocol.AssetIssueContract.frozen_supply)
    pub frozen_supply: ::std::vec::Vec<asset_issue_contract::FrozenSupply>,
    // @@protoc_insertion_point(field:protocol.AssetIssueContract.trx_num)
    pub trx_num: i32,
    // @@protoc_insertion_point(field:protocol.AssetIssueContract.precision)
    pub precision: i32,
    // @@protoc_insertion_point(field:protocol.AssetIssueContract.num)
    pub num: i32,
    // @@protoc_insertion_point(field:protocol.AssetIssueContract.start_time)
    pub start_time: i64,
    // @@protoc_insertion_point(field:protocol.AssetIssueContract.end_time)
    pub end_time: i64,
    // @@protoc_insertion_point(field:protocol.AssetIssueContract.order)
    pub order: i64,
    // @@protoc_insertion_point(field:protocol.AssetIssueContract.vote_score)
    pub vote_score: i32,
    // @@protoc_insertion_point(field:protocol.AssetIssueContract.description)
    pub description: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.AssetIssueContract.url)
    pub url: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.AssetIssueContract.free_asset_net_limit)
    pub free_asset_net_limit: i64,
    // @@protoc_insertion_point(field:protocol.AssetIssueContract.public_free_asset_net_limit)
    pub public_free_asset_net_limit: i64,
    // @@protoc_insertion_point(field:protocol.AssetIssueContract.public_free_asset_net_usage)
    pub public_free_asset_net_usage: i64,
    // @@protoc_insertion_point(field:protocol.AssetIssueContract.public_latest_free_net_time)
    pub public_latest_free_net_time: i64,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.AssetIssueContract.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AssetIssueContract {
    fn default() -> &'a AssetIssueContract {
        <AssetIssueContract as ::protobuf::Message>::default_instance()
    }
}

impl AssetIssueContract {
    pub fn new() -> AssetIssueContract {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &AssetIssueContract| { &m.id },
            |m: &mut AssetIssueContract| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "owner_address",
            |m: &AssetIssueContract| { &m.owner_address },
            |m: &mut AssetIssueContract| { &mut m.owner_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &AssetIssueContract| { &m.name },
            |m: &mut AssetIssueContract| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "abbr",
            |m: &AssetIssueContract| { &m.abbr },
            |m: &mut AssetIssueContract| { &mut m.abbr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_supply",
            |m: &AssetIssueContract| { &m.total_supply },
            |m: &mut AssetIssueContract| { &mut m.total_supply },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "frozen_supply",
            |m: &AssetIssueContract| { &m.frozen_supply },
            |m: &mut AssetIssueContract| { &mut m.frozen_supply },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trx_num",
            |m: &AssetIssueContract| { &m.trx_num },
            |m: &mut AssetIssueContract| { &mut m.trx_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "precision",
            |m: &AssetIssueContract| { &m.precision },
            |m: &mut AssetIssueContract| { &mut m.precision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num",
            |m: &AssetIssueContract| { &m.num },
            |m: &mut AssetIssueContract| { &mut m.num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start_time",
            |m: &AssetIssueContract| { &m.start_time },
            |m: &mut AssetIssueContract| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "end_time",
            |m: &AssetIssueContract| { &m.end_time },
            |m: &mut AssetIssueContract| { &mut m.end_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "order",
            |m: &AssetIssueContract| { &m.order },
            |m: &mut AssetIssueContract| { &mut m.order },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vote_score",
            |m: &AssetIssueContract| { &m.vote_score },
            |m: &mut AssetIssueContract| { &mut m.vote_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &AssetIssueContract| { &m.description },
            |m: &mut AssetIssueContract| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &AssetIssueContract| { &m.url },
            |m: &mut AssetIssueContract| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "free_asset_net_limit",
            |m: &AssetIssueContract| { &m.free_asset_net_limit },
            |m: &mut AssetIssueContract| { &mut m.free_asset_net_limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "public_free_asset_net_limit",
            |m: &AssetIssueContract| { &m.public_free_asset_net_limit },
            |m: &mut AssetIssueContract| { &mut m.public_free_asset_net_limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "public_free_asset_net_usage",
            |m: &AssetIssueContract| { &m.public_free_asset_net_usage },
            |m: &mut AssetIssueContract| { &mut m.public_free_asset_net_usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "public_latest_free_net_time",
            |m: &AssetIssueContract| { &m.public_latest_free_net_time },
            |m: &mut AssetIssueContract| { &mut m.public_latest_free_net_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AssetIssueContract>(
            "AssetIssueContract",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AssetIssueContract {
    const NAME: &'static str = "AssetIssueContract";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                330 => {
                    self.id = is.read_string()?;
                },
                10 => {
                    self.owner_address = is.read_bytes()?;
                },
                18 => {
                    self.name = is.read_bytes()?;
                },
                26 => {
                    self.abbr = is.read_bytes()?;
                },
                32 => {
                    self.total_supply = is.read_int64()?;
                },
                42 => {
                    self.frozen_supply.push(is.read_message()?);
                },
                48 => {
                    self.trx_num = is.read_int32()?;
                },
                56 => {
                    self.precision = is.read_int32()?;
                },
                64 => {
                    self.num = is.read_int32()?;
                },
                72 => {
                    self.start_time = is.read_int64()?;
                },
                80 => {
                    self.end_time = is.read_int64()?;
                },
                88 => {
                    self.order = is.read_int64()?;
                },
                128 => {
                    self.vote_score = is.read_int32()?;
                },
                162 => {
                    self.description = is.read_bytes()?;
                },
                170 => {
                    self.url = is.read_bytes()?;
                },
                176 => {
                    self.free_asset_net_limit = is.read_int64()?;
                },
                184 => {
                    self.public_free_asset_net_limit = is.read_int64()?;
                },
                192 => {
                    self.public_free_asset_net_usage = is.read_int64()?;
                },
                200 => {
                    self.public_latest_free_net_time = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(41, &self.id);
        }
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.name);
        }
        if !self.abbr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.abbr);
        }
        if self.total_supply != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.total_supply);
        }
        for value in &self.frozen_supply {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.trx_num != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.trx_num);
        }
        if self.precision != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.precision);
        }
        if self.num != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.num);
        }
        if self.start_time != 0 {
            my_size += ::protobuf::rt::int64_size(9, self.start_time);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::int64_size(10, self.end_time);
        }
        if self.order != 0 {
            my_size += ::protobuf::rt::int64_size(11, self.order);
        }
        if self.vote_score != 0 {
            my_size += ::protobuf::rt::int32_size(16, self.vote_score);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::bytes_size(20, &self.description);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::bytes_size(21, &self.url);
        }
        if self.free_asset_net_limit != 0 {
            my_size += ::protobuf::rt::int64_size(22, self.free_asset_net_limit);
        }
        if self.public_free_asset_net_limit != 0 {
            my_size += ::protobuf::rt::int64_size(23, self.public_free_asset_net_limit);
        }
        if self.public_free_asset_net_usage != 0 {
            my_size += ::protobuf::rt::int64_size(24, self.public_free_asset_net_usage);
        }
        if self.public_latest_free_net_time != 0 {
            my_size += ::protobuf::rt::int64_size(25, self.public_latest_free_net_time);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(41, &self.id)?;
        }
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.name.is_empty() {
            os.write_bytes(2, &self.name)?;
        }
        if !self.abbr.is_empty() {
            os.write_bytes(3, &self.abbr)?;
        }
        if self.total_supply != 0 {
            os.write_int64(4, self.total_supply)?;
        }
        for v in &self.frozen_supply {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if self.trx_num != 0 {
            os.write_int32(6, self.trx_num)?;
        }
        if self.precision != 0 {
            os.write_int32(7, self.precision)?;
        }
        if self.num != 0 {
            os.write_int32(8, self.num)?;
        }
        if self.start_time != 0 {
            os.write_int64(9, self.start_time)?;
        }
        if self.end_time != 0 {
            os.write_int64(10, self.end_time)?;
        }
        if self.order != 0 {
            os.write_int64(11, self.order)?;
        }
        if self.vote_score != 0 {
            os.write_int32(16, self.vote_score)?;
        }
        if !self.description.is_empty() {
            os.write_bytes(20, &self.description)?;
        }
        if !self.url.is_empty() {
            os.write_bytes(21, &self.url)?;
        }
        if self.free_asset_net_limit != 0 {
            os.write_int64(22, self.free_asset_net_limit)?;
        }
        if self.public_free_asset_net_limit != 0 {
            os.write_int64(23, self.public_free_asset_net_limit)?;
        }
        if self.public_free_asset_net_usage != 0 {
            os.write_int64(24, self.public_free_asset_net_usage)?;
        }
        if self.public_latest_free_net_time != 0 {
            os.write_int64(25, self.public_latest_free_net_time)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AssetIssueContract {
        AssetIssueContract::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.owner_address.clear();
        self.name.clear();
        self.abbr.clear();
        self.total_supply = 0;
        self.frozen_supply.clear();
        self.trx_num = 0;
        self.precision = 0;
        self.num = 0;
        self.start_time = 0;
        self.end_time = 0;
        self.order = 0;
        self.vote_score = 0;
        self.description.clear();
        self.url.clear();
        self.free_asset_net_limit = 0;
        self.public_free_asset_net_limit = 0;
        self.public_free_asset_net_usage = 0;
        self.public_latest_free_net_time = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AssetIssueContract {
        static instance: AssetIssueContract = AssetIssueContract {
            id: ::std::string::String::new(),
            owner_address: ::std::vec::Vec::new(),
            name: ::std::vec::Vec::new(),
            abbr: ::std::vec::Vec::new(),
            total_supply: 0,
            frozen_supply: ::std::vec::Vec::new(),
            trx_num: 0,
            precision: 0,
            num: 0,
            start_time: 0,
            end_time: 0,
            order: 0,
            vote_score: 0,
            description: ::std::vec::Vec::new(),
            url: ::std::vec::Vec::new(),
            free_asset_net_limit: 0,
            public_free_asset_net_limit: 0,
            public_free_asset_net_usage: 0,
            public_latest_free_net_time: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AssetIssueContract {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AssetIssueContract").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AssetIssueContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssetIssueContract {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `AssetIssueContract`
pub mod asset_issue_contract {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:protocol.AssetIssueContract.FrozenSupply)
    pub struct FrozenSupply {
        // message fields
        // @@protoc_insertion_point(field:protocol.AssetIssueContract.FrozenSupply.frozen_amount)
        pub frozen_amount: i64,
        // @@protoc_insertion_point(field:protocol.AssetIssueContract.FrozenSupply.frozen_days)
        pub frozen_days: i64,
        // special fields
        // @@protoc_insertion_point(special_field:protocol.AssetIssueContract.FrozenSupply.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FrozenSupply {
        fn default() -> &'a FrozenSupply {
            <FrozenSupply as ::protobuf::Message>::default_instance()
        }
    }

    impl FrozenSupply {
        pub fn new() -> FrozenSupply {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "frozen_amount",
                |m: &FrozenSupply| { &m.frozen_amount },
                |m: &mut FrozenSupply| { &mut m.frozen_amount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "frozen_days",
                |m: &FrozenSupply| { &m.frozen_days },
                |m: &mut FrozenSupply| { &mut m.frozen_days },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FrozenSupply>(
                "AssetIssueContract.FrozenSupply",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FrozenSupply {
        const NAME: &'static str = "FrozenSupply";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.frozen_amount = is.read_int64()?;
                    },
                    16 => {
                        self.frozen_days = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.frozen_amount != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.frozen_amount);
            }
            if self.frozen_days != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.frozen_days);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.frozen_amount != 0 {
                os.write_int64(1, self.frozen_amount)?;
            }
            if self.frozen_days != 0 {
                os.write_int64(2, self.frozen_days)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FrozenSupply {
            FrozenSupply::new()
        }

        fn clear(&mut self) {
            self.frozen_amount = 0;
            self.frozen_days = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FrozenSupply {
            static instance: FrozenSupply = FrozenSupply {
                frozen_amount: 0,
                frozen_days: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FrozenSupply {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("AssetIssueContract.FrozenSupply").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FrozenSupply {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FrozenSupply {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.TransferAssetContract)
pub struct TransferAssetContract {
    // message fields
    // @@protoc_insertion_point(field:protocol.TransferAssetContract.asset_name)
    pub asset_name: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.TransferAssetContract.owner_address)
    pub owner_address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.TransferAssetContract.to_address)
    pub to_address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.TransferAssetContract.amount)
    pub amount: i64,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.TransferAssetContract.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransferAssetContract {
    fn default() -> &'a TransferAssetContract {
        <TransferAssetContract as ::protobuf::Message>::default_instance()
    }
}

impl TransferAssetContract {
    pub fn new() -> TransferAssetContract {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "asset_name",
            |m: &TransferAssetContract| { &m.asset_name },
            |m: &mut TransferAssetContract| { &mut m.asset_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "owner_address",
            |m: &TransferAssetContract| { &m.owner_address },
            |m: &mut TransferAssetContract| { &mut m.owner_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "to_address",
            |m: &TransferAssetContract| { &m.to_address },
            |m: &mut TransferAssetContract| { &mut m.to_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "amount",
            |m: &TransferAssetContract| { &m.amount },
            |m: &mut TransferAssetContract| { &mut m.amount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransferAssetContract>(
            "TransferAssetContract",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransferAssetContract {
    const NAME: &'static str = "TransferAssetContract";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.asset_name = is.read_bytes()?;
                },
                18 => {
                    self.owner_address = is.read_bytes()?;
                },
                26 => {
                    self.to_address = is.read_bytes()?;
                },
                32 => {
                    self.amount = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.asset_name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.asset_name);
        }
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.owner_address);
        }
        if !self.to_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.to_address);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.amount);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.asset_name.is_empty() {
            os.write_bytes(1, &self.asset_name)?;
        }
        if !self.owner_address.is_empty() {
            os.write_bytes(2, &self.owner_address)?;
        }
        if !self.to_address.is_empty() {
            os.write_bytes(3, &self.to_address)?;
        }
        if self.amount != 0 {
            os.write_int64(4, self.amount)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransferAssetContract {
        TransferAssetContract::new()
    }

    fn clear(&mut self) {
        self.asset_name.clear();
        self.owner_address.clear();
        self.to_address.clear();
        self.amount = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransferAssetContract {
        static instance: TransferAssetContract = TransferAssetContract {
            asset_name: ::std::vec::Vec::new(),
            owner_address: ::std::vec::Vec::new(),
            to_address: ::std::vec::Vec::new(),
            amount: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransferAssetContract {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransferAssetContract").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransferAssetContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransferAssetContract {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.UnfreezeAssetContract)
pub struct UnfreezeAssetContract {
    // message fields
    // @@protoc_insertion_point(field:protocol.UnfreezeAssetContract.owner_address)
    pub owner_address: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.UnfreezeAssetContract.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnfreezeAssetContract {
    fn default() -> &'a UnfreezeAssetContract {
        <UnfreezeAssetContract as ::protobuf::Message>::default_instance()
    }
}

impl UnfreezeAssetContract {
    pub fn new() -> UnfreezeAssetContract {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "owner_address",
            |m: &UnfreezeAssetContract| { &m.owner_address },
            |m: &mut UnfreezeAssetContract| { &mut m.owner_address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnfreezeAssetContract>(
            "UnfreezeAssetContract",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnfreezeAssetContract {
    const NAME: &'static str = "UnfreezeAssetContract";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.owner_address = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnfreezeAssetContract {
        UnfreezeAssetContract::new()
    }

    fn clear(&mut self) {
        self.owner_address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnfreezeAssetContract {
        static instance: UnfreezeAssetContract = UnfreezeAssetContract {
            owner_address: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnfreezeAssetContract {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnfreezeAssetContract").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnfreezeAssetContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnfreezeAssetContract {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.UpdateAssetContract)
pub struct UpdateAssetContract {
    // message fields
    // @@protoc_insertion_point(field:protocol.UpdateAssetContract.owner_address)
    pub owner_address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.UpdateAssetContract.description)
    pub description: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.UpdateAssetContract.url)
    pub url: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.UpdateAssetContract.new_limit)
    pub new_limit: i64,
    // @@protoc_insertion_point(field:protocol.UpdateAssetContract.new_public_limit)
    pub new_public_limit: i64,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.UpdateAssetContract.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateAssetContract {
    fn default() -> &'a UpdateAssetContract {
        <UpdateAssetContract as ::protobuf::Message>::default_instance()
    }
}

impl UpdateAssetContract {
    pub fn new() -> UpdateAssetContract {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "owner_address",
            |m: &UpdateAssetContract| { &m.owner_address },
            |m: &mut UpdateAssetContract| { &mut m.owner_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &UpdateAssetContract| { &m.description },
            |m: &mut UpdateAssetContract| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &UpdateAssetContract| { &m.url },
            |m: &mut UpdateAssetContract| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "new_limit",
            |m: &UpdateAssetContract| { &m.new_limit },
            |m: &mut UpdateAssetContract| { &mut m.new_limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "new_public_limit",
            |m: &UpdateAssetContract| { &m.new_public_limit },
            |m: &mut UpdateAssetContract| { &mut m.new_public_limit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateAssetContract>(
            "UpdateAssetContract",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateAssetContract {
    const NAME: &'static str = "UpdateAssetContract";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.owner_address = is.read_bytes()?;
                },
                18 => {
                    self.description = is.read_bytes()?;
                },
                26 => {
                    self.url = is.read_bytes()?;
                },
                32 => {
                    self.new_limit = is.read_int64()?;
                },
                40 => {
                    self.new_public_limit = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.description);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.url);
        }
        if self.new_limit != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.new_limit);
        }
        if self.new_public_limit != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.new_public_limit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.description.is_empty() {
            os.write_bytes(2, &self.description)?;
        }
        if !self.url.is_empty() {
            os.write_bytes(3, &self.url)?;
        }
        if self.new_limit != 0 {
            os.write_int64(4, self.new_limit)?;
        }
        if self.new_public_limit != 0 {
            os.write_int64(5, self.new_public_limit)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateAssetContract {
        UpdateAssetContract::new()
    }

    fn clear(&mut self) {
        self.owner_address.clear();
        self.description.clear();
        self.url.clear();
        self.new_limit = 0;
        self.new_public_limit = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateAssetContract {
        static instance: UpdateAssetContract = UpdateAssetContract {
            owner_address: ::std::vec::Vec::new(),
            description: ::std::vec::Vec::new(),
            url: ::std::vec::Vec::new(),
            new_limit: 0,
            new_public_limit: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateAssetContract {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateAssetContract").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateAssetContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateAssetContract {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protocol.ParticipateAssetIssueContract)
pub struct ParticipateAssetIssueContract {
    // message fields
    // @@protoc_insertion_point(field:protocol.ParticipateAssetIssueContract.owner_address)
    pub owner_address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.ParticipateAssetIssueContract.to_address)
    pub to_address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.ParticipateAssetIssueContract.asset_name)
    pub asset_name: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protocol.ParticipateAssetIssueContract.amount)
    pub amount: i64,
    // special fields
    // @@protoc_insertion_point(special_field:protocol.ParticipateAssetIssueContract.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ParticipateAssetIssueContract {
    fn default() -> &'a ParticipateAssetIssueContract {
        <ParticipateAssetIssueContract as ::protobuf::Message>::default_instance()
    }
}

impl ParticipateAssetIssueContract {
    pub fn new() -> ParticipateAssetIssueContract {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "owner_address",
            |m: &ParticipateAssetIssueContract| { &m.owner_address },
            |m: &mut ParticipateAssetIssueContract| { &mut m.owner_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "to_address",
            |m: &ParticipateAssetIssueContract| { &m.to_address },
            |m: &mut ParticipateAssetIssueContract| { &mut m.to_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "asset_name",
            |m: &ParticipateAssetIssueContract| { &m.asset_name },
            |m: &mut ParticipateAssetIssueContract| { &mut m.asset_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "amount",
            |m: &ParticipateAssetIssueContract| { &m.amount },
            |m: &mut ParticipateAssetIssueContract| { &mut m.amount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ParticipateAssetIssueContract>(
            "ParticipateAssetIssueContract",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ParticipateAssetIssueContract {
    const NAME: &'static str = "ParticipateAssetIssueContract";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.owner_address = is.read_bytes()?;
                },
                18 => {
                    self.to_address = is.read_bytes()?;
                },
                26 => {
                    self.asset_name = is.read_bytes()?;
                },
                32 => {
                    self.amount = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.to_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.to_address);
        }
        if !self.asset_name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.asset_name);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.amount);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.to_address.is_empty() {
            os.write_bytes(2, &self.to_address)?;
        }
        if !self.asset_name.is_empty() {
            os.write_bytes(3, &self.asset_name)?;
        }
        if self.amount != 0 {
            os.write_int64(4, self.amount)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ParticipateAssetIssueContract {
        ParticipateAssetIssueContract::new()
    }

    fn clear(&mut self) {
        self.owner_address.clear();
        self.to_address.clear();
        self.asset_name.clear();
        self.amount = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ParticipateAssetIssueContract {
        static instance: ParticipateAssetIssueContract = ParticipateAssetIssueContract {
            owner_address: ::std::vec::Vec::new(),
            to_address: ::std::vec::Vec::new(),
            asset_name: ::std::vec::Vec::new(),
            amount: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ParticipateAssetIssueContract {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ParticipateAssetIssueContract").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ParticipateAssetIssueContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParticipateAssetIssueContract {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n(core/contract/asset_issue_contract.proto\x12\x08protocol\"\x91\x06\n\
    \x12AssetIssueContract\x12\x0e\n\x02id\x18)\x20\x01(\tR\x02id\x12#\n\row\
    ner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12\x12\n\x04name\x18\
    \x02\x20\x01(\x0cR\x04name\x12\x12\n\x04abbr\x18\x03\x20\x01(\x0cR\x04ab\
    br\x12!\n\x0ctotal_supply\x18\x04\x20\x01(\x03R\x0btotalSupply\x12N\n\rf\
    rozen_supply\x18\x05\x20\x03(\x0b2).protocol.AssetIssueContract.FrozenSu\
    pplyR\x0cfrozenSupply\x12\x17\n\x07trx_num\x18\x06\x20\x01(\x05R\x06trxN\
    um\x12\x1c\n\tprecision\x18\x07\x20\x01(\x05R\tprecision\x12\x10\n\x03nu\
    m\x18\x08\x20\x01(\x05R\x03num\x12\x1d\n\nstart_time\x18\t\x20\x01(\x03R\
    \tstartTime\x12\x19\n\x08end_time\x18\n\x20\x01(\x03R\x07endTime\x12\x14\
    \n\x05order\x18\x0b\x20\x01(\x03R\x05order\x12\x1d\n\nvote_score\x18\x10\
    \x20\x01(\x05R\tvoteScore\x12\x20\n\x0bdescription\x18\x14\x20\x01(\x0cR\
    \x0bdescription\x12\x10\n\x03url\x18\x15\x20\x01(\x0cR\x03url\x12/\n\x14\
    free_asset_net_limit\x18\x16\x20\x01(\x03R\x11freeAssetNetLimit\x12<\n\
    \x1bpublic_free_asset_net_limit\x18\x17\x20\x01(\x03R\x17publicFreeAsset\
    NetLimit\x12<\n\x1bpublic_free_asset_net_usage\x18\x18\x20\x01(\x03R\x17\
    publicFreeAssetNetUsage\x12<\n\x1bpublic_latest_free_net_time\x18\x19\
    \x20\x01(\x03R\x17publicLatestFreeNetTime\x1aT\n\x0cFrozenSupply\x12#\n\
    \rfrozen_amount\x18\x01\x20\x01(\x03R\x0cfrozenAmount\x12\x1f\n\x0bfroze\
    n_days\x18\x02\x20\x01(\x03R\nfrozenDays\"\x92\x01\n\x15TransferAssetCon\
    tract\x12\x1d\n\nasset_name\x18\x01\x20\x01(\x0cR\tassetName\x12#\n\rown\
    er_address\x18\x02\x20\x01(\x0cR\x0cownerAddress\x12\x1d\n\nto_address\
    \x18\x03\x20\x01(\x0cR\ttoAddress\x12\x16\n\x06amount\x18\x04\x20\x01(\
    \x03R\x06amount\"<\n\x15UnfreezeAssetContract\x12#\n\rowner_address\x18\
    \x01\x20\x01(\x0cR\x0cownerAddress\"\xb5\x01\n\x13UpdateAssetContract\
    \x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12\x20\n\
    \x0bdescription\x18\x02\x20\x01(\x0cR\x0bdescription\x12\x10\n\x03url\
    \x18\x03\x20\x01(\x0cR\x03url\x12\x1b\n\tnew_limit\x18\x04\x20\x01(\x03R\
    \x08newLimit\x12(\n\x10new_public_limit\x18\x05\x20\x01(\x03R\x0enewPubl\
    icLimit\"\x9a\x01\n\x1dParticipateAssetIssueContract\x12#\n\rowner_addre\
    ss\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12\x1d\n\nto_address\x18\x02\
    \x20\x01(\x0cR\ttoAddress\x12\x1d\n\nasset_name\x18\x03\x20\x01(\x0cR\ta\
    ssetName\x12\x16\n\x06amount\x18\x04\x20\x01(\x03R\x06amountBE\n\x18org.\
    tron.protos.contractZ)github.com/tronprotocol/grpc-gateway/coreJ\xf2\x14\
    \n\x06\x12\x04\0\0;\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\
    \x12\x03\x02\0\x11\n\x08\n\x01\x08\x12\x03\x04\01\nH\n\x02\x08\x01\x12\
    \x03\x04\01\"=Specify\x20the\x20name\x20of\x20the\x20package\x20that\x20\
    generated\x20the\x20Java\x20file\n\n\x08\n\x01\x08\x12\x03\x06\0@\ns\n\
    \x02\x08\x0b\x12\x03\x06\0@\x1ahoption\x20java_outer_classname\x20=\x20\
    \"AssetIssueContract\";\x20//Specify\x20the\x20class\x20name\x20of\x20th\
    e\x20generated\x20Java\x20file\n\n\n\n\x02\x04\0\x12\x04\x08\0!\x01\n\n\
    \n\x03\x04\0\x01\x12\x03\x08\x08\x1a\n\x0b\n\x04\x04\0\x02\0\x12\x03\t\
    \x02\x11\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\t\x02\x08\n\x0c\n\x05\x04\0\
    \x02\0\x01\x12\x03\t\t\x0b\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\t\x0e\x10\
    \n\x0c\n\x04\x04\0\x03\0\x12\x04\x0b\x02\x0e\x03\n\x0c\n\x05\x04\0\x03\0\
    \x01\x12\x03\x0b\n\x16\n\r\n\x06\x04\0\x03\0\x02\0\x12\x03\x0c\x04\x1c\n\
    \x0e\n\x07\x04\0\x03\0\x02\0\x05\x12\x03\x0c\x04\t\n\x0e\n\x07\x04\0\x03\
    \0\x02\0\x01\x12\x03\x0c\n\x17\n\x0e\n\x07\x04\0\x03\0\x02\0\x03\x12\x03\
    \x0c\x1a\x1b\n\r\n\x06\x04\0\x03\0\x02\x01\x12\x03\r\x04\x1a\n\x0e\n\x07\
    \x04\0\x03\0\x02\x01\x05\x12\x03\r\x04\t\n\x0e\n\x07\x04\0\x03\0\x02\x01\
    \x01\x12\x03\r\n\x15\n\x0e\n\x07\x04\0\x03\0\x02\x01\x03\x12\x03\r\x18\
    \x19\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x0f\x02\x1a\n\x0c\n\x05\x04\0\x02\
    \x01\x05\x12\x03\x0f\x02\x07\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x0f\
    \x08\x15\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x0f\x18\x19\n\x0b\n\x04\
    \x04\0\x02\x02\x12\x03\x10\x02\x11\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\
    \x10\x02\x07\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x10\x08\x0c\n\x0c\n\
    \x05\x04\0\x02\x02\x03\x12\x03\x10\x0f\x10\n\x0b\n\x04\x04\0\x02\x03\x12\
    \x03\x11\x02\x11\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03\x11\x02\x07\n\x0c\
    \n\x05\x04\0\x02\x03\x01\x12\x03\x11\x08\x0c\n\x0c\n\x05\x04\0\x02\x03\
    \x03\x12\x03\x11\x0f\x10\n\x0b\n\x04\x04\0\x02\x04\x12\x03\x12\x02\x19\n\
    \x0c\n\x05\x04\0\x02\x04\x05\x12\x03\x12\x02\x07\n\x0c\n\x05\x04\0\x02\
    \x04\x01\x12\x03\x12\x08\x14\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03\x12\
    \x17\x18\n\x0b\n\x04\x04\0\x02\x05\x12\x03\x13\x02*\n\x0c\n\x05\x04\0\
    \x02\x05\x04\x12\x03\x13\x02\n\n\x0c\n\x05\x04\0\x02\x05\x06\x12\x03\x13\
    \x0b\x17\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03\x13\x18%\n\x0c\n\x05\x04\
    \0\x02\x05\x03\x12\x03\x13()\n\x0b\n\x04\x04\0\x02\x06\x12\x03\x14\x02\
    \x14\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03\x14\x02\x07\n\x0c\n\x05\x04\0\
    \x02\x06\x01\x12\x03\x14\x08\x0f\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03\
    \x14\x12\x13\n\x0b\n\x04\x04\0\x02\x07\x12\x03\x15\x02\x16\n\x0c\n\x05\
    \x04\0\x02\x07\x05\x12\x03\x15\x02\x07\n\x0c\n\x05\x04\0\x02\x07\x01\x12\
    \x03\x15\x08\x11\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03\x15\x14\x15\n\x0b\
    \n\x04\x04\0\x02\x08\x12\x03\x16\x02\x10\n\x0c\n\x05\x04\0\x02\x08\x05\
    \x12\x03\x16\x02\x07\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03\x16\x08\x0b\n\
    \x0c\n\x05\x04\0\x02\x08\x03\x12\x03\x16\x0e\x0f\n\x0b\n\x04\x04\0\x02\t\
    \x12\x03\x17\x02\x17\n\x0c\n\x05\x04\0\x02\t\x05\x12\x03\x17\x02\x07\n\
    \x0c\n\x05\x04\0\x02\t\x01\x12\x03\x17\x08\x12\n\x0c\n\x05\x04\0\x02\t\
    \x03\x12\x03\x17\x15\x16\n\x0b\n\x04\x04\0\x02\n\x12\x03\x18\x02\x16\n\
    \x0c\n\x05\x04\0\x02\n\x05\x12\x03\x18\x02\x07\n\x0c\n\x05\x04\0\x02\n\
    \x01\x12\x03\x18\x08\x10\n\x0c\n\x05\x04\0\x02\n\x03\x12\x03\x18\x13\x15\
    \n\x16\n\x04\x04\0\x02\x0b\x12\x03\x19\x02\x13\"\t\x20useless\n\n\x0c\n\
    \x05\x04\0\x02\x0b\x05\x12\x03\x19\x02\x07\n\x0c\n\x05\x04\0\x02\x0b\x01\
    \x12\x03\x19\x08\r\n\x0c\n\x05\x04\0\x02\x0b\x03\x12\x03\x19\x10\x12\n\
    \x0b\n\x04\x04\0\x02\x0c\x12\x03\x1a\x02\x18\n\x0c\n\x05\x04\0\x02\x0c\
    \x05\x12\x03\x1a\x02\x07\n\x0c\n\x05\x04\0\x02\x0c\x01\x12\x03\x1a\x08\
    \x12\n\x0c\n\x05\x04\0\x02\x0c\x03\x12\x03\x1a\x15\x17\n\x0b\n\x04\x04\0\
    \x02\r\x12\x03\x1b\x02\x19\n\x0c\n\x05\x04\0\x02\r\x05\x12\x03\x1b\x02\
    \x07\n\x0c\n\x05\x04\0\x02\r\x01\x12\x03\x1b\x08\x13\n\x0c\n\x05\x04\0\
    \x02\r\x03\x12\x03\x1b\x16\x18\n\x0b\n\x04\x04\0\x02\x0e\x12\x03\x1c\x02\
    \x11\n\x0c\n\x05\x04\0\x02\x0e\x05\x12\x03\x1c\x02\x07\n\x0c\n\x05\x04\0\
    \x02\x0e\x01\x12\x03\x1c\x08\x0b\n\x0c\n\x05\x04\0\x02\x0e\x03\x12\x03\
    \x1c\x0e\x10\n\x0b\n\x04\x04\0\x02\x0f\x12\x03\x1d\x02\"\n\x0c\n\x05\x04\
    \0\x02\x0f\x05\x12\x03\x1d\x02\x07\n\x0c\n\x05\x04\0\x02\x0f\x01\x12\x03\
    \x1d\x08\x1c\n\x0c\n\x05\x04\0\x02\x0f\x03\x12\x03\x1d\x1f!\n\x0b\n\x04\
    \x04\0\x02\x10\x12\x03\x1e\x02)\n\x0c\n\x05\x04\0\x02\x10\x05\x12\x03\
    \x1e\x02\x07\n\x0c\n\x05\x04\0\x02\x10\x01\x12\x03\x1e\x08#\n\x0c\n\x05\
    \x04\0\x02\x10\x03\x12\x03\x1e&(\n\x0b\n\x04\x04\0\x02\x11\x12\x03\x1f\
    \x02)\n\x0c\n\x05\x04\0\x02\x11\x05\x12\x03\x1f\x02\x07\n\x0c\n\x05\x04\
    \0\x02\x11\x01\x12\x03\x1f\x08#\n\x0c\n\x05\x04\0\x02\x11\x03\x12\x03\
    \x1f&(\n\x0b\n\x04\x04\0\x02\x12\x12\x03\x20\x02)\n\x0c\n\x05\x04\0\x02\
    \x12\x05\x12\x03\x20\x02\x07\n\x0c\n\x05\x04\0\x02\x12\x01\x12\x03\x20\
    \x08#\n\x0c\n\x05\x04\0\x02\x12\x03\x12\x03\x20&(\n\n\n\x02\x04\x01\x12\
    \x04#\0(\x01\n\n\n\x03\x04\x01\x01\x12\x03#\x08\x1d\n\x9f\x01\n\x04\x04\
    \x01\x02\0\x12\x03$\x02\x17\"\x91\x01\x20this\x20field\x20is\x20token\
    \x20name\x20before\x20the\x20proposal\x20ALLOW_SAME_TOKEN_NAME\x20is\x20\
    active,\x20otherwise\x20it\x20is\x20token\x20id\x20and\x20token\x20is\
    \x20should\x20be\x20in\x20string\x20format.\n\n\x0c\n\x05\x04\x01\x02\0\
    \x05\x12\x03$\x02\x07\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03$\x08\x12\n\
    \x0c\n\x05\x04\x01\x02\0\x03\x12\x03$\x15\x16\n\x0b\n\x04\x04\x01\x02\
    \x01\x12\x03%\x02\x1a\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03%\x02\x07\n\
    \x0c\n\x05\x04\x01\x02\x01\x01\x12\x03%\x08\x15\n\x0c\n\x05\x04\x01\x02\
    \x01\x03\x12\x03%\x18\x19\n\x0b\n\x04\x04\x01\x02\x02\x12\x03&\x02\x17\n\
    \x0c\n\x05\x04\x01\x02\x02\x05\x12\x03&\x02\x07\n\x0c\n\x05\x04\x01\x02\
    \x02\x01\x12\x03&\x08\x12\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03&\x15\
    \x16\n\x0b\n\x04\x04\x01\x02\x03\x12\x03'\x02\x13\n\x0c\n\x05\x04\x01\
    \x02\x03\x05\x12\x03'\x02\x07\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03'\
    \x08\x0e\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03'\x11\x12\n\n\n\x02\x04\
    \x02\x12\x04*\0,\x01\n\n\n\x03\x04\x02\x01\x12\x03*\x08\x1d\n\x0b\n\x04\
    \x04\x02\x02\0\x12\x03+\x02\x1a\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03+\
    \x02\x07\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03+\x08\x15\n\x0c\n\x05\x04\
    \x02\x02\0\x03\x12\x03+\x18\x19\n\n\n\x02\x04\x03\x12\x04.\04\x01\n\n\n\
    \x03\x04\x03\x01\x12\x03.\x08\x1b\n\x0b\n\x04\x04\x03\x02\0\x12\x03/\x02\
    \x1a\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03/\x02\x07\n\x0c\n\x05\x04\x03\
    \x02\0\x01\x12\x03/\x08\x15\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03/\x18\
    \x19\n\x0b\n\x04\x04\x03\x02\x01\x12\x030\x02\x18\n\x0c\n\x05\x04\x03\
    \x02\x01\x05\x12\x030\x02\x07\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x030\
    \x08\x13\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x030\x16\x17\n\x0b\n\x04\
    \x04\x03\x02\x02\x12\x031\x02\x10\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\
    \x031\x02\x07\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x031\x08\x0b\n\x0c\n\
    \x05\x04\x03\x02\x02\x03\x12\x031\x0e\x0f\n\x0b\n\x04\x04\x03\x02\x03\
    \x12\x032\x02\x16\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\x032\x02\x07\n\x0c\
    \n\x05\x04\x03\x02\x03\x01\x12\x032\x08\x11\n\x0c\n\x05\x04\x03\x02\x03\
    \x03\x12\x032\x14\x15\n\x0b\n\x04\x04\x03\x02\x04\x12\x033\x02\x1d\n\x0c\
    \n\x05\x04\x03\x02\x04\x05\x12\x033\x02\x07\n\x0c\n\x05\x04\x03\x02\x04\
    \x01\x12\x033\x08\x18\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\x033\x1b\x1c\n\
    \n\n\x02\x04\x04\x12\x046\0;\x01\n\n\n\x03\x04\x04\x01\x12\x036\x08%\n\
    \x0b\n\x04\x04\x04\x02\0\x12\x037\x02\x1a\n\x0c\n\x05\x04\x04\x02\0\x05\
    \x12\x037\x02\x07\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x037\x08\x15\n\x0c\n\
    \x05\x04\x04\x02\0\x03\x12\x037\x18\x19\n\x0b\n\x04\x04\x04\x02\x01\x12\
    \x038\x02\x17\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x038\x02\x07\n\x0c\n\
    \x05\x04\x04\x02\x01\x01\x12\x038\x08\x12\n\x0c\n\x05\x04\x04\x02\x01\
    \x03\x12\x038\x15\x16\n\x9f\x01\n\x04\x04\x04\x02\x02\x12\x039\x02\x17\"\
    \x91\x01\x20this\x20field\x20is\x20token\x20name\x20before\x20the\x20pro\
    posal\x20ALLOW_SAME_TOKEN_NAME\x20is\x20active,\x20otherwise\x20it\x20is\
    \x20token\x20id\x20and\x20token\x20is\x20should\x20be\x20in\x20string\
    \x20format.\n\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x039\x02\x07\n\x0c\n\
    \x05\x04\x04\x02\x02\x01\x12\x039\x08\x12\n\x0c\n\x05\x04\x04\x02\x02\
    \x03\x12\x039\x15\x16\n\"\n\x04\x04\x04\x02\x03\x12\x03:\x02\x13\"\x15\
    \x20the\x20amount\x20of\x20drops\n\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\
    \x03:\x02\x07\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\x03:\x08\x0e\n\x0c\n\
    \x05\x04\x04\x02\x03\x03\x12\x03:\x11\x12b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(6);
            messages.push(AssetIssueContract::generated_message_descriptor_data());
            messages.push(TransferAssetContract::generated_message_descriptor_data());
            messages.push(UnfreezeAssetContract::generated_message_descriptor_data());
            messages.push(UpdateAssetContract::generated_message_descriptor_data());
            messages.push(ParticipateAssetIssueContract::generated_message_descriptor_data());
            messages.push(asset_issue_contract::FrozenSupply::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
